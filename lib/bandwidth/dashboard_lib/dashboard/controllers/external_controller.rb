# bandwidth
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Bandwidth
module Dashboard
  # ExternalController
  class ExternalController < BaseController
    def initialize(config, http_call_back: nil)
      super(config, http_call_back: http_call_back)
    end

    # discover what is currently enabled on the account
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountProductsResponse] response from the API call
    def get_products(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountProductsResponse',
                                   AccountProductsResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] product_name Required parameter: Example:
    # @return [AccountProductResponse] response from the API call
    def get_account_product(account_id,
                            product_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/{productName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'productName' => { 'value' => product_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'AccountProductResponse',
                                   AccountProductResponse)
      )
    end

    # GET is used to retrieve all addresses.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] type Optional parameter: Example:
    # @param [String] e911locationid Optional parameter: Example:
    # @param [String] suggestions Optional parameter: Example:
    # @return [AddressesResponse] response from the API call
    def get_addresses(account_id,
                      page: nil,
                      size: nil,
                      type: nil,
                      e911locationid: nil,
                      suggestions: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/addresses'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'type' => type,
        'e911locationid' => e911locationid,
        'suggestions' => suggestions
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - if the account specified does not exist or is locked' \
          ' or there are no addresses for specified search' \
          ' criteria it will result in a not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'AddressesResponse',
                                   AddressesResponse)
      )
    end

    # GET is used to retrieve a detailed information of Alternate end user
    # identifier by acid.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] identifier Required parameter: Example:
    # @return [AlternateEndUserIdentifierResponse] response from the API call
    def get_aeui(account_id,
                 identifier)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/aeuis/{identifier}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'identifier' => { 'value' => identifier, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - if the account specified does not exist or is locked' \
          ' or there are no AEUI that corresponds to specified' \
          ' acid it will result in a "NOT FOUND" response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AlternateEndUserIdentifierResponse',
                                   AlternateEndUserIdentifierResponse)
      )
    end

    # GET is used to retrieve all Alternate end user identifiers.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] aeui Optional parameter: Example:
    # @param [String] callback Optional parameter: Example:
    # @param [Boolean] pidfloenabledonly Optional parameter: Example:
    # @param [String] suggestions Optional parameter: Example:
    # @param [String] callername Optional parameter: Example:
    # @param [String] location_id Optional parameter: Example:
    # @param [Integer] e911address_id Optional parameter: Example:
    # @return [AlternateEndUserIdentifiersResponse] response from the API call
    def get_aeuis_1(account_id,
                    page: nil,
                    size: nil,
                    aeui: nil,
                    callback: nil,
                    pidfloenabledonly: nil,
                    suggestions: nil,
                    callername: nil,
                    location_id: nil,
                    e911address_id: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/aeuis'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'aeui' => aeui,
        'callback' => callback,
        'pidfloenabledonly' => pidfloenabledonly,
        'suggestions' => suggestions,
        'callername' => callername,
        'locationId' => location_id,
        'e911addressId' => e911address_id
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - if the account specified does not exist or is locked' \
          ' or there are no AEUIs for specified search criteria it' \
          ' will result in a "NOT FOUND" response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AlternateEndUserIdentifiersResponse',
                                   AlternateEndUserIdentifiersResponse)
      )
    end

    # Lists all Applications<br><p><br>  <ul>    <li> CallbackCreds Password is
    # not returned in response for security reasons </li>  </ul></p>
    # @param [Integer] account_id Required parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def get_all_applications(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Create an Application, CallbackUrl field is deprecated field, use
    # MsgCallbackUrl instead
    # @param [Integer] account_id Required parameter: Example:
    # @param [ApplicationPayload] body Optional parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def create_application(account_id,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Application', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Retrieve an Application
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] application_id Required parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def get_application_by_id(account_id,
                              application_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications/{applicationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'applicationId' => { 'value' => application_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Update an Application. <br> <ul>    <li> ServiceType can have value of
    # Voice-V2 or Messaging-V2 but it can't be changed for existing application
    # </li> </ul>     <p>For ServiceType of Messaging-V2 <br>       <ul>        
    # <li> MsgCallbackUrl (CallbackUrl - is deprecated) is required </li>      
    # </ul>     </p>     <p>For ServiceType of Voice-V2       <ul>         <li>
    # CallInitiatedCallbackUrl - required for voice </li>         <li>
    # CallInitiatedMethod - optional for voice [POST|GET] default is POST if not
    # specified</li>         <li> CallStatusCallbackUrl - optional for voice
    # </li>         <li> CallStatusMethod - optional for voice [POST|GET]
    # default is POST if not specified </li>         <li>
    # CallInitiatedFallbackUrl - optional for voice </li>         <li>
    # CallInitiatedFallbackMethod - optional for voice [POST|GET] default is
    # POST if not specified </li>         <li> CallbackTimeout - optional for
    # voice. Range from 1 to 25 seconds. </li>       </ul>     </p>    
    # <p>CallbackCreds - can only be specified by External users       <ul>     
    #     <li> CallbackCreds with same UserId but different Password will change
    # password</li>          <li> If you want credentials, both UserId and
    # Password must be specified.</li>          <li> If you do not want
    # passwords, CallbackCreds should be omitted entirely.</li>          <li>
    # UserId and Password should have length between 6 and 63 symbols.</li>     
    #  </ul>     </p>     <p>CallInitiatedFallbackCreds - can only be specified
    # by External users      <ul>         <li> If you want credentials, both
    # UserId and Password must be specified.</li>         <li> If you do not
    # want passwords, CallInitiatedFallbackCreds should be omitted
    # entirely.</li>         <li> UserId and Password should have length between
    # 6 and 63 symbols.</li>       </ul>     </p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] application_id Required parameter: Example:
    # @param [ApplicationPayload] body Optional parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def update_application(account_id,
                           application_id,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications/{applicationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'applicationId' => { 'value' => application_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Application', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Delete an Application. <br>An Application cannot be removed from an
    # account if that Application is referenced by any Location associated with
    # the account.<br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] application_id Required parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def delete_application(account_id,
                           application_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications/{applicationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'applicationId' => { 'value' => application_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Patch update an Application<br> <ul>  <li> CallStatusCallbackUrl can be
    # removed by settings its value to 'remove'  </li> </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] application_id Required parameter: Example:
    # @param [ApplicationPayload] body Optional parameter: Example:
    # @return [ApplicationResponse] response from the API call
    def patch_application(account_id,
                          application_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications/{applicationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'applicationId' => { 'value' => application_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.patch(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Application', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ApplicationProvisioningResponse',
                                   ApplicationResponse)
      )
    end

    # Retrieve a list of sippeers, associated with application
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] application_id Required parameter: Example:
    # @return [AssociatedSipPeersResponse] response from the API call
    def get_associated_sippeers_by_application_id_id(account_id,
                                                     application_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/applications/{applicationId}/associatedsippeers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'applicationId' => { 'value' => application_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Not Found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AssociatedSipPeersResponse',
                                   AssociatedSipPeersResponse)
      )
    end

    # Retrieve the information for a specific Campaign ID.
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/a2pcampaignids/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Campaign ID not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/a2pcampaignids'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get A2P Class.
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_1(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/a2pclasses/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A2P Class not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get all A2P Classes.
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data_1(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/a2pclasses'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_6(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get all bwspids
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data_3(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/bwspids'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get Bwspid
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_3(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/bwspids/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Bwspid not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # This resource retrieves information about pom.
    # @param [Integer] account_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_7(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/blockedaccount/{accountId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Account does not have a POM configuration.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve the information for a specific proxy sippeer.
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_9(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/proxypeers/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'proxy sippeer not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get all proxy sippeers (they should be sippeers of catapult accounts)
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data_8(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/proxypeers'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @return [SbcNodeGroups] response from the API call
    def get_all_admin_data_9
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/sbcnodegroups'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SbcNodeGroups',
                                   SbcNodeGroups)
      )
    end

    # TODO
    # @param [String] sbc_group_id Required parameter: Example:
    # @param [String] account_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_10(sbc_group_id,
                          account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sbcnodegroups/{sbcGroupId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'sbcGroupId' => { 'value' => sbc_group_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # get SystemEventSubscription.
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_11(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/systemeventsubscriptions/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'SystemEventSubscription not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data_10(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/systemeventsubscriptions'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get Vendor.
    # @param [String] id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_14(id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/vendors/{id}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'id' => { 'value' => id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Vendor not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Get all vendors and filter by name
    # @param [String] name_fragment Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_admin_data_12(name_fragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/admin/data/vendors'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'nameFragment' => name_fragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [String] property Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_option_error_with_parameter(property)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{property}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'property' => { 'value' => property, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [String] sippeer_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_admin_data_16(sippeer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{sippeerId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'sippeerId' => { 'value' => sippeer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # The GET returns the current settings, indicating the user ID, and the
    # result from attempted authentication with the stored credentials.  If the
    # Authentication fails subsequent attempts will be made using default
    # credentials until the issue is resolved.
    # @param [Integer] account_id Required parameter: Example:
    # @return [E911SettingsResponse] response from the API call
    def get_e911_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/e911/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUNDIf the E911 product exists on the account, but settings' \
          ' are missing, then the 404 not found response is' \
          ' used.If the E911 product does not exist on the account' \
          ' then the 404 will indicate that the E911 products' \
          ' resource cannot be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'E911SettingsResponse',
                                   E911SettingsResponse)
      )
    end

    # There are three primary settings that are provided as part of the Edge
    # Management product: The SBC settings that are associated with the
    # account,SipAuthentication that provide settings for SIP authentication and
    # ProductSpecificAccessRestrictions that can restrict Termination traffic
    # for sipCredendital.    <br>    <b>SbcSettings:</b>    <table>   
    # <tr><th>Parameter</th><th>Description</th></tr>   
    # <tr><td>TrunkGroupId</td><td>element defines id of the trunk group
    # associated with the Account in TGA</td></tr>   
    # <tr><td>NodeGroupName</td><td>element are the node group name set up in
    # TGA</td></tr>    </table>    <br>    <b>SipAuthentication:</b>     <table>
    #     <tr><th>Parameter</th><th>Description</th></tr>    
    # <tr><td>Enabled</td><td>enable SIP Authentication on account. Values that
    # can be accepted: true, false</td></tr>     <tr><td>Status</td><td>provide
    # information about processing status. This field cannot be
    # updated.</td></tr>     <tr><td>Errors</td><td>List of errors that happened
    # during sip auth provisioning. This field cannot be updated.</td></tr>    
    # </table>    <br><br>    <b>ProductSpecificAccessRestrictions</b>(requires
    # existence of SipCredentialSettings)<b>:</b>    <table>   
    # <tr><th>Parameter</th><th>Description</th></tr>   
    # <tr><td>RestrictedProduct</td><td>Product to restrict. Values that can be
    # accepted: Termination</td></tr>   
    # <tr><td>RestrictedAccessType</td><td>Type of restriction. Values that can
    # be accepted: SipCredentials</td></tr>    </table>
    # @param [Integer] account_id Required parameter: Example:
    # @return [EdgeManagementConfigurationResponse] response from the API call
    def get_edge_management_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/edgemanagement/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'If the settings are not present for the EdgeManagement product a' \
          ' 404 NOT FOUND is returned with an explanatory payload.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'EdgeManagementSettingsResponse',
                                   EdgeManagementConfigurationResponse)
      )
    end

    # Gets all SIP Authentication settings
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountSipAuthSettingsResponse] response from the API call
    def get_sip_authentication_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/edgemanagement/settings/sipauthentication'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'If the configuration is not present a 404 NOT FOUND is returned' \
          ' with an explanatory payload.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipAuthenticationResponse',
                                   AccountSipAuthSettingsResponse)
      )
    end

    # POST is used to validate address as geocode-able one. Request payload is
    # the address to geocode. If decomposed elements are provided for
    # AddressLine 1 then AddressLine1 is ignored. At least HouseNumber and
    # StreetName are required to use them as replacement of AddressLine1. If at
    # least HouseNumber or StreetName is absent then AddressLine1 is used.
    # AddressLine1 information is required in either way. City and StateCode
    # fields are required.
    # @param [Integer] account_id Required parameter: Example:
    # @param [GeocodeRequestAddress] body Optional parameter: Example:
    # @return [GeocodeRequestResponse] response from the API call
    def create_get_addresses_1(account_id,
                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/geocoderequest'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('RequestAddress', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request - service cannot geocode address or validation rules' \
          ' were violated.',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict - address is close to one that can be geocoded.',
          _response
        )
      elsif _response.status_code == 500
        raise APIException.new(
          'System error - internal error which cannot be fixed by changing' \
          ' payload etc.',
          _response
        )
      elsif _response.status_code == 503
        raise APIException.new(
          'Service unavailable - for some reason service is temporary' \
          ' unavailable.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'GeocodeRequestResponse',
                                   GeocodeRequestResponse)
      )
    end

    # TODO
    # @param [String] holiday_date Required parameter: Example:
    # @return [HolidayResponse] response from the API call
    def get_holiday(holiday_date)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{holidayDate}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'holidayDate' => { 'value' => holiday_date, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'HolidayResponse',
                                   HolidayResponse)
      )
    end

    # The GET returns the current settings, indicating is Messaging product
    # enabled now and if yes will Messaging feature be enabled on each new
    # telephone number.
    # @param [Integer] account_id Required parameter: Example:
    # @return [MessagingSettingsResponse] response from the API call
    def get_messaging_settings(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUNDIf the Messaging product exists on the account, but' \
          ' settings are missing, then the 404 not found response' \
          ' is used.If the Messaging product does not exist on the' \
          ' account then the 404 will indicate that the Messaging' \
          ' products resource cannot be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'MessagingSettingsResponse',
                                   MessagingSettingsResponse)
      )
    end

    # The GET returns the current list of routes associated with the various
    # types of TNs that can be assigned messaging routes.Zero or more routes can
    # be returned for each type of TN; each one of these routes is identified by
    # an NNID, or an ESPID while we transition from ESPIDs to NNIDs.For
    # reference the various types of TNs that can be assigned differentiated
    # routes are...<table>    <tr><th>XML element</th><th>Type of TN
    # description</th></tr>    <tr><td>OnNetTns</td><td>On Net Bandwidth owned
    # TNs</td></tr>    <tr><td>OffNetTns</td><td>Off-net TNs in Bandwidth's
    # inventory</td></tr>    <tr><td>OffNetCanadianTns</td><td>Canadian TNs in
    # Bandwidth's inventory</td></tr>    <tr><td>TollFreeTns</td><td>TollFree
    # TNs in Bandwidth's inventory</td></tr>   
    # <tr><td>ExternalCustomerOwnedTns</td><td>TNs owned by the customer in
    # NPAC, and imported into Bandwidth's inventory for the customer's
    # use</td></tr>    <tr><td>ExternalThirdPartyTns</td><td>TNs owned by a 3rd
    # party in NPAC, and imported into Bandwidth's inventory for the customer's
    # use</td></tr>    <tr><td>ExternalCanadianTns</td><td>Canadian TNs eh,
    # imported into Bandwidth's inventory for the customer's use</td></tr>   
    # <tr><td>ExternalTollFreeTns</td><td>Toll Free TNs imported into
    # Bandwidth's inventory for the customer's use</td></tr>   
    # <tr><td>A2pTollFreeTns</td><td>A2P Non Toll Free NNID</td></tr>   
    # <tr><td>A2pNonTollFreeTns</td><td>A2P Toll Free NNID</td></tr></table>If a
    # single route is returned that implies that all of the TNs of the
    # associated type will use the listed NNID for routing.If no route values
    # are returnet that implies that Bandwidth is not involved in setting up
    # routes - that must be done using other means.It also implies that Messages
    # sent to TNs of that type will be routed off-net.If there are multiple
    # route values configured it means that the customer is empowered to assign
    # one of the NNIDs to any of the messaging enabled TNs on their account.In
    # the multiple routes case the only one route per Tn Type in the list is
    # taken to be the default value assigned to TNs when provisioned.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] details Optional parameter: Example:
    # @return [AccountMessagingRoutesResponse] response from the API call
    def get_account_routes(account_id,
                           details: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/routes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'details' => details
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountMessagingRoutesResponse',
                                   AccountMessagingRoutesResponse)
      )
    end

    # Get sms settings for account
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountSmsFeatureResponse] response from the API call
    def get_sms_feature(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/features/sms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountSmsFeatureResponse',
                                   AccountSmsFeatureResponse)
      )
    end

    # Get http settings for account
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountHttpFeatureResponse] response from the API call
    def get_http_feature(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/features/http'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountHttpFeatureResponse',
                                   AccountHttpFeatureResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountMmsFeatureSettingsResponse] response from the API call
    def retrieve_mms_feature_settings(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/features/mms/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountMmsFeatureSettingsResponse',
                                   AccountMmsFeatureSettingsResponse)
      )
    end

    # Get mm4 settings for account
    # @param [Integer] account_id Required parameter: Example:
    # @return [MmsFeatureMm4SettingsResponse] response from the API call
    def retrieve_mms_feature_mm4_settings(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/features/mms/mm4settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'MmsFeatureMm4AdminSettingsResponse',
                                   MmsFeatureMm4SettingsResponse)
      )
    end

    # Get mms settings for account
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountMmsFeatureResponse] response from the API call
    def get_mms_feature(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/messaging/features/mms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AccountMmsFeatureResponse',
                                   AccountMmsFeatureResponse)
      )
    end

    # TODO
    # @param [String] property_name Required parameter: Example:
    # @return [ProductsResponse] response from the API call
    def get_property(property_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{propertyName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'propertyName' => { 'value' => property_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ProductsResponse',
                                   ProductsResponse)
      )
    end

    # GET is used to retrieve all SIP credentials for the account.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] usernamefragment Optional parameter: Example:
    # @param [String] domainfragment Optional parameter: Example:
    # @return [AccountSipCredentials] response from the API call
    def get_sip_credentials(account_id,
                            page: nil,
                            size: nil,
                            usernamefragment: nil,
                            domainfragment: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sipcredentials'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'usernamefragment' => usernamefragment,
        'domainfragment' => domainfragment
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - if the account specified does not exist or is locked' \
          ' or there are no SIP credentials associated with' \
          ' specified account it will result in a not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipCredentials',
                                   AccountSipCredentials)
      )
    end

    # POST is used to create SIP credentials and associate its with the
    # account.The key data elements in the submission are - <table
    # style="text-align: left; width: 80%;" border="1" cellpadding="2"
    # cellspacing="2">  <tbody>    <tr>      <td>UserName</td>      <td>This is
    # subscriber name or aggregated name and domain value(ex: John@bw.com).
    # Field is required. Max length - 32 characters.</td>    </tr>    <tr>     
    # <td>Domain</td>      <td>This is subscriber domain. Domain is optional and
    # if present will be appended to the UserName with an '@'. Max length - 32
    # characters.</td>    </tr>    <tr>      <td>Hash1</td>      <td>This is
    # hash value #1 in MD5 representation. Field is required. Max length - 64
    # characters.</td>    </tr>    <tr>      <td>Hash1b</td>      <td>This is
    # hash value #2 in MD5 representation. Field is optional. Max length - 64
    # characters.</td>    </tr>  </tbody></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [AccountSipCredentials] body Optional parameter: Example:
    # @return [AccountSipCredentialsCreateResponse] response from the API call
    def create_sip_credentials(account_id,
                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sipcredentials'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipCredentials', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - If all credential entries in specified list are' \
          ' invalid it will result in bad request with list of' \
          ' errors.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipCredentialsResponse',
                                   AccountSipCredentialsCreateResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] aggregatedusername Required parameter: Example:
    # @return [SipCredentialResponse] response from the API call
    def get_sip_credential(account_id,
                           aggregatedusername)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sipcredentials/{aggregatedusername}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'aggregatedusername' => { 'value' => aggregatedusername, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipCredentialResponse',
                                   SipCredentialResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] aggregatedusername Required parameter: Example:
    # @param [SipCredential] body Optional parameter: Example:
    # @return [SipCredentialResponse] response from the API call
    def update_sip_credential(account_id,
                              aggregatedusername,
                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sipcredentials/{aggregatedusername}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'aggregatedusername' => { 'value' => aggregatedusername, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipCredential', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipCredentialResponse',
                                   SipCredentialResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] aggregatedusername Required parameter: Example:
    # @return [Object] response from the API call
    def delete_sip_credential(account_id,
                              aggregatedusername)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sipcredentials/{aggregatedusername}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'aggregatedusername' => { 'value' => aggregatedusername, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # retrieves the information associated with the site id
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @return [SiteResponse] response from the API call
    def get_site(account_id,
                 site_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'the site id entered does not exist',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteResponse',
                                   SiteResponse)
      )
    end

    # updates the contents of a site id
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Site] body Optional parameter: Example:
    # @return [SiteResponse] response from the API call
    def update_site(account_id,
                    site_id,
                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Site', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Information essential to the site id is missing',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Address needs some changes',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteResponse',
                                   SiteResponse)
      )
    end

    # deletes the site - sites can only be deleted if there are no SIP Peers
    # attached to it
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @return [SiteResponse] response from the API call
    def delete_site(account_id,
                    site_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'DELETE request is invalid given the current state of the site',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteResponse',
                                   SiteResponse)
      )
    end

    # retrieve a list of all the sites associated with the account
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] tn_counts Optional parameter: Example:false
    # @param [Boolean] sip_peer_details Optional parameter: Example:false
    # @param [Boolean] summary Optional parameter: Example:false
    # @return [SitesResponse] response from the API call
    def get_sites(account_id,
                  tn_counts: false,
                  sip_peer_details: false,
                  summary: false)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'tnCounts' => tn_counts,
        'sipPeerDetails' => sip_peer_details,
        'summary' => summary
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SitesResponse',
                                   SitesResponse)
      )
    end

    # Add a site to the account
    # @param [Integer] account_id Required parameter: Example:
    # @param [Site] body Optional parameter: Example:
    # @return [SiteResponse] response from the API call
    def create_site(account_id,
                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Site', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Information is missing from the body of the add site request',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Address needs some changes',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteResponse',
                                   SiteResponse)
      )
    end

    # These are the settings associated with the provisioning of Termination
    # settings. The current values represented below detail the legacy
    # Termination settings appropriate for customers currently on Bandwidth
    # Dashboard API.  In the future Bandwidth Dashboard API customers will use
    # the Roger Termination Product manager, and define the set of Roger
    # parameters using an extension of this interface.  A parameter
    # 'RogerUsedForTerminationSettings' is used to control this behavior...   
    # <ul>    <li>If RogerUsedForTerminationSettings is false, then the
    # LegacyTerminationSettings will be used, RogerTerminationSettings will be
    # empty</li>    <li>If RogerUsedForTerminationSettings is transition, then
    # both LegacyTerminationSettings and RogerTerminationSettings elements are
    # used</li>    <li>If RogerUsedForTerminationSettings is true, then the
    # RogerTerminationSettings element will be used.  LegacyTerminationSettings
    # will be empty.</li>    </ul>    <ul>    <li>HttpVoiceProxyTermHost is
    # created automatically when the first voice application is created for HTTP
    # Voice V2 for this account, and deleted when the last voice application for
    # HTTP Voice V2 is removed from this account.</li>   
    # <li>HttpVoiceProxyTermHost is only displayed for internal users.</li>   
    # </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @return [AccountTerminationConfigurationResponse] response from the API call
    def get_termination_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/termination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'If the settings are not present for the Termination product a 404' \
          ' NOT FOUND is returned with an explanatory payload.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TerminationSettingResponse',
                                   AccountTerminationConfigurationResponse)
      )
    end

    # Retrieve Toll Free Settings for this account
    # @param [Integer] account_id Required parameter: Example:
    # @return [TollFreeSettingsResponse] response from the API call
    def get_toll_free_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/tollfree/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Failure to parse the request, or inconsistent provisioned data,' \
          ' such as no related product associated with the account.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TollFreeSettingsResponse',
                                   TollFreeSettingsResponse)
      )
    end

    # These are the settings associated with the provisioning of UC Trunking
    # settings.
    # @param [Integer] account_id Required parameter: Example:
    # @return [UcTrunkingCloudConfigurationResponse] response from the API call
    def get_uc_trunking_hosted_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/uctrunks'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'If the settings are not present for the UC Trunking product a 404' \
          ' NOT FOUND is returned with an explanatory payload.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'UcTrunkingCloudSettingsResponse',
                                   UcTrunkingCloudConfigurationResponse)
      )
    end

    # This resource can be PUT or POSTed to in order to establish the
    # appropriate settings.Some of the important values that are established as
    # part of this UC Trunking are described in the section on POST.
    # @param [Integer] account_id Required parameter: Example:
    # @param [UcTrunkingCloudConfigurationPayload] body Optional parameter:
    # Example:
    # @return [UcTrunkingCloudConfigurationResponse] response from the API call
    def update_uc_trunking_hosted_configuration(account_id,
                                                body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/uctrunks'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UcTrunkingCloudSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'a 400 BAD REQUEST will be returned with a descriptive payload if' \
          ' the XML describing the UC Trunking settings resource' \
          ' is incorrect.  The error contains an error code and' \
          ' description.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'UcTrunkingCloudSettingsResponse',
                                   UcTrunkingCloudConfigurationResponse)
      )
    end

    # Creates a UC Trunking hosted (cloud) configuration
    # @param [Integer] account_id Required parameter: Example:
    # @param [UcTrunkingCloudConfigurationPayload] body Optional parameter:
    # Example:
    # @return [UcTrunkingCloudConfigurationResponse] response from the API call
    def create_uc_trunking_hosted_configuration(account_id,
                                                body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/uctrunks'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UcTrunkingCloudSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'a 400 BAD REQUEST will be returned with a descriptive payload if' \
          ' the XML describing the UC Trunking settings resource' \
          ' is incorrect.  The error contains an error code and' \
          ' description.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'UcTrunkingCloudSettingsResponse',
                                   UcTrunkingCloudConfigurationResponse)
      )
    end

    # These are the settings associated with the provisioning of UC Trunking
    # settings.
    # @param [Integer] account_id Required parameter: Example:
    # @return [OriginationConfigurationResponse] response from the API call
    def get_uc_trunking_configuration(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/uctrunking/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'If the settings are not present for the UC Trunking product a 404' \
          ' NOT FOUND is returned with an explanatory payload.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'OriginationSettingResponse',
                                   OriginationConfigurationResponse)
      )
    end

    # TODO
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @param [String] suggestions Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [String] size Optional parameter: Example:
    # @return [IrisAccountsResponse] response from the API call
    def get_ldap_accounts(domain_name,
                          accounts,
                          suggestions: nil,
                          page: nil,
                          size: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{accounts}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'suggestions' => suggestions,
        'page' => page,
        'size' => size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapAccountsResponse',
                                   IrisAccountsResponse)
      )
    end

    # Retrieves the information about account by unique account id.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @return [IrisAccountResponse] response from the API call
    def get_ldap_account(account_id,
                         domain_name,
                         accounts)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{accounts}/{accountId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The account does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapAccountResponse',
                                   IrisAccountResponse)
      )
    end

    # Retrieves the information about domain with some name.
    # @param [String] domain_name Required parameter: Example:
    # @return [DomainResponse] response from the API call
    def get_domain(domain_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Domain name not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'DomainResponse',
                                   DomainResponse)
      )
    end

    # TODO
    # @param [String] domain_name Required parameter: Example:
    # @param [String] permissions Required parameter: Example:
    # @return [LdapPermissionsResponse] response from the API call
    def get_ldap_permissions(domain_name,
                             permissions)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{permissions}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'permissions' => { 'value' => permissions, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapPermissionsResponse',
                                   LdapPermissionsResponse)
      )
    end

    # Retrieves the information about permission by unique permission name.
    # @param [String] permission_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] permissions Required parameter: Example:
    # @return [LdapPermissionResponse] response from the API call
    def get_ldap_permission(permission_id,
                            domain_name,
                            permissions)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{permissions}/{permissionId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'permissionId' => { 'value' => permission_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'permissions' => { 'value' => permissions, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The permission does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapPermissionResponse',
                                   LdapPermissionResponse)
      )
    end

    # Retrieves the information about role by unique role name.
    # @param [String] role_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapRoleResponse] response from the API call
    def get_ldap_role(role_id,
                      domain_name,
                      roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{roles}/{roleId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'roleId' => { 'value' => role_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The role does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapRoleResponse',
                                   LdapRoleResponse)
      )
    end

    # TODO
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapRoleResponse] response from the API call
    def get_ldap_roles(domain_name,
                       roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{roles}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapRoleResponse',
                                   LdapRoleResponse)
      )
    end

    # Retrieves the information about permission by unique name, related to
    # specific role.
    # @param [String] role_id Required parameter: Example:
    # @param [String] permission_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @param [String] permissions Required parameter: Example:
    # @return [LdapRolePermissionXrefResponse] response from the API call
    def get_ldap_role_permissions(role_id,
                                  permission_id,
                                  domain_name,
                                  roles,
                                  permissions)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{roles}/{roleId}/{permissions}/{permissionId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'roleId' => { 'value' => role_id, 'encode' => false },
        'permissionId' => { 'value' => permission_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false },
        'permissions' => { 'value' => permissions, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The role or permission does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapRolePermissionResponse',
                                   LdapRolePermissionXrefResponse)
      )
    end

    # TODO
    # @param [String] role_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @param [String] permissions Required parameter: Example:
    # @return [LdapRolePermissionsXrefResponse] response from the API call
    def get_ldap_role_permissions_1(role_id,
                                    domain_name,
                                    roles,
                                    permissions)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/{roles}/{roleId}/{permissions}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'roleId' => { 'value' => role_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false },
        'permissions' => { 'value' => permissions, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapRolePermissionsResponse',
                                   LdapRolePermissionsXrefResponse)
      )
    end

    # TODO
    # @param [String] domain_name Required parameter: Example:
    # @param [Integer] account_scope Optional parameter: Example:
    # @return [TokensResponse] response from the API call
    def list_tokens(domain_name,
                    account_scope: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/tokens'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'accountScope' => account_scope
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TokensResponse',
                                   TokensResponse)
      )
    end

    # TODO
    # @param [String] domain_name Required parameter: Example:
    # @param [TokenScope] body Optional parameter: Example:
    # @return [TokenResponse] response from the API call
    def create_token_secret_pair(domain_name,
                                 body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/tokens'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('TokenScope', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TokenResponse',
                                   TokenResponse)
      )
    end

    # TODO
    # @param [String] token_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [Integer] account_scope Optional parameter: Example:
    # @return [TokenResponse] response from the API call
    def retrieve_token(token_id,
                       domain_name,
                       account_scope: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/tokens/{tokenId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'tokenId' => { 'value' => token_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'accountScope' => account_scope
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TokenResponse',
                                   TokenResponse)
      )
    end

    # TODO
    # @param [String] token_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [Integer] account_scope Optional parameter: Example:
    # @return [TokenResponse] response from the API call
    def delete_token(token_id,
                     domain_name,
                     account_scope: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/tokens/{tokenId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'tokenId' => { 'value' => token_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'accountScope' => account_scope
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TokenResponse',
                                   TokenResponse)
      )
    end

    # Retrieves the information about user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @return [LdapUserResponse] response from the API call
    def get_user(user_id,
                 domain_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'User ID is not correct.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'User not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserResponse',
                                   LdapUserResponse)
      )
    end

    # Allows the user update.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [LdapUser] body Optional parameter: Example:
    # @return [LdapUserResponse] response from the API call
    def update_user(user_id,
                    domain_name,
                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('User', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Some information is not correct.',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'User has access for users in accounts that they control.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'User not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserResponse',
                                   LdapUserResponse)
      )
    end

    # Allows to create a new user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [LdapUser] body Optional parameter: Example:
    # @return [LdapUserResponse] response from the API call
    def create_user(user_id,
                    domain_name,
                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('User', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Some information is not correct.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserResponse',
                                   LdapUserResponse)
      )
    end

    # Determine whether the current user has named permission
    # @param [String] domain_name Required parameter: Example:
    # @param [String] permission Optional parameter: Example:
    # @return [LdapUsersResponse] response from the API call
    def get_validate_user_permission(domain_name,
                                     permission: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/permittedaccess'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'permission' => permission
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'User does not have the named permission in their set of named' \
          ' permissions',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUsersResponse',
                                   LdapUsersResponse)
      )
    end

    # Retrieves the information about  all users.
    # @param [String] domain_name Required parameter: Example:
    # @param [String] suggestions Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [String] size Optional parameter: Example:
    # @param [String] scope Optional parameter: Example:
    # @param [Boolean] is_active Optional parameter: Example:
    # @return [LdapUsersResponse] response from the API call
    def get_users(domain_name,
                  suggestions: nil,
                  page: nil,
                  size: nil,
                  scope: nil,
                  is_active: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'suggestions' => suggestions,
        'page' => page,
        'size' => size,
        'scope' => scope,
        'isActive' => is_active
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUsersResponse',
                                   LdapUsersResponse)
      )
    end

    # Update user's password. Only logged user can change your password.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] password Required parameter: Example:
    # @param [Object] body Optional parameter: Example:
    # @return [LdapUserPasswordResponse] response from the API call
    def update_password(user_id,
                        domain_name,
                        password,
                        body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{password}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'password' => { 'value' => password, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Password', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Password is not correct.',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPasswordResponse',
                                   LdapUserPasswordResponse)
      )
    end

    # TODO
    # @param [String] user_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @return [UserAccountResponse] response from the API call
    def get_user_account(user_id,
                         account_id,
                         domain_name,
                         accounts)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{accounts}/{accountId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserAccountResponse',
                                   UserAccountResponse)
      )
    end

    # TODO
    # @param [String] user_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @return [UserAccountResponse] response from the API call
    def add_user_account(user_id,
                         account_id,
                         domain_name,
                         accounts)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{accounts}/{accountId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserAccountResponse',
                                   UserAccountResponse)
      )
    end

    # TODO
    # @param [String] user_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @return [UserAccountResponse] response from the API call
    def delete_user_account(user_id,
                            account_id,
                            domain_name,
                            accounts)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{accounts}/{accountId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserAccountResponse',
                                   UserAccountResponse)
      )
    end

    # Retrieves the information about accounts associated with user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @return [UserAccountsResponse] response from the API call
    def get_user_accounts(user_id,
                          domain_name,
                          accounts)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{accounts}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'User has system-wide scope.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'User not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserAccountsResponse',
                                   UserAccountsResponse)
      )
    end

    # Allows the user replace associated accounts.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] accounts Required parameter: Example:
    # @param [LdapAccountsDto] body Optional parameter: Example:
    # @return [UserAccountsResponse] response from the API call
    def update_replace_user_accounts(user_id,
                                     domain_name,
                                     accounts,
                                     body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{accounts}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'accounts' => { 'value' => accounts, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('AccountList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Account scope user can add just own accounts.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'User not found.',
          _response
        )
      elsif _response.status_code == 422
        raise APIException.new(
          'Some information is not correct.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserAccountsResponse',
                                   UserAccountsResponse)
      )
    end

    # Retrieves the details of a change, with prior and new values as
    # appropriate.
    # @param [String] userid Required parameter: Example:
    # @param [Integer] event_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @return [UserActivityEventDetailsResponse] response from the API call
    def get_user_event_details(userid,
                               event_id,
                               domain_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userid}/logs/{eventId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userid' => { 'value' => userid, 'encode' => false },
        'eventId' => { 'value' => event_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Event is not associated with impacted user or does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'UserActivityEventDetailsResponse',
                                   UserActivityEventDetailsResponse)
      )
    end

    # Retrieves the information about user access activity in date range.
    # @param [String] userid Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] start_date Optional parameter: Example:
    # @param [String] end_date Optional parameter: Example:
    # @return [UserActivityEventLogResponse] response from the API call
    def get_user_events_log(userid,
                            domain_name,
                            page: nil,
                            size: nil,
                            start_date: nil,
                            end_date: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userid}/logs'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userid' => { 'value' => userid, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'startDate' => start_date,
        'endDate' => end_date
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Incorrect date range.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserEventLog',
                                   UserActivityEventLogResponse)
      )
    end

    # Retrieves all user preferences.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def get_ldap_user_preferences_xref(user_id,
                                       domain_name,
                                       preferences)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Updates preference list for single user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @param [LdapUserPreferences] body Optional parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def update_ldap_user_preferences_xref(user_id,
                                          domain_name,
                                          preferences,
                                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UserPreferences', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 422
        raise APIException.new(
          'The information was not processed and error appeared.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Creates user-preference relation if it doesn't exist.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @param [LdapUserPreference] body Optional parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def create_get_ldap_user_preference_xref(user_id,
                                             domain_name,
                                             preferences,
                                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UserPreference', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 409
        raise APIException.new(
          'User preference already exists.',
          _response
        )
      elsif _response.status_code == 422
        raise APIException.new(
          'Provided data in payload is incorrect.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Retrieves user preference by name if it exists.
    # @param [String] user_id Required parameter: Example:
    # @param [String] preference_name Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def get_ldap_user_preference_xref_2(user_id,
                                        preference_name,
                                        domain_name,
                                        preferences)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}/{preferenceName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'preferenceName' => { 'value' => preference_name, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The preference does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Updates user-preference relation.
    # @param [String] user_id Required parameter: Example:
    # @param [String] preference_name Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @param [LdapUserPreference] body Optional parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def update_get_ldap_user_preference_xref_1(user_id,
                                               preference_name,
                                               domain_name,
                                               preferences,
                                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}/{preferenceName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'preferenceName' => { 'value' => preference_name, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UserPreference', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 422
        raise APIException.new(
          'Provided data in payload is incorrect.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Removes user-preference relation.
    # @param [String] user_id Required parameter: Example:
    # @param [String] preference_name Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] preferences Required parameter: Example:
    # @return [LdapUserPreferenceXrefResponse] response from the API call
    def delete_ldap_user_preference_xref(user_id,
                                         preference_name,
                                         domain_name,
                                         preferences)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{preferences}/{preferenceName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'preferenceName' => { 'value' => preference_name, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'preferences' => { 'value' => preferences, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'User preference does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LdapUserPreferenceResponse',
                                   LdapUserPreferenceXrefResponse)
      )
    end

    # Retrieves the information about first name, last name, company name,
    # contact telephone numbers and address by unique user name.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] profile Required parameter: Example:
    # @return [UserProfileResponse] response from the API call
    def get_user_profile(user_id,
                         domain_name,
                         profile)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{profile}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'profile' => { 'value' => profile, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The user does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserProfileResponse',
                                   UserProfileResponse)
      )
    end

    # Updates the information about user profile by unique user name. Note, that
    # empty fields will work like delete.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] profile Required parameter: Example:
    # @param [UserProfile] body Optional parameter: Example:
    # @return [UserProfileResponse] response from the API call
    def update_upsert_user_profile(user_id,
                                   domain_name,
                                   profile,
                                   body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{profile}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'profile' => { 'value' => profile, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UserProfile', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The user don\'t put telephone number.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserProfileResponse',
                                   UserProfileResponse)
      )
    end

    # Retrieves the information about permission by unique name, related to
    # specific user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] role_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapUserRoleXrefResponse] response from the API call
    def get_ldap_user_roles(user_id,
                            role_id,
                            domain_name,
                            roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{roles}/{roleId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'roleId' => { 'value' => role_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The user, role or user-to-role association does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserRoleResponse',
                                   LdapUserRoleXrefResponse)
      )
    end

    # Adds role to user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] role_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapUserRoleXrefResponse] response from the API call
    def create_ldap_user_role_xref(user_id,
                                   role_id,
                                   domain_name,
                                   roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{roles}/{roleId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'roleId' => { 'value' => role_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Create failed, role cannot be associated to certain user.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserRoleResponse',
                                   LdapUserRoleXrefResponse)
      )
    end

    # Removes specified role from user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] role_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapUserRoleXrefResponse] response from the API call
    def delete_ldap_user_role_xref(user_id,
                                   role_id,
                                   domain_name,
                                   roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{roles}/{roleId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'roleId' => { 'value' => role_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The role is not related to certain user.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserRoleResponse',
                                   LdapUserRoleXrefResponse)
      )
    end

    # TODO
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @return [LdapUserRolesXrefResponse] response from the API call
    def get_ldap_user_roles_1(user_id,
                              domain_name,
                              roles)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{roles}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserRolesResponse',
                                   LdapUserRolesXrefResponse)
      )
    end

    # Rewrites all existing roles, related to user.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] roles Required parameter: Example:
    # @param [LdapRoles] body Optional parameter: Example:
    # @return [LdapUserRolesXrefResponse] response from the API call
    def update_ldap_user_roles(user_id,
                               domain_name,
                               roles,
                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{roles}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'roles' => { 'value' => roles, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('RoleList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Data in body formed in wrong way, validation error appears.',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Update failed, some of roles cannot be associated with user.',
          _response
        )
      elsif _response.status_code == 422
        raise APIException.new(
          'Some of roles cannot be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LdapUserRolesResponse',
                                   LdapUserRolesXrefResponse)
      )
    end

    # Retrieves the information about scope and active status by unique user
    # name.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] settings Required parameter: Example:
    # @return [UserSettingsResponse] response from the API call
    def get_user_settings(user_id,
                          domain_name,
                          settings)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{settings}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'settings' => { 'value' => settings, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The user has more then one scope.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The user does not exist.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserSettingsResponse',
                                   UserSettingsResponse)
      )
    end

    # Updates the information about scope and active by unique user name.
    # @param [String] user_id Required parameter: Example:
    # @param [String] domain_name Required parameter: Example:
    # @param [String] settings Required parameter: Example:
    # @param [UserSettings] body Optional parameter: Example:
    # @return [UserSettingsResponse] response from the API call
    def update_upsert_user_settings(user_id,
                                    domain_name,
                                    settings,
                                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{domainName}/users/{userId}/{settings}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'userId' => { 'value' => user_id, 'encode' => false },
        'domainName' => { 'value' => domain_name, 'encode' => false },
        'settings' => { 'value' => settings, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('UserSettings', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The user try setup scope that higher than his own.',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'The user try activate another user having no accoounts assigned' \
          ' to it.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'UserSettingsResponse',
                                   UserSettingsResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] data_type Required parameter: Example:
    # @return [AnalyticsResponse] response from the API call
    def get_number_assignment_analytics(account_id,
                                        data_type)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/analytics/{dataType}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'dataType' => { 'value' => data_type, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'AnalyticsResult',
                                   AnalyticsResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @return [void] response from the API call
    def get_analytics(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/analytics'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - if the API call does not specify the type of data.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(_response)
    end

    # Retrieve a list of the TelephoneNumbersAssignment orders that are
    # associated with the account. <p>A maximum of 1,000 orders can be retrieved
    # per request. If no date range or specific query parameter (marked by <b
    # class="required">*</b> below) is provided, the order results will be
    # limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [List of String] status Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [List of String] activity_state Optional parameter: Example:
    # @param [String] created_date_from Optional parameter: Example:
    # @param [String] created_date_to Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] order_id_fragment Optional parameter: Example:
    # @param [String] action Optional parameter: Example:
    # @return [Object] response from the API call
    def get_orders(account_id,
                   status: nil,
                   tn: nil,
                   customer_order_id: nil,
                   activity_state: nil,
                   created_date_from: nil,
                   created_date_to: nil,
                   modified_date_from: nil,
                   modified_date_to: nil,
                   order_id_fragment: nil,
                   action: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/numbersAssignment'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'status' => status,
        'tn' => tn,
        'customerOrderId' => customer_order_id,
        'activityState' => activity_state,
        'createdDateFrom' => created_date_from,
        'createdDateTo' => created_date_to,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'orderIdFragment' => order_id_fragment,
        'action' => action
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request.  If any errors are found in the processing of the' \
          ' query string a 400 will be returned.  Note that' \
          ' parameters that are not recognized are not considered' \
          ' errors, and are just ignored.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body,
        'TelephoneNumbersAssignmentOrderReportResponse', String
      )
      )
    end

    # Create a TelephoneNumbersAssignment order to register the assignment
    # status of a list of telephone numbers.  The telephone numbers can be
    # declared to be either ASSIGNED or UNASSIGNED.The key data elements in the
    # submission are - <table style="text-align: left; width: 80%;" border="1"
    # cellpadding="2" cellspacing="2">  <tbody>    <tr>     
    # <td>CustomerOrderID</td>      <td>An order ID created by the customer for
    # their tracking purposes. Only alphanumeric values, dashes and spaces are
    # allowed. Max length is 40 characters.</td>    </tr>    <tr>     
    # <td>Action</td>      <td>(Required) Declare whether the listed Telephone
    # Numbers are to be ASSIGNED or UNASSIGNED</td>    </tr>  </tbody></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [TelephoneNumbersAssignmentOrderPayload] body Optional parameter:
    # Example:
    # @return [Object] response from the API call
    def create_order(account_id,
                     body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/numbersAssignment'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'TelephoneNumbersAssignmentOrder', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request <br> A 400 response Indicates that the order could' \
          ' not be created.Error text and an error code will be' \
          ' provided in the ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Creates a csr order.<br>Upon a successfully-submitted payload, the order
    # will have a status of "RECEIVED".<br><br><br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Csr] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_csr_order(account_id,
                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/csrs'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Csr', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The order failed. One of the input parameters is invalid.',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Action can not be performed because account does not have CSR' \
          ' product feature enabled.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the information associated with the specified csr order ID
    # number.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def retrieve_csr_order(account_id,
                           orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/csrs/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Order ID has invalid format.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Order does not exists or belongs to different account.',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Action can not be performed because account does not have CSR' \
          ' product feature enabled.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Replaces the existing csr conditional data with specificed csr conditional
    # data. To cancel CSR order need provide Status tag with REQUESTED_CANCEL
    # value. Note that csr order must be a non-real time with PROCESSING or
    # ACTION_REQUIRED status.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [Csr] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_csr_order(account_id,
                         orderid,
                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/csrs/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Csr', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'There was an error replacing the conditional data for the order.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve a list of the DLDA orders that are associated with the account.
    # <p>A maximum of 1,000 orders can be retrieved per request. If no date
    # range or specific query parameter (marked by <b class="required">*</b>
    # below) is provided, the order results will be limited to the last two
    # years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] last_modified_after Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @return [Object] response from the API call
    def get_dlda_order_2(account_id,
                         last_modified_after: nil,
                         modified_date_from: nil,
                         modified_date_to: nil,
                         tn: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/dldas'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'lastModifiedAfter' => last_modified_after,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'tn' => tn
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found <br> If any errors are found in the processing of the' \
          ' query string a 404 will be returned.  Note that' \
          ' parameters that are not recognized are not considered' \
          ' errors, and are just ignored.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'DldaOrderReportResponse', String)
      )
    end

    # Create DLDA order to associate the street address with the telephone
    # number.The key data elements in the submission are - <table
    # style="text-align: left; width: 80%;" border="1" cellpadding="2"
    # cellspacing="2">  <tbody>    <tr>      <td>TelephoneNumbers</td>     
    # <td>A list of telephone numbers you need to bind information from
    # payload.</td>    </tr>    <tr>      <td>SubscriberType</td>      <td>Can
    # be RESIDENTIAL or BUSINESS.  The element is required.</td>    </tr>   
    # <tr>      <td>ListingType</td>      <td>Can be LISTED, NON_LISTED or
    # NON_PUBLISHED. The element is required</td>    </tr>    <tr>     
    # <td>ListingName</td>      <td>This field is required. Inner fields:
    # FirstName (this field is required in case RESIDENTIAL SubscriberType is
    # chosen), FirstName2, LastName (this field is required), Designation,
    # TitleOfLineage, TitleOfAddress, TitleOfAddress2, TitleOfLineageName2,
    # TitleOfAddressName2, TitleOfAddress2Name2, and PlaceListingAs are
    # optional<br>Please see the note below on sorting of Business
    # Listings.</td>    </tr>    <tr>      <td>ListAddress</td>      <td>Can be
    # true or false. The element is required.</td>    </tr>    <tr>     
    # <td>Address</td>      <td>This field is required. Inner fields:
    # HousePrefix, HouseNumber, HouseSuffix, PreDirectional, StreetName,
    # StreetSuffix, PostDirectional, AddressLine2, City, StateCode, Zip,
    # PlusFour and AddressType=DLDA.<br>City, HouseNumber, StreetName, City,
    # State and Zipcode are required fields.</td>    </tr>    <tr>     
    # <td>CustomerOrderId</td>      <td>The Customer Order ID is an ID assigned
    # by the account owner to provide a reference number for the Order. The
    # element is optional. Only alphanumeric values, dashes and spaces are
    # allowed. Max length is 40 characters.</td>    </tr> 
    # </tbody></table><b>Business Listings...</b> <br>Business Listings sort
    # differently than Residential Listings, and must be submitted accordingly. 
    # Since Business Listings sort starting at the beginning of the name, where
    # Residential Listings sort on Last Name, the parts of the business name
    # that will govern the sorting need to be entered in the LastName field. 
    # For example, Joe's Pizza sorts starting with Joe, so the entire business
    # name would be entered in the LastName field, and the Firstname could be
    # left blank.  If there was a portion of the name that was not important
    # from a sorting perspective (perhaps "the best pizza in town"), that
    # portion could be placed in the FirstName field.<br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [DldaOrderPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_dlda_order(account_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/dldas'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('DldaOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request <br> A 400 response Indicates that the order could' \
          ' not be created.Error text and an error code will be' \
          ' provided in the ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve information about a DLDA Order with specified ID.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_dlda_order_1(account_id,
                         order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/dldas/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'DldaOrderReportResponse', String)
      )
    end

    # Update DLDA order to associate the street address with the telephone
    # number.The key data elements in the submission are -     <table
    # style="text-align: left; width: 80%;"     border="1" cellpadding="2"
    # cellspacing="2">      <tbody>        <tr>         
    # <td>TelephoneNumbers</td>          <td>A list of telephone numbers you
    # need to bind information from payload.</td>        </tr>        <tr>      
    #    <td>AccountType</td>          <td>Can be RESIDENTIAL or BUSINESS.  The
    # element is required.</td>        </tr>        <tr>         
    # <td>ListingType</td>          <td>Can be LISTED, NON_LISTED or
    # NON_PUBLISHED. The element is required</td>        </tr>        <tr>      
    #    <td>ListingName</td>          <td>Inner fields: FirstName, FirstName2,
    # LastName, Designation, TitleOfLineage, TitleOfAddress, TitleOfAddress2,
    # TitleOfLineageName2, TitleOfAddressName2, TitleOfAddress2Name2,
    # PlaceListingAs.</td>        </tr>        <tr>         
    # <td>ListAddress</td>          <td>Can be true or false. The element is
    # required.</td>        </tr>        <tr>          <td>Address</td>         
    # <td>This field is required. Inner fields: HousePrefix, HouseNumber,
    # HouseSuffix, PreDirectional, StreetName, StreetSuffix, PostDirectional,
    # AddressLine2, City, StateCode, Zip, PlusFour, AddressType</td>       
    # </tr>        <tr>          <td>CustomerOrderId</td>          <td>The
    # Customer Order ID is an ID assigned by the account owner to provide a
    # reference number for the Order. The element is optional. Only alphanumeric
    # values, dashes and spaces are allowed. Max length is 40 characters.</td>  
    #      </tr>      </tbody>    </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [DldaOrderPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_dlda_order(account_id,
                          order_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/dldas/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('DldaOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request <br> A 400 response Indicates that the order could' \
          ' not be modified. The payload is echoed with the Errors' \
          ' identified.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the e911 information associated with that telephone number.
    # @param [String] tn Required parameter: Example:
    # @return [TnE911AddressResponse] response from the API call
    def get_uc_trunking_configuration_1(tn)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{tn}/e911'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'tn' => { 'value' => tn, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnE911AddressResponse',
                                   TnE911AddressResponse)
      )
    end

    # The GET operation is used to fetch the emergency notification recipient
    # specified by its identifier. <br>URI parameters:<ul>  <li> 
    # <b>accountId</b> - the account id of the account to which the emergency
    # notification recipient belongs  </li>  <li>  <b>enrId</b> - the identifier
    # assigned to the emergency notification recipient when it was created 
    # </li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] recipient_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_emergency_notification_recipient(account_id,
                                             recipient_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencyNotificationRecipients/{recipientId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'recipientId' => { 'value' => recipient_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to view emergency notification recipients,' \
          ' either due to Role/Permission or because the account' \
          ' is not configured for Emergency Notification Config.' \
          ' <br> <b>Error Description:</b> Access Denied </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p><b>Condition:</b> The' \
          ' emergency notification recipient identifier does not' \
          ' exist, or does not exist for the specified account id.' \
          ' <br> <b>Error Description:</b> The resource does not' \
          ' exist </p> <br>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # <p> Retrieve a list of emergency notification recipients configured for
    # this account. <br> Results can be paginated and filtered using the
    # following query parameters. </p><p> <b>Query parameters: </b></p><p> The
    # GET operation has no request payload, but the accountId must be specified
    # in the URI parameter.Results are returned by default in the order of
    # newest to oldest modification date of the Emergency Notification
    # Recipient.  This default order is reversed from oldest to newest when the
    # ModifiedAfterDate query parameter is included in the query.</p><p>Query
    # parameters act as filters on the data. If more than one query parameter is
    # provided, the results will be the intersection of the results from each
    # query parameter. In other words, the query parameters are logically
    # ANDed.Query parameters are appended to the end of the endpoint, separated
    # by a '?' and in the format parameter=value.  If you wish to specify more
    # than one query parameter, separate them using an '&' character.  The order
    # of query parameters does not matter.  For example:GET
    # /accounts/{accountId}/emergencyNotificationRecipients?EnrDescription=front
    # desk&EnrNotificationType=TTS...will return all Emergency Notification
    # Recipients having a description field including the string "front desk",
    # and having a notification type of TTS.The following query parameters are
    # supported.  All query parameters are optional. </p> <table>         <tr>  
    #         <th>Parameter Name</th>           <th>Example</th>          
    # <th>Default</th>           <th>Usage</th>         </tr>         <tr>      
    #       <td valign="top">                 <p>                    
    # ModifiedAfterDate                 </p>             </td>             <td 
    # valign="top">                 <p>                     ModifiedAfterDate=  
    #                   2020-03-23T17:34:00Z                     </p>           
    #  </td>             <td valign="top">                 <p>                  
    #   No filter                 </p>             </td>             <td
    # valign="top">                 <p>                     Include results only
    # for orders having order last modified date and time after the date and
    # time specified in this parameter. Note that inclusion of this parameter
    # reverses the default sort order of the results to ascending in date/time
    # (i.e. from oldest to newest). If you are looking for the
    # ModifiedBeforeDate query parameter, please see the Page parameter.        
    #         </p>             </td>         </tr>         <tr>             <td
    # valign="top">                 <p>                     ModifiedByUser      
    #           </p>             </td>             <td valign="top">            
    #     <p>                     ModifiedByUser=jgilmore                 </p>  
    #           </td>             <td  valign="top">                 <p>        
    #             No filter                 </p>             </td>            
    # <td valign="top">                 <p>                     Include results
    # only for orders last modified by the user specified in this parameter.    
    #             </p>             </td>         </tr>         <tr>            
    # <td valign="top">                 <p>                     EnrDescription  
    #               </p>             </td>             <td  valign="top">       
    #          <p>                     EnrDescription=front desk                
    # </p>             </td>             <td  valign="top">                 <p> 
    #                    No filter                 </p>             </td>       
    #      <td  valign="top">                 <p>                     A
    # substring that will exist in all Emergency Notification Recipient
    # Descriptions returned.                 </p>             </td>        
    # </tr>         <tr>             <td valign="top">                 <p>      
    #               EnrNotificationType                 </p>             </td>  
    #           <td valign="top">                 <p>                    
    # EnrNotificationType=SMS                 </p>             </td>            
    # <td  valign="top">                 <p>                     No filter      
    #           </p>             </td>             <td  valign="top">           
    #      <p>                     The type of notification (EMAIL, SMS, TTS, or
    # CALLBACK) specified for Emergency Notification Recipients returned.       
    #          </p>             </td>         </tr>         <tr>             <td
    # valign="top">                 <p>                     EnrSmsTn            
    #     </p>             </td>             <td valign="top">                
    # <p>                     EnrSmsTn=9195551212                 </p>          
    #   </td>             <td valign="top">                 <p>                 
    #    No filter                 </p>             </td>             <td 
    # valign="top">                 <p>                     The Short Message
    # Service telephone number in all SMS type Emergency Notification Recipients
    # returned.                 </p>             </td>         </tr>        
    # <tr>             <td valign="top">                 <p>                    
    # EnrTtsTn                 </p>             </td>             <td
    # valign="top">                 <p>                     EnrTtsTn=7045553777 
    #                </p>             </td>             <td valign="top">       
    #          <p>                     No filter                 </p>           
    #  </td>             <td valign="top">                 <p>                  
    #   The Text To Speech telephone number in all TTS type Emergency
    # Notification Recipients returned.                 </p>             </td>  
    #       </tr>         <tr>             <td valign="top">                 <p>
    #                     EnrEmailAddress                 </p>             </td>
    #             <td valign="top">                 <p>                    
    # EnrEmailAddress=                     fred9982@gmail.com                
    # </p>             </td>             <td valign="top">                 <p>  
    #                   No filter                 </p>             </td>        
    #     <td  valign="top">                 <p>                     The email
    # address in all EMAIL type Emergency Notification Recipients returned.     
    #            </p>             </td>         </tr>         <tr>            
    # <td valign="top">                 <p>                     EnrCallbackUrl  
    #               </p>             </td>             <td  valign="top">       
    #          <p>                     EnrCallbackUrl=                    
    # https://not.company.com                 </p>             </td>            
    # <td valign="top">                 <p>                     No filter       
    #          </p>             </td>             <td  valign="top">            
    #     <p>                     The callback URL in all CALLBACK type
    # Emergency Notification Recipients returned.                 </p>          
    #   </td>         </tr>         <tr>             <td valign="top">          
    #       <p>                     EnrCallbackUsername                 </p>    
    #         </td>             <td valign="top">                 <p>           
    #          EnrCallbackUsername=                     jgilmore                
    # </p>             </td>             <td valign="top">                 <p>  
    #                   No filter                 </p>             </td>        
    #     <td valign="top">                 <p>                     The callback
    # username in all CALLBACK type Emergency Notification Recipients returned. 
    #                </p>             </td>         </tr>         <tr>          
    #   <td valign="top">                 <p>                     Page          
    #       </p>             </td>             <td valign="top">                
    # <p>                     Page=                    
    # 2020-03-15T14:00:00.000-04:00                 </p>             </td>      
    #       <td valign="top">                 <p>                     Now       
    #          </p>             </td>             <td valign="top">             
    #    <p>                     This represents the position in the data set
    # from which you want your output to begin.  If this parameter is omitted,
    # results will include Emergency Notification Recipients last modified on or
    # before the current date and time.  If a date and time is provided, results
    # will include Emergency Notification Recipients last modified on or before
    # that date and time.  Date/time format is YYYY-MM-DDTHH:MM:SS.mmmZ, where
    # the Z indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm"
    # represents the local time offset, plus or minus, from UTC time.           
    #      </p>             </td>         </tr>         <tr>             <td 
    # valign="top">                 <p>                     Size                
    # </p>             </td>             <td  valign="top">                 <p> 
    #                    Size=20                 </p>             </td>         
    #    <td  valign="top">                 <p>                     100         
    #        </p>             </td>             <td  valign="top">              
    #   <p>                     The maximum number of Emergency Notification
    # Recipient results to include in the response payload.  This value may be
    # between 1 and 500.                 </p>             </td>         </tr>
    # </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:100
    # @param [String] modified_after_date Optional parameter: Example:
    # @param [String] modified_by_user Optional parameter: Example:
    # @param [String] enr_description Optional parameter: Example:
    # @param [String] enr_notification_type Optional parameter: Example:
    # @param [String] enr_sms_tn Optional parameter: Example:
    # @param [String] enr_tts_tn Optional parameter: Example:
    # @param [String] enr_email_address Optional parameter: Example:
    # @param [String] enr_callback_url Optional parameter: Example:
    # @param [String] enr_callback_username Optional parameter: Example:
    # @return [Object] response from the API call
    def get_all_emergency_notification_recipient_for_account(account_id,
                                                             page: nil,
                                                             size: 100,
                                                             modified_after_date: nil,
                                                             modified_by_user: nil,
                                                             enr_description: nil,
                                                             enr_notification_type: nil,
                                                             enr_sms_tn: nil,
                                                             enr_tts_tn: nil,
                                                             enr_email_address: nil,
                                                             enr_callback_url: nil,
                                                             enr_callback_username: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationrecipients'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'ModifiedAfterDate' => modified_after_date,
        'ModifiedByUser' => modified_by_user,
        'EnrDescription' => enr_description,
        'EnrNotificationType' => enr_notification_type,
        'EnrSmsTn' => enr_sms_tn,
        'EnrTtsTn' => enr_tts_tn,
        'EnrEmailAddress' => enr_email_address,
        'EnrCallbackUrl' => enr_callback_url,
        'EnrCallbackUsername' => enr_callback_username
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <p><b>Condition:</b> Unrecognized query' \
          ' parameter <br> <b>Error Description:</b>Query' \
          ' parameter xxx is not recognized. </p> <br>' \
          ' <p><b>Condition:</b>Unsupported value for query' \
          ' parameter <br> <b>Error Description:</b>Invalid value' \
          ' xxx for query parameter yyy. Supported values are aaa,' \
          ' bbb, etc. </p>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b>User does not have' \
          ' permission to view emergency notification recipients,' \
          ' either due to Role/Permission or because the account' \
          ' is not configured for Emergency Notification' \
          ' Config.<br> <b>Error Description:</b>Access Denied </p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # <p> Create a new emergency notification recipient.  <br>URI Parameters:
    # <b>accountId</b> - the bandwidth Dashboard account that this emergency
    # notification recipient is to belong to </p><p><b>Emergency notification
    # recipient request elements</b></p><table border="1" cellspacing="0"
    # cellpadding="0" width="624">        <tbody>            <tr>               
    # <td valign="top">                    <p>                       
    # <strong>Parameter</strong>                    </p>                </td>   
    #             <td width="351" valign="top">                    <p>          
    #              <strong>Description</strong>                    </p>         
    #       </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                        Description   
    #                 </p>                </td>                <td width="351"
    # valign="top">                    <p>                        A mandatory
    # 200 character description of the Emergency Notification Recipient.  The
    # contents of this field are freeform, but ideally should describe who is
    # being notified and by what means.  E.g. Voice notification to building 5
    # front desk.                    </p>                </td>            </tr> 
    #           <tr>                <td valign="top">                    <p>    
    #                    Type                    </p>                </td>      
    #          <td width="351" valign="top">                    <p>             
    #           A mandatory field indicating the means by which the emergency
    # call notification will be made.  The choices are":" EMAIL, SMS, TTS, and
    # CALLBACK.  EMAIL sends an email to the specified email address.  SMS sends
    # a text message to the specified telephone number.  TTS sends a voice call
    # with a text-to-speech announcement to the specified telephone number. 
    # CALLBACK causes invocation of a specified HTTPS URL.                   
    # </p>                </td>            </tr>            <tr>               
    # <td valign="top">                    <p>                       
    # EmailAddress                    </p>                </td>               
    # <td width="351" valign="top">                    <p>                      
    #  An email address that must be specified when the Type is set to EMAIL. 
    # The value must be formatted like a valid email address.  E.g.
    # FredJones@gmail.com.  An email address can be up to 254 characters long.  
    #                  </p>                </td>            </tr>           
    # <tr>                <td valign="top">                    <p>              
    #          Sms TelephoneNumber                    </p>                </td> 
    #               <td width="351" valign="top">                    <p>        
    #                A telephone number capable of receiving text messages that
    # must be specified when Type is set to SMS.  Format is 11 digits":"
    # 1NPANXXXXXX.                    </p>                </td>            </tr>
    #            <tr>                <td valign="top">                    <p>   
    #                     Tts TelephoneNumber                    </p>           
    #     </td>                <td width="351" valign="top">                   
    # <p>                        A telephone number capable of receiving voice
    # calls that must be specified when Type is set to TTS.  Format is 11
    # digits":" 1NPANXXXXXX.                    </p>                </td>       
    #     </tr>            <tr>                <td valign="top">                
    #    <p>                        Callback Url                    </p>        
    #        </td>                <td width="351" valign="top">                 
    #   <p>                        An https URL that must be provided when Type
    # is set to CALLBACK.                        The URL may optionally include
    # one or mory query parameters.  E.g. https://foo.com/bar?param=value.  The
    # URL may be up to 256 characters.                    </p>               
    # </td>            </tr>            <tr>                <td valign="top">   
    #                 <p>                        Callback Username              
    #      </p>                </td>                <td width="351"
    # valign="top">                    <p>                        A username to
    # be used in Basic Authentication of the callback that must be specified
    # when Type is CALLBACK.  The username may be up to 32 characters.          
    #          </p>                </td>            </tr>            <tr>       
    #         <td valign="top">                    <p>                       
    # Callback Password                    </p>                </td>            
    #    <td width="351" valign="top">                    <p>                   
    #     A password to be used in Basic Authentication of the callback that
    # must be specified when Type is CALLBACK.  Passwords may be up to 256
    # characters.  Passwords are not included in GET responses.                 
    #   </p>                </td>            </tr>        </tbody>    </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [EmergencyNotificationRecipientPayload] body Optional parameter:
    # Example:
    # @return [Object] response from the API call
    def create_emergency_notification_recipient(account_id,
                                                body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationrecipients'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'EmergencyNotificationRecipient', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <table border="1" cellspacing="0"' \
          ' cellpadding="0" width="624"> <tbody> <tr> <td' \
          ' valign="top"> <p> <strong>Condition</strong> </p>' \
          ' </td> <td width="351" valign="top"> <p> <strong>Error' \
          ' Description</strong> </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Missing or empty description </p>' \
          ' </td> <td width="351" valign="top"> <p> Description' \
          ' must be present and non-empty. </p> </td> </tr> <tr>' \
          ' <td valign="top"> <p> Missing type </p> </td> <td' \
          ' width="351" valign="top"> <p> Type is a mandatory' \
          ' element. </p> </td> </tr> <tr> <td valign="top"> <p>' \
          ' Unrecognized type value </p> </td> <td width="351"' \
          ' valign="top"> <p> Type value must be one of \'EMAIL\',' \
          ' \'SMS\', \'TTS\', or \'CALLBACK\'. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Missing data required for' \
          ' type - for example, type is EMAIL, but no EmailAddress' \
          ' element is present. </p> </td> <td width="351"' \
          ' valign="top"> <p> When Type xxx is specified, yyy must' \
          ' be included., where xxx is one of the type values and' \
          ' yyy is the element that is missing. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Malformed email </p> </td>' \
          ' <td width="351" valign="top"> <p> Invalid' \
          ' EmailAddress.  Format should be foo@bar.com.  Max' \
          ' length is 254 characters. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Malformed telephone number </p>' \
          ' </td> <td width="351" valign="top"> <p> Invalid' \
          ' TelephoneNumber.  Telephone number must be 11 digits' \
          ' in format 1NPANXXXXXX. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Malformed url </p> </td> <td' \
          ' width="351" valign="top"> <p> Invalid Url.  Format' \
          ' should be https://foo.bar[?param=val]. </p> </td>' \
          ' </tr> <tr> <td valign="top"> <p> Malformed username' \
          ' </p> </td> <td width="351" valign="top"> <p> Invalid' \
          ' Username.  Username must be between 1 and 32' \
          ' characters. </p> </td> </tr> <tr> <td valign="top">' \
          ' <p> Malformed password </p> </td> <td width="351"' \
          ' valign="top"> <p> Invalid Password.  Password must be' \
          ' between 1 and 256 characters. </p> </td> </tr>' \
          ' </tbody> </table>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to configure emergency notification' \
          ' recipients, either due to Role/Permission or because' \
          ' the account is not enabled for Emergency' \
          ' Notifications. <br> <b>Error Description:</b> Access' \
          ' Denied </p>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict <br> <p> <b>Condition:</b> Duplicate entry <br> <b>Error' \
          ' Description:</b> An entry with an identical recipient' \
          ' already exists. Identifier xxx., where xxx is replaced' \
          ' with the emergency notification recipient Identifier' \
          ' of the existing entry.</p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # <p>The PUT operation is used to replace an emergency notification
    # recipient without changing its identifier value.  All emergency
    # notification recipient fields must be specified, even if they are not
    # changing.URI parameters: The account id of the account to which the
    # emergency notification recipient belongs.  The identifier assigned to the
    # emergency notification recipient when it was created. </p><p>Emergency
    # notification recipient request elements:</p><b>Description</b> - A
    # mandatory 200 character description of the Emergency Notification
    # Recipient.  The contents of this field are freeform, but ideally should
    # describe who is being notified and by what means.  E.g. Voice notification
    # to building 5 front desk.<br><br><b>Type</b> - A mandatory field
    # indicating the means by which the emergency call notification will be
    # made.  The choices are: EMAIL, SMS, TTS, and CALLBACK.  EMAIL sends an
    # email to the specified email address.  SMS sends a text message to the
    # specified telephone number.  TTS sends a voice call with a text-to-speech
    # announcement to the specified telephone number.  CALLBACK causes
    # invocation of a specified HTTPS URL.<br><br><b>EmailAddress</b> - An email
    # address that must be specified when the Type is set to EMAIL.  The value
    # must be formatted like a valid email address.  E.g. FredJones@gmail.com. 
    # An email address can be up to 254 characters long.<br><br><b>Sms
    # TelephoneNumber</b> - A telephone number capable of receiving text
    # messages that must be specified when Type is set to SMS.  Format is 11
    # digits: 1NPANXXXXXX.<br><br><b>Tts TelephoneNumber</b> - A telephone
    # number capable of receiving voice calls that must be specified when Type
    # is set to TTS.  Format is 11 digits: 1NPANXXXXXX.<br><br><b>Callback
    # Url</b> - An https URL that must be provided when Type is set to CALLBACK.
    #  The URL may optionally include one or mory query parameters.  E.g.
    # https://foo.com/bar?param=value.  The URL may be up to 256
    # characters.<br><br><b>Callback Username</b> - A username to be used in
    # Basic Authentication of the callback that must be specified when Type is
    # CALLBACK.  The username may be up to 32 characters.<br><br><b>Callback
    # Password</b> - A password to be used in Basic Authentication of the
    # callback that must be specified when Type is CALLBACK.  Passwords may be
    # up to 256 characters.  Passwords are not included in GET
    # responses.<br><br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] enr_id Required parameter: Example:
    # @param [EmergencyNotificationRecipientPayload] body Optional parameter:
    # Example:
    # @return [Object] response from the API call
    def update_emergency_notification_recipient(account_id,
                                                enr_id,
                                                body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationrecipients/{enrId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'enrId' => { 'value' => enr_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'EmergencyNotificationRecipient', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <table border="1" cellspacing="0"' \
          ' cellpadding="0" width="624"> <tbody> <tr> <td' \
          ' valign="top"> <p> <strong>Condition</strong> </p>' \
          ' </td> <td width="351" valign="top"> <p> <strong>Error' \
          ' Description</strong> </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Missing or empty description </p>' \
          ' </td> <td width="351" valign="top"> <p> Description' \
          ' must be present and non-empty. </p> </td> </tr> <tr>' \
          ' <td valign="top"> <p> Missing type </p> </td> <td' \
          ' width="351" valign="top"> <p> Type is a mandatory' \
          ' element. </p> </td> </tr> <tr> <td valign="top"> <p>' \
          ' Unrecognized type value </p> </td> <td width="351"' \
          ' valign="top"> <p> Type value must be one of \'EMAIL\',' \
          ' \'SMS\', \'TTS\', or \'CALLBACK\'. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Missing data required for' \
          ' type - for example, type is EMAIL, but no EmailAddress' \
          ' element is present. </p> </td> <td width="351"' \
          ' valign="top"> <p> When Type xxx is specified, yyy must' \
          ' be included., where xxx is one of the type values and' \
          ' yyy is the element that is missing. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Malformed email </p> </td>' \
          ' <td width="351" valign="top"> <p> Invalid' \
          ' EmailAddress.  Format should be foo@bar.com.  Max' \
          ' length is 254 characters. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Malformed telephone number </p>' \
          ' </td> <td width="351" valign="top"> <p> Invalid' \
          ' TelephoneNumber.  Telephone number must be 11 digits' \
          ' in format 1NPANXXXXXX. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Malformed url </p> </td> <td' \
          ' width="351" valign="top"> <p> Invalid Url.  Format' \
          ' should be https://foo.bar[?param=val]. </p> </td>' \
          ' </tr> <tr> <td valign="top"> <p> Malformed username' \
          ' </p> </td> <td width="351" valign="top"> <p> Invalid' \
          ' Username.  Username must be between 1 and 32' \
          ' characters. </p> </td> </tr> <tr> <td valign="top">' \
          ' <p> Malformed password </p> </td> <td width="351"' \
          ' valign="top"> <p> Invalid Password.  Password must be' \
          ' between 1 and 256 characters. </p> </td> </tr>' \
          ' </tbody> </table>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to configure emergency notification' \
          ' recipients, either due to Role/Permission or because' \
          ' the account is not enabled for Emergency' \
          ' Notifications. <br> <b>Error Description:</b> Access' \
          ' Denied </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p> <b>Condition:</b> Specified' \
          ' emergency notification recipient ID does not exist for' \
          ' this account <br> <b>Error Description:</b> The' \
          ' resource does not exist </p>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          '<p> <b>Condition:</b> Duplicate entry <br> <b>Error' \
          ' Description:</b> An entry with an identical recipient' \
          ' already exists. Identifier xxx., where xxx is replaced' \
          ' with the emergency notification recipient Identifier' \
          ' of the existing entry. </p> <br>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # The DELETE operation is used to remove the emergency notification
    # recipient specified by its identifier. <br><br>An emergency notification
    # recipient cannot be removed if it is still used by an emergency
    # notification group. If you wish to remove an emergency notification
    # recipient that is associated with an emergency notificaiton group, use the
    # /account/{accountId}/emergencyNotificationGroupOrders endpoint to remove
    # the group or modify the group to no longer use this emergency notification
    # recipient.URI parameters:    <ul>      <li>      <b>accountId</b> - the
    # account id of the account to which the emergency notification recipient
    # belongs      </li>      <li>      <b>enrId</b> - the identifier assigned
    # to the emergency notification recipient when it was created      </li>   
    # </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] enr_id Required parameter: Example:
    # @return [Object] response from the API call
    def delete_emergency_notification_recipient(account_id,
                                                enr_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationrecipients/{enrId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'enrId' => { 'value' => enr_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to configure emergency notification' \
          ' recipients, either due to Role/Permission or because' \
          ' the account is not configured for Emergency' \
          ' Notification Config. <br> <b>Error Description:</b>' \
          ' Access Denied </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p><b>Condition:</b> The' \
          ' emergency notification recipient identifier does not' \
          ' exist, or does not exist for the specified account id.' \
          ' <br> <b>Error Description:</b> The resource does not' \
          ' exist </p> <br>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict <br> <p> <b>Condition:</b> Attempt to delete an' \
          ' emergency notification recipient that is referenced by' \
          ' an emergency notification group. <br> <b>Error' \
          ' Description:</b> Emergency notification recipient with' \
          ' identifier xxx is being used by emergency notification' \
          ' group with identifier yyy. Please remove the recipient' \
          ' reference from the group prior to removing the' \
          ' recipient., where xxx is replaced by the emergency' \
          ' notification recipient ID and yyy is replaced by the' \
          ' emergency notification group ID. </p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # <p> The GET operation provides a means of fetching all of the emergency
    # notification group order history for an account. <br>A number of query
    # parameters are provided to filter the results. <br>URI Parameters:
    # <b>accountId</b> - the account id of the account to which the emergency
    # notification recipient belongs </p><p>The GET operation has no payload,
    # although the accountId URI parameter is mandatory and a number of optional
    # query parameters may be added.Results are returned by default in the order
    # of newest to oldest creation date of the Emergency Notification Group
    # Order. This default order is reversed from oldest to newest when the
    # CreatedAfterDate query parameter is included in the query.Query parameters
    # are appended to the end of the endpoint, separated by a '?' and in the
    # format parameter=value. If you wish to specify more than one query
    # parameter, separate them using an '&' character. The order of query
    # parameters does not matter. For example: <br>GET
    # /accounts/{accountId}/emergencyNotificationGroupOrders?EnrDescription=fron
    # t desk&EnrType=SMS <br>...will return all Emergency Notification Group
    # Orders associated with Emergency Notification Recipients having a
    # description field including the string "front desk" and a notification
    # type of SMS. The results will be sorted from newest order to oldest order.
    # <br>This endpoint supports the following query parameters. All query
    # parameters are optional.<table>        <tr>          <th>Parameter
    # Name</th>          <th>Example</th>          <th>Default</th>         
    # <th>Usage</th>        </tr>        <tr>            <td valign="top">      
    #          <p>                    CreatedAfterDate                </p>      
    #      </td>            <td  valign="top">                <p>               
    #     CreatedAfterDate=                    2020-04-03T00:00:00.000-04:00    
    #            </p>            </td>            <td valign="top">             
    #   <p>                    Results are returned in order from newest to
    # oldest order creation date                </p>            </td>           
    # <td valign="top">                <p>                  Include results only
    # for orders having order creation date and time after the date and time
    # specified in this parameter.  Note that inclusion of this parameter
    # reverses the default sort order of the results to ascending in date/time
    # (i.e. from oldest to newest).  If you are looking for the
    # CreatedBeforeDate query parameter, please see the Page parameter. 
    # Date/time format is YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z indicate UTC
    # time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm" represents the
    # local time offset, plus or minus, from UTC time.                </p>      
    #      </td>        </tr>        <tr>            <td valign="top">          
    #      <p>                    CreatedByUser                </p>           
    # </td>            <td valign="top">                <p>                    
    # CreatedByUser=catlee                </p>            </td>            <td 
    # valign="top">                <p>                    No filter             
    #   </p>            </td>            <td valign="top">                <p>   
    #                 Include results only for orders created by the user
    # specified in this parameter.                </p>            </td>       
    # </tr>        <tr>            <td valign="top">                <p>         
    #           EnrOperation                </p>            </td>            <td
    #  valign="top">                <p>                    EnrOperation=AddedEnr
    #                </p>            </td>            <td  valign="top">        
    #        <p>                    No filter                </p>           
    # </td>            <td  valign="top">                <p>                   
    # Include results only for orders requesting one of the following emergency
    # notification recipient operations: AddedEnr or DeletedEnr.               
    # </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    ProcessingStatus      
    #          </p>            </td>            <td valign="top">               
    # <p>                    ProcessingStatus=FAILED                </p>        
    #    </td>            <td  valign="top">                <p>                 
    #   No filter                </p>            </td>            <td 
    # valign="top">                <p>                    Include results only
    # for orders having one of the following processing status values: FAILED or
    # COMPLETED.                </p>            </td>        </tr>        <tr>  
    #          <td valign="top">                <p>                   
    # CustomerOrderId                </p>            </td>            <td
    # valign="top">                <p>                   
    # CustomerOrderId=j3jljkd8                </p>            </td>           
    # <td valign="top">                <p>                    No filter         
    #       </p>            </td>            <td  valign="top">               
    # <p>                    Include results only for orders having the
    # specified customer order id value.                </p>            </td>   
    #     </tr>        <tr>            <td valign="top">                <p>     
    #               EngId                </p>            </td>            <td
    # valign="top">                <p>                    EngId=                
    #    63865500-0904-46b1-9b4f-7bd237a26363                </p>           
    # </td>            <td valign="top">                <p>                   
    # No filter                </p>            </td>            <td
    # valign="top">                <p>                    The Identifier of an
    # Emergency Notification Group that was altered by an order.               
    # </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    EngDescription        
    #        </p>            </td>            <td valign="top">               
    # <p>                    EngDesription=3rd floor                </p>        
    #    </td>            <td valign="top">                <p>                  
    #  No filter                </p>            </td>            <td 
    # valign="top">                <p>                    A substring that will
    # exist in the emergency notification group Description for all returned
    # Emergency Notification Group Orders.                </p>            </td> 
    #       </tr>        <tr>            <td valign="top">                <p>   
    #                 EnrId                </p>            </td>            <td 
    # valign="top">                <p>                    EnrId=                
    #    63865500-0904-46b1-9b4f-7bd237a26363                </p>           
    # </td>            <td valign="top">                <p>                   
    # No filter                </p>            </td>            <td 
    # valign="top">                <p>                    The Identifier of an
    # Emergency Notification Recipient that is associated with the Emergency
    # Notification Groups in all orders returned.                </p>           
    # </td>        </tr>        <tr>            <td valign="top">               
    # <p>                    EnrDescription                </p>            </td>
    #            <td valign="top">                <p>                   
    # EnrDescription=front desk                </p>            </td>           
    # <td valign="top">                <p>                    No filter         
    #       </p>            </td>            <td valign="top">               
    # <p>                    A substring that will exist in all Emergency
    # Notification Recipient Descriptions associated with the Emergency
    # Notification Groups in all orders returned.                </p>           
    # </td>        </tr>        <tr>            <td valign="top">               
    # <p>                    EnrNotificationType                </p>           
    # </td>            <td valign="top">                <p>                   
    # EnrNotificationType=TTS                </p>            </td>           
    # <td valign="top">                <p>                    No filter         
    #       </p>            </td>            <td valign="top">               
    # <p>                    The type of notification (EMAIL, SMS, TTS, or
    # CALLBACK) specified for Emergency Notification Recipients associated with
    # the Emergency Notification Groups in all orders returned.               
    # </p>            </td>        </tr>        <tr>            <td 
    # valign="top">                <p>                    EnrSmsTn              
    #  </p>            </td>            <td  valign="top">                <p>   
    #                 EnrSmsTn=3037458827                </p>            </td>  
    #          <td  valign="top">                <p>                    No
    # filter                </p>            </td>            <td  valign="top"> 
    #               <p>                    The Short Message Service telephone
    # number in all SMS type Emergency Notification Recipients associated with
    # the Emergency Notification Groups in all orders returned.               
    # </p>            </td>        </tr>        <tr>            <td 
    # valign="top">                <p>                    EnrTtsTn              
    #  </p>            </td>            <td  valign="top">                <p>   
    #                 EnrTtsTn=402288875                </p>            </td>   
    #         <td  valign="top">                <p>                    No filter
    #                </p>            </td>            <td  valign="top">        
    #        <p>                    The Text To Speech telephone number in all
    # TTS type Emergency Notification Recipients associated with the Emergency
    # Notification Groups in all orders returned.                </p>           
    # </td>        </tr>        <tr>            <td  valign="top">              
    #  <p>                    EnrEmailAddress                </p>           
    # </td>            <td  valign="top">                <p>                   
    # EnrEmailAddress=fred@aol.com                </p>            </td>         
    #   <td  valign="top">                <p>                    No filter      
    #          </p>            </td>            <td  valign="top">              
    #  <p>                    The email address in all EMAIL type Emergency
    # Notification Recipients associated with the Emergency Notification Groups
    # in all orders returned.                </p>            </td>        </tr> 
    #       <tr>            <td  valign="top">                <p>               
    #     EnrCallbackUrl                </p>            </td>            <td 
    # valign="top">                <p>                    EnrCallbackUrl=       
    #             https://e911.callback.mycompany.com                </p>       
    #     </td>            <td  valign="top">                <p>                
    #    No filter                </p>            </td>            <td 
    # valign="top">                <p>                    The callback URL in
    # all CALLBACK type Emergency Notification Recipients associated with the
    # Emergency Notification Groups in all orders returned.                </p> 
    #           </td>        </tr>        <tr>            <td  valign="top">    
    #            <p>                    EnrCallbackUsername                </p> 
    #           </td>            <td  valign="top">                <p>          
    #          EnrCallbackUsername=ljames                </p>            </td>  
    #          <td  valign="top">                <p>                    No
    # filter                </p>            </td>            <td  valign="top"> 
    #               <p>                    The callback username in all CALLBACK
    # type Emergency Notification Recipients associated with the Emergency
    # Notification Groups in all orders returned.                </p>           
    # </td>        </tr>        <tr>            <td  valign="top">              
    #  <p>                    Page                </p>            </td>         
    #   <td  valign="top">                <p>                   
    # Page=2019-08-01Z                </p>            </td>            <td 
    # valign="top">                <p>                    Now               
    # </p>            </td>            <td  valign="top">                <p>    
    #              This represents the position in the data set from which you
    # want your output to begin.  If this parameter is omitted, results will
    # include Emergency Notification Group Orders created on or before the
    # current date and time.  If a date and time is provided, results will
    # include Emergency Notification Group Orders created on or before that date
    # and time.  Date/time format is YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z
    # indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm"
    # represents the local time offset, plus or minus, from UTC time.           
    #     </p>            </td>        </tr>        <tr>            <td 
    # valign="top">                <p>                    Size               
    # </p>            </td>            <td  valign="top">                <p>    
    #                Size=200                </p>            </td>           
    # <td  valign="top">                <p>                    100              
    #  </p>            </td>            <td  valign="top">                <p>   
    #               The maximum number of Emergency Notification Group Order
    # results to include in the response payload.  This value may be between 1
    # and 500.                </p>            </td>        </tr></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:100
    # @param [String] created_after_date Optional parameter: Example:
    # @param [String] created_by_user Optional parameter: Example:
    # @param [String] eng_operation Optional parameter: Example:
    # @param [String] enr_operation Optional parameter: Example:
    # @param [String] processing_status Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] eng_id Optional parameter: Example:
    # @param [String] eng_description Optional parameter: Example:
    # @param [String] enr_id Optional parameter: Example:
    # @param [String] enr_description Optional parameter: Example:
    # @param [String] enr_notification_type Optional parameter: Example:
    # @param [String] enr_sms_tn Optional parameter: Example:
    # @param [String] enr_tts_tn Optional parameter: Example:
    # @param [String] enr_email_address Optional parameter: Example:
    # @param [String] enr_callback_url Optional parameter: Example:
    # @param [String] enr_callback_username Optional parameter: Example:
    # @param [String] expand_errors Optional parameter: Example:false
    # @param [String] enr_details Optional parameter: Example:false
    # @return [EmergencyNotificationGroupRecipientOrderResponse] response from the API call
    def get_group_orders(account_id,
                         page: nil,
                         size: 100,
                         created_after_date: nil,
                         created_by_user: nil,
                         eng_operation: nil,
                         enr_operation: nil,
                         processing_status: nil,
                         customer_order_id: nil,
                         eng_id: nil,
                         eng_description: nil,
                         enr_id: nil,
                         enr_description: nil,
                         enr_notification_type: nil,
                         enr_sms_tn: nil,
                         enr_tts_tn: nil,
                         enr_email_address: nil,
                         enr_callback_url: nil,
                         enr_callback_username: nil,
                         expand_errors: 'false',
                         enr_details: 'false')
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationgrouporders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'CreatedAfterDate' => created_after_date,
        'CreatedByUser' => created_by_user,
        'EngOperation' => eng_operation,
        'EnrOperation' => enr_operation,
        'ProcessingStatus' => processing_status,
        'CustomerOrderId' => customer_order_id,
        'EngId' => eng_id,
        'EngDescription' => eng_description,
        'EnrId' => enr_id,
        'EnrDescription' => enr_description,
        'EnrNotificationType' => enr_notification_type,
        'EnrSmsTn' => enr_sms_tn,
        'EnrTtsTn' => enr_tts_tn,
        'EnrEmailAddress' => enr_email_address,
        'EnrCallbackUrl' => enr_callback_url,
        'EnrCallbackUsername' => enr_callback_username,
        'ExpandErrors' => expand_errors,
        'EnrDetails' => enr_details
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <p><b>Condition:</b> Unrecognized query' \
          ' parameter <br> <b>Error Description:</b>Query' \
          ' parameter xxx is not recognized. </p> <br>' \
          ' <p><b>Condition:</b>Unsupported value for query' \
          ' parameter <br> <b>Error Description:</b>Invalid value' \
          ' xxx for query parameter yyy. Supported values are aaa,' \
          ' bbb, etc. </p>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b>User does not have' \
          ' permission to view emergency notification group' \
          ' orders, either due to Role/Permission or because the' \
          ' account is not configured for Emergency Notification' \
          ' Config.<br> <b>Error Description:</b>Access Denied </p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body, 'EmergencyNotificationGroupOrderResponse',
        EmergencyNotificationGroupRecipientOrderResponse
      )
      )
    end

    # <p> The POST operation is used to create an order to create, update, or
    # delete an emergency notification group. <br>URI Parameters:
    # <b>accountId</b> - the account id of the account to which the emergency
    # notification recipient belongs </p><p><b>Emergency notification group
    # order request elements</b></p><table border="1" cellspacing="0"
    # cellpadding="0" width="724">        <tbody>            <tr>               
    # <td valign="top">                    <p>                       
    # <strong>Parameter</strong>                    </p>                </td>   
    #             <td width="451" valign="top">                    <p>          
    #              <strong>Description</strong>                    </p>         
    #       </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                       
    # CustomerOrderId                    </p>                </td>              
    #  <td width="451" valign="top">                    <p>                     
    #   An optional customer-defined order identifier that is stored with the
    # Bandwidth order.  This value is opaque to Bandwidth.                   
    # </p>                </td>            </tr>            <tr>               
    # <td valign="top">                    <p>                        (emergency
    # notification group) Identifier                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       A mandatory identifier of the Emergency Notification
    # Group to be deleted or updated.                    </p>               
    # </td>            </tr>            <tr>                <td valign="top">   
    #                 <p>                        AddedEmergencyNotificationGroup
    #                    </p>                </td>                <td
    # width="451" valign="top">                    <p>                       
    # Indicates that the order is to add an emergency notification group.       
    #             </p>                </td>            </tr>            <tr>    
    #            <td valign="top">                    <p>                       
    # DeletedEmergencyNotificationGroup                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       Indicates that the order is to delete an emergency
    # notification group.                    </p>                </td>          
    #  </tr>            <tr>                <td valign="top">                   
    # <p>                        UpdatedEmergencyNotificationGroup              
    #      </p>                </td>                <td width="451"
    # valign="top">                    <p>                        Indicates that
    # the order is to modify an emergency notification group.                   
    # </p>                </td>            </tr>            <tr>               
    # <td valign="top">                    <p>                       
    # Description                    </p>                </td>               
    # <td width="451" valign="top">                    <p>                      
    #  A mandatory 200 character description of the Emergency Notification
    # Group.                        The contents of this field are freeform, but
    # ideally should describe the set of endpoints                        that
    # are being grouped together for the purpose of having the same emergency
    # notification recipients.  E.g. Occupants of building 5 main campus.       
    #             </p>                </td>            </tr>            <tr>    
    #            <td valign="top">                    <p>                       
    # AddedEmergencyNotificationRecipients                    </p>              
    #  </td>                <td width="451" valign="top">                    <p>
    #                        Indicates that emergency notification recipients
    # are being added to the emergency notification group.                   
    # </p>                </td>            </tr>            <tr>               
    # <td valign="top">                    <p>                       
    # DeletedEmergencyNotificationRecipients                    </p>            
    #    </td>                <td width="451" valign="top">                   
    # <p>                        Indicates that emergency notification
    # recipients are being removed from the emergency notification group.       
    #             </p>                </td>            </tr>            <tr>    
    #            <td valign="top">                    <p>                       
    # EmergencyNotificationRecipients                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       A list of one to three emergency notification
    # recipients being associated with this emergency notification group.       
    #             </p>                </td>            </tr>            <tr>    
    #            <td valign="top">                    <p>                       
    # EmergencyNotificationRecipient                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       One of up to three emergency notification recipients
    # belonging to this emergency notification group.                    </p>   
    #             </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                        (emergency
    # notification recipient) Identifier                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       The identifier that uniquely identifies an emergency
    # notification recipient.  This identifier was assigned when the emergency
    # notification recipient was created.  A given emergency notification
    # recipient may be associated with only one emergency notification group.   
    #                 </p>                </td>            </tr>        </tbody>
    #    </table><br><br>    <p><b>Creating a new emergency notification
    # group</b> <br>    An emergency notification group must have one to three
    # emergency notification recipients.  This means that the emergency
    # notification recipients must be created before the emergency notification
    # group.    </p>    <p><b>Deleting an emergency notification group</b> <br> 
    #   An emergency notification group may be deleted if there are no emergency
    # endpoints associated with the group.  Deleting an emergency notification
    # group that is configured with emergency notification recipients will
    # successfully delete the group, but will not delete the emergency
    # notification recipients.    </p>    <p><b>Updating an emergency
    # notification group</b> <br>    You may remove emergency notification
    # recipients from the emergency notification group, provided the total
    # number remaining is at least one.    </p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [EmergencyNotificationGroupRecipientOrderPayload] body Optional
    # parameter: Example:
    # @return [EmergencyNotificationGroupRecipientOrderResponse] response from the API call
    def create_group_order(account_id,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationgrouporders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'EmergencyNotificationGroupOrder', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <table border="1" cellspacing="0"' \
          ' cellpadding="0" width="724"> <tbody> <tr> <td' \
          ' valign="top"> <p> <strong>Condition</strong> </p>' \
          ' </td> <td width="451" valign="top"> <p> <strong>Error' \
          ' Description</strong> </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Order payload does not indicate' \
          ' whether the emergency notification group is being' \
          ' created, modified, or deleted </p> </td> <td' \
          ' width="451" valign="top"> <p> Order payload must' \
          ' include one of "AddedEmergencyNotificationGroup",' \
          ' "DeletedEmergencyNotificationGroup", or' \
          ' "ModifiedEmergencyNotificationGroup". </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Order is creating a new' \
          ' emergency notification group, but does not indicate' \
          ' that emergency notification recipients are being added' \
          ' </p> </td> <td width="451" valign="top"> <p> When' \
          ' creating an emergency notification group,' \
          ' "AddedEmergencyNotificationRecipients" must be' \
          ' included to indicate that emergency notification' \
          ' recipients are being added. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Missing or empty emergency' \
          ' notification group description </p> </td> <td' \
          ' width="451" valign="top"> <p> Emergency Notification' \
          ' Group Description must be present and non-empty. </p>' \
          ' </td> </tr> <tr> <td valign="top"> <p> No emergency' \
          ' notification recipients listed </p> </td> <td' \
          ' width="451" valign="top"> <p> An Emergency' \
          ' Notification Group must have 1, 2, or 3 Emergency' \
          ' Notification Recipients.  Note:<b></b> This can be' \
          ' used for missing list or empty list. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Too many emergency' \
          ' notification recipients listed </p> </td> <td' \
          ' width="451" valign="top"> <p> An Emergency' \
          ' Notification Group must have 1, 2, or 3 Emergency' \
          ' Notification Recipients. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Order does not include an emergency' \
          ' notification group </p> </td> <td width="451"' \
          ' valign="top"> <p> </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> The specified emergency notification' \
          ' group does not exist </p> </td> <td width="451"' \
          ' valign="top"> <p> ENG Identifier xxx does not exist.,' \
          ' where xxx is replaced by the emergency notification' \
          ' group identifier supplied in the request. </p> </td>' \
          ' </tr> <tr> <td valign="top"> <p> The specified' \
          ' emergency notification recipient identifier does not' \
          ' exist </p> </td> <td width="451" valign="top"> <p> ENR' \
          ' Identifier xxx does not exist., where xxx is replaced' \
          ' by the emergency notification recipient identifier' \
          ' supplied in the request. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Attempt to update an emergency' \
          ' notification group, but none of "Description",' \
          ' "AddedEmergencyNotificationRecipients", or' \
          ' "DeletedEmergencyNotificationRecipients" included </p>' \
          ' </td> <td width="451" valign="top"> <p> Update of ENG' \
          ' did not specify any of:<b></b> new description, added' \
          ' ENRs, or deleted ENRs. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Attempt to update an emergency' \
          ' notification group with both' \
          ' "AddedEmergencyNotificationRecipients" and' \
          ' "DeletedEmergencyNotificationRecipients" included </p>' \
          ' </td> <td width="451" valign="top"> <p> Update of ENG' \
          ' supports added ENRs or deleted ENRs, but not both.' \
          ' </p> </td> </tr> </tbody> </table>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to configure emergency notification group' \
          ' orders, either due to Role/Permission or because the' \
          ' account is not configured for Emergency Notification' \
          ' Config. <br> <b>Error Description:</b> Access Denied' \
          ' </p>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict <br> <table border="1" cellspacing="0" cellpadding="0"' \
          ' width="724"> <tbody> <tr> <td valign="top"> <p>' \
          ' <strong>Condition</strong> </p> </td> <td width="451"' \
          ' valign="top"> <p> <strong>Error Description</strong>' \
          ' </p> </td> </tr> <tr> <td valign="top"> <p> Invalid' \
          ' emergency notification recipient identifier </p> </td>' \
          ' <td width="451" valign="top"> <p> Emergency' \
          ' Notification Recipient Identifier xxx does not exist.,' \
          ' where xxx is replaced by the emergency notification' \
          ' recipient identifier supplied in the request. ' \
          ' Note:<b></b> This error can be used also for the case' \
          ' where the emergency notification recipient ID exists,' \
          ' but not for this Iris account. </p> </td> </tr> <tr>' \
          ' <td valign="top"> <p> Specified emergency notification' \
          ' recipient is already associated with another emergency' \
          ' notification group </p> </td> <td width="451"' \
          ' valign="top"> <p> The Emergency Notification Recipient' \
          ' with identifier xxx is already associated with' \
          ' Emergency Notification Group with identifier yyy.,' \
          ' where xxx is replaced with the emergency notification' \
          ' recipient ID supplied in the request, and yyy is' \
          ' replaced by the emergency notification group ID of the' \
          ' emergency notification group that the supplied' \
          ' emergency notification recipient ID is associated' \
          ' with.  Note:<b></b> The emergency notification group' \
          ' must also belong to this account. </p> </td> </tr>' \
          ' <tr> <td valign="top"> <p> Attempt to remove an' \
          ' emergency notification group that has emergency' \
          ' endpoints associated with it </p> </td> <td' \
          ' width="451" valign="top"> <p> ENG xxx cannot be' \
          ' removed until emergency endpoint associations are' \
          ' removed., where xxx is replaced by the emergency' \
          ' notification group identifier supplied in the request.' \
          ' </p> </td> </tr> <tr> <td valign="top"> <p> Removal of' \
          ' ENRs would leave the emergency notification group with' \
          ' no emergency notification recipient associations </p>' \
          ' </td> <td width="451" valign="top"> <p> An Emergency' \
          ' Notification Group must have 1, 2, or 3 Emergency' \
          ' Notification Recipients. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Addition of emergency notification' \
          ' recipients would leave the emergency notification' \
          ' group with too many emergency notification recipient' \
          ' associations </p> </td> <td width="451" valign="top">' \
          ' <p> An Emergency Notification Group must have 1, 2, or' \
          ' 3 Emergency Notification Recipients. </p> </td> </tr>' \
          ' </tbody> </table>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body, 'EmergencyNotificationGroupOrderResponse',
        EmergencyNotificationGroupRecipientOrderResponse
      )
      )
    end

    # This endpoint is used to query the status of a specified emergency
    # notification group order, using the order-id that was assigned in the 201
    # response to the order creation. <br>When you query an order-id, look for
    # the "ProcessingStatus" element in the 200 response.  Values may be:
    # PROCESSING, COMPLETED, or FAILED.  PROCESSING means that the system is
    # still processing the order.  Please wait a couple of minutes and fetch the
    # order results again.  COMPLETED means that the order has been successfully
    # completed.  FAILED means that errors occurred while processing the order,
    # and that the order did not make any changes to the system.  Look for the
    # "ErrorList" element to see what type of error occurred. <br>URI
    # parameters:<ul>  <li>  <b>accountId</b> - the account id of the account to
    # which the emergency notification group order belongs.  </li>  <li> 
    # <b>orderId</b> - the order identifier assigned to the emergency
    # notification group order when it was created.  </li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [EmergencyNotificationGroupRecipientOrderResponse] response from the API call
    def get_group_order(account_id,
                        order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationgrouporders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to view emergency notification group' \
          ' orders, either due to Role/Permission or because the' \
          ' account is not configured for Emergency Notification' \
          ' Config. <br> <b>Error Description:</b> Access Denied' \
          ' </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p><b>Condition:</b> Specified' \
          ' emergency notification group order-id does not exist' \
          ' for this account. <br> <b>Error Description:</b> The' \
          ' resource does not exist </p> <br>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body, 'EmergencyNotificationGroupOrderResponse',
        EmergencyNotificationGroupRecipientOrderResponse
      )
      )
    end

    # <p> The GET operation provides a means to query any Emergency Notification
    # Endpoint Order associated with the account. This endpoint is for querying
    # "orders", not the emergency endpoint to emergency notification group
    # associations themselves. <br>URI Parameters: <b>accountId</b> - the
    # account id of the account to which the emergency notification recipient
    # belongs. </p><p>The GET operation has no payload, although the accountId
    # URI parameter is mandatory and a number of optional query parameters may
    # be added. The query parameters are described in this section.   Results
    # are returned by default in the order of newest to oldest creation date of
    # the Emergency Notification Endpoint Order. This default order is reversed
    # from oldest to newest when the CreatedAfterDate query parameter is
    # included in the query.   Query parameters act as filters on the data. If
    # more than one query parameter is provided, the results will be the
    # intersection of the results from each query parameter. In other words, the
    # query parameters are logically ANDed.   Query parameters are appended to
    # the end of the endpoint, separated by a '?' and in the format
    # parameter=value. If you wish to specify more than one query parameter,
    # separate them using an '&' character. The order of query parameters does
    # not matter. For example:<br>   GET
    # /accounts/{accountId}/emergencyNotificationEndpointOrders?EngDescription=3
    # rd Floor&EndpointOperation=Dissociated <br>   ...will return all Emergency
    # Notification Endpoint Orders associated with Emergency Notification Groups
    # having a description field including the string "3rd Floor" and where
    # endpoints were dissociated from emergency notification groups. The results
    # will be sorted from newest order to oldest order.<br>    This endpoint
    # supports the following query parameters. All query parameters are
    # optional.</p><table>        <tr>          <th>Parameter Name</th>         
    # <th>Example</th>          <th>Default</th>          <th>Usage</th>       
    # </tr>        <tr>            <td valign="top">                <p>         
    #           CreatedAfterDate                </p>            </td>           
    # <td  valign="top">                <p>                    CreatedAfterDate=
    #                    2020-03-30T14:00:00Z                </p>           
    # </td>            <td valign="top">                <p>                   
    # No filter                </p>            </td>            <td
    # valign="top">                <p>                  Include results only for
    # orders having order creation date and time after the date and time
    # specified in this parameter.  Note that inclusion of this parameter
    # reverses the default sort order of the results to ascending in date/time
    # (i.e. from oldest to newest).  If you are looking for the
    # CreatedBeforeDate query parameter, please see the Page parameter.         
    #       </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    CreatedByUser         
    #       </p>            </td>            <td valign="top">               
    # <p>                     CreatedByUser=catlee                </p>          
    #  </td>            <td  valign="top">                <p>                   
    # No filter                </p>            </td>            <td
    # valign="top">                <p>                    Include results only
    # for orders created by the user specified in this parameter.               
    # </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    ProcessingStatus      
    #          </p>            </td>            <td valign="top">               
    # <p>                    ProcessingStatus=FAILED                </p>        
    #    </td>            <td  valign="top">                <p>                 
    #   No filter                </p>            </td>            <td 
    # valign="top">                <p>                    Include results only
    # for orders having one of the following processing status values: FAILED or
    # COMPLETED.                </p>            </td>        </tr>        <tr>  
    #          <td valign="top">                <p>                   
    # CustomerOrderId                </p>            </td>            <td
    # valign="top">                <p>                   
    # CustomerOrderId=j3jljkd8                </p>            </td>           
    # <td valign="top">                <p>                    No filter         
    #       </p>            </td>            <td  valign="top">               
    # <p>                    Include results only for orders having the
    # specified customer order id value.                </p>            </td>   
    #     </tr>        <tr>            <td valign="top">                <p>     
    #               EngId                </p>            </td>            <td
    # valign="top">                <p>                    EngId=                
    #    63865500-0904-46b1-9b4f-7bd237a26363                </p>           
    # </td>            <td valign="top">                <p>                   
    # No filter                </p>            </td>            <td
    # valign="top">                <p>                    The Identifier of an
    # Emergency Notification Group that was altered by an order.               
    # </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    EngDescription        
    #        </p>            </td>            <td valign="top">               
    # <p>                    EngDesription=3rd floor                </p>        
    #    </td>            <td valign="top">                <p>                  
    #  No filter                </p>            </td>            <td 
    # valign="top">                <p>                    A substring that will
    # exist in the emergency notification group Description for all returned
    # Emergency Notification Endpoint Orders.                </p>           
    # </td>        </tr>        <tr>            <td valign="top">               
    # <p>                    EepTns                </p>            </td>        
    #    <td  valign="top">                <p>                    EepTns=404    
    #            </p>            </td>            <td valign="top">             
    #   <p>                    No filter                </p>            </td>   
    #         <td  valign="top">                <p>                    Include
    # results only for orders having EepTns that start with the specified digit
    # string.  The digit string may be from 1 to 11 digits.                </p> 
    #           </td>        </tr>        <tr>            <td valign="top">     
    #           <p>                    EepAeuiIds                </p>           
    # </td>            <td valign="top">                <p>                   
    # EepAeuiIds=Joe                </p>            </td>            <td
    # valign="top">                <p>                    No filter             
    #   </p>            </td>            <td valign="top">                <p>   
    #                 Include results only for orders having EepAeuiIds that
    # start with the specified character string.  The string may be from 1 to 30
    # characters.                </p>            </td>        </tr>        <tr> 
    #           <td  valign="top">                <p>                    Page   
    #             </p>            </td>            <td  valign="top">           
    #     <p>                    Page=2019-08-01Z                </p>           
    # </td>            <td  valign="top">                <p>                   
    # Now                </p>            </td>            <td  valign="top">    
    #            <p>                  This represents the position in the data
    # set from which you want your output to begin.  If this parameter is
    # omitted, results will include Emergency Notification Endpoint Orders
    # created on or before the current date and time.  If a date and time is
    # provided, results will include Emergency Notification Endpoint Orders
    # created on or before that date and time.  Date/time format is
    # YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z indicate UTC time, or
    # YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm" represents the local time
    # offset, plus or minus, from UTC time.                </p>            </td>
    #        </tr>        <tr>            <td  valign="top">                <p> 
    #                   Size                </p>            </td>            <td
    #  valign="top">                <p>                    Size=5               
    # </p>            </td>            <td  valign="top">                <p>    
    #                100                </p>            </td>            <td 
    # valign="top">                <p>                  The maximum number of
    # Emergency Notification Endpoint Order results to include in the response
    # payload.  This value may be between 1 and 500.                </p>        
    #    </td>        </tr></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:100
    # @param [String] created_after_date Optional parameter: Example:
    # @param [String] created_by_user Optional parameter: Example:
    # @param [String] endpoint_operation Optional parameter: Example:
    # @param [String] processing_status Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] eng_id Optional parameter: Example:
    # @param [String] eng_description Optional parameter: Example:
    # @param [String] eep_tns Optional parameter: Example:
    # @param [String] eep_aeui_ids Optional parameter: Example:
    # @param [String] expand_errors Optional parameter: Example:false
    # @param [String] enr_details Optional parameter: Example:false
    # @return [EmergencyNotificationGroupsEndpointAssociationResponse] response from the API call
    def retrieve_groups_association_order(account_id,
                                          page: nil,
                                          size: 100,
                                          created_after_date: nil,
                                          created_by_user: nil,
                                          endpoint_operation: nil,
                                          processing_status: nil,
                                          customer_order_id: nil,
                                          eng_id: nil,
                                          eng_description: nil,
                                          eep_tns: nil,
                                          eep_aeui_ids: nil,
                                          expand_errors: 'false',
                                          enr_details: 'false')
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationendpointorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'CreatedAfterDate' => created_after_date,
        'CreatedByUser' => created_by_user,
        'EndpointOperation' => endpoint_operation,
        'ProcessingStatus' => processing_status,
        'CustomerOrderId' => customer_order_id,
        'EngId' => eng_id,
        'EngDescription' => eng_description,
        'EepTns' => eep_tns,
        'EepAeuiIds' => eep_aeui_ids,
        'ExpandErrors' => expand_errors,
        'EnrDetails' => enr_details
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <p><b>Condition:</b> Unrecognized query' \
          ' parameter <br> <b>Error Description:</b>Query' \
          ' parameter xxx is not recognized. </p> <br>' \
          ' <p><b>Condition:</b>Unsupported value for query' \
          ' parameter <br> <b>Error Description:</b>Invalid value' \
          ' xxx for query parameter yyy. Supported values are aaa,' \
          ' bbb, etc. </p>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b>User does not have' \
          ' permission to view Endpoint orders, either due to' \
          ' Role/Permission or because the account is not' \
          ' configured for Emergency Notification Config.<br>' \
          ' <b>Error Description:</b>Access Denied </p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body,
        'EmergencyNotificationEndpointOrderResponse',
        EmergencyNotificationGroupsEndpointAssociationResponse
      )
      )
    end

    # <p> The POST operation creates a new order to request that an emergency
    # endpoint be added to or removed from an emergency notification group.  A
    # given order may either add or remove associations, not both in one
    # order.<br>    If the order is successfully created, a 201 response is
    # returned, including an order-id that is used to query for completion of
    # the order. <br>    The order's ProcessingStatus is set to PROCESSING when
    # the request is successfully created.  When processing of all emergency
    # endpoint to emergency notification group associations has been attempted,
    # the software    will update the order's processing status to either
    # COMPLETED or FAILED. <br>URI Parameters: <b>accountId</b> - the account id
    # of the account to which the emergency endpoints and emergency notification
    # groups are configured. </p><p><b>The emergency notification endpoint order
    # includes the following payload elements:</b></p><table border="1"
    # cellspacing="0" cellpadding="0" width="724">        <tbody>           
    # <tr>                <td valign="top">                    <p>              
    #          <strong>Parameter</strong>                    </p>               
    # </td>                <td width="451" valign="top">                    <p> 
    #                       <strong>Description</strong>                    </p>
    #                </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                       
    # CustomerOrderId                    </p>                </td>              
    #  <td width="451" valign="top">                    <p>                     
    #   An optional customer-defined order identifier that is stored with the
    # Bandwidth order.  This value is opaque to Bandwidth.                   
    # </p>                </td>            </tr>            <tr>               
    # <td valign="top">                    <p>                       
    # EmergencyNotificationGroup Identifier                    </p>             
    #   </td>                <td width="451" valign="top">                   
    # <p>                        The mandatory identifier that uniquely
    # identifies the emergency notification group to which emergency endpoints
    # are being associated.  This value is assigned by the system when the
    # emergency notification group is created.                    </p>          
    #      </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                       
    # AddedAssociations                    </p>                </td>            
    #    <td width="451" valign="top">                    <p>                   
    #     Included when emergency endpoint to emergency notification group
    # associations are to be created.  Only AddedAssociations or Deleted
    # Associations may be included in a given order.                    </p>    
    #            </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                       
    # DeletedAssociations                    </p>                </td>          
    #      <td width="451" valign="top">                    <p>                 
    #       Included when emergency endpoint to emergency notification group
    # associations are to be removed.  Only AddedAssociations or Deleted
    # Associations may be included in a given order.                    </p>    
    #            </td>            </tr>            <tr>                <td
    # valign="top">                    <p>                       
    # EepToEngAssociations                    </p>                </td>         
    #       <td width="451" valign="top">                    <p>                
    #        Mandatory container for the list of TNs and AEUI identifiers to be
    # associated or dissociated with the emergency notification group.          
    #          </p>                </td>            </tr>            <tr>       
    #         <td valign="top">                    <p>                       
    # EepTns                    </p>                </td>                <td
    # width="451" valign="top">                    <p>                        A
    # container of emergency endpoints that are of type TN.  This element may be
    # omitted if none of the emergency endpoints to be associated or dissociated
    # are telephone numbers.                    </p>                </td>       
    #     </tr>            <tr>                <td valign="top">                
    #    <p>                        TelephoneNumber                    </p>     
    #           </td>                <td width="451" valign="top">              
    #      <p>                        A 10-digit telephone number representing
    # an emergency endpoint in the ListOfEepTns.  The list may consist of a
    # single TN if desired.                    </p>                </td>        
    #    </tr>            <tr>                <td valign="top">                 
    #   <p>                        EepAeuiIds                    </p>           
    #     </td>                <td width="451" valign="top">                   
    # <p>                        A container of emergency endpoints that are of
    # type AEUI.  This element may be omitted if none of the emergency endpoints
    # to be associated or dissociated are Alternate End User Identities.        
    #            </p>                </td>            </tr>            <tr>     
    #           <td valign="top">                    <p>                       
    # Identifier                    </p>                </td>                <td
    # width="451" valign="top">                    <p>                        A
    # unique identifier for the AEUI representing an emergency endpoint in the
    # ListOfEepAeuiIds.  The list may consist of a single AEUI ID if desired.   
    #                 </p>                </td>            </tr>        </tbody>
    #    </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [EmergencyNotificationGroupEndpointAssociationPayload] body
    # Optional parameter: Example:
    # @return [EmergencyNotificationGroupEndpointAssociationResponse] response from the API call
    def create_group_order_1(account_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationendpointorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'EmergencyNotificationEndpointOrder', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <table border="1" cellspacing="0"' \
          ' cellpadding="0" width="724"> <tbody> <tr> <td' \
          ' valign="top"> <p> <strong>Condition</strong> </p>' \
          ' </td> <td width="451" valign="top"> <p> <strong>Error' \
          ' Description</strong> </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Order payload does not indicate' \
          ' whether the endpoints are being added or deleted </p>' \
          ' </td> <td width="451" valign="top"> <p> Order payload' \
          ' must include one of "AddedAssociations" or' \
          ' "DeletedAssociations". </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Attempt to both add and delete' \
          ' endpoint associations in one request </p> </td> <td' \
          ' width="451" valign="top"> <p> Order payload must' \
          ' include one of "AddedAssociations" or' \
          ' "DeletedAssociations", but not both in one request.' \
          ' </p> </td> </tr> <tr> <td valign="top"> <p> Order' \
          ' payload does not specify any endpoints to be added' \
          ' </p> </td> <td width="451" valign="top"> <p> Order' \
          ' payload must include at least one Emergency Enpoint' \
          ' value. </p> </td> </tr> <tr> <td valign="top"> <p> Too' \
          ' many emergency endpoints listed </p> </td> <td' \
          ' width="451" valign="top"> <p> Please limit the total' \
          ' number of emergency endpoints to 5000 per request.' \
          ' </p> </td> </tr> </tbody> </table>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to configure associations between emergency' \
          ' endpoints and an emergency notification group, either' \
          ' due to Role/Permission or because the account is not' \
          ' configured for Emergency Notification Config. <br>' \
          ' <b>Error Description:</b> Access Denied </p>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict <br> <table border="1" cellspacing="0" cellpadding="0"' \
          ' width="724"> <tbody> <tr> <td valign="top"> <p>' \
          ' <strong>Condition</strong> </p> </td> <td width="451"' \
          ' valign="top"> <p> <strong>Error Description</strong>' \
          ' </p> </td> </tr> <tr> <td valign="top"> <p> Invalid' \
          ' emergency notification group identifier </p> </td> <td' \
          ' width="451" valign="top"> <p> Emergency Notification' \
          ' Group Identifier xxx does not exist., where xxx is' \
          ' replaced by the emergency notification group' \
          ' identifier supplied in the request.  Note:<b></b> This' \
          ' error can be used also for the case where the' \
          ' emergency notification group ID exists, but not for' \
          ' this Iris account. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Attempt to add invalid emergency' \
          ' endpoint identifier </p> </td> <td width="451"' \
          ' valign="top"> <p> Emergency Endpoint Identifier being' \
          ' added does not exist.  Note:<b></b> This error can' \
          ' also be used for the case where the emergency endpoint' \
          ' ID exists, but not for this Iris account. </p> </td>' \
          ' </tr> <tr> <td valign="top"> <p> Attempt to remove' \
          ' invalid emergency endpoint identifier, for the case' \
          ' where the emergency endpoint does not exist for the' \
          ' specified Iris account </p> </td> <td width="451"' \
          ' valign="top"> <p>Warning:<b></b> Emergency Endpoint' \
          ' Identifier specified for removal does not exist. </p>' \
          ' </td> </tr> <tr> <td valign="top"> <p> Attempt to' \
          ' remove a valid emergency endpoint identifier that is' \
          ' associated with an emergency notification group other' \
          ' than the one specified in the request </p> </td> <td' \
          ' width="451" valign="top"> <p> Error:<b></b> Emergency' \
          ' Endpoint Identifier specified for removal is not' \
          ' associated with Emergency Notification Group xxx.,' \
          ' where xxx is replaced by the emergency notification' \
          ' group identifier. </p> </td> </tr> <tr> <td' \
          ' valign="top"> <p> Attempt to add an endpoint, but' \
          ' specified emergency endpoint is already associated' \
          ' with another emergency notification group             ' \
          '                   </p> </td> <td width="451"' \
          ' valign="top"> <p> The Emergency Endpoint with' \
          ' identifier xxx is already associated with Emergency' \
          ' Notification Group with identifier yyy., where xxx is' \
          ' replaced with the TN or AEUI supplied in the request,' \
          ' and yyy is replaced by the emergency notification' \
          ' group ID of the emergency notification group that the' \
          ' supplied endpoint ID is associated with. </p> </td>' \
          ' </tr> </tbody> </table>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body,
        'EmergencyNotificationEndpointOrderResponse',
        EmergencyNotificationGroupEndpointAssociationResponse
      )
      )
    end

    # This endpoint is used to fetch the status of an emergency notification
    # endpoint order, using the order-id assigned when the order was created.
    # <br>If the order is still being processed, the ProcessingStatus will be
    # PROCESSING.  If the order has completed successfully, the ProcessingStatus
    # will be COMPLETED.  Otherwise the ProcessingStatus will be FAILED.  If the
    # ProcessingStatus is FAILED, look for the ErrorList in the payload to see
    # reasons for the failure.URI parameters:<ul>  <li>  <b>accountId</b> - the
    # account id of the account to which the emergency notification endpoint
    # order belongs.  </li>  <li>  <b>orderId</b> - the order-id assigned to the
    # emergency notification endpoint order when it was created.  </li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [EmergencyNotificationGroupEndpointAssociationResponse] response from the API call
    def retrieve_group_association_order(account_id,
                                         order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationendpointorders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to view emergency notification endpoint' \
          ' orders, either due to Role/Permission or because the' \
          ' account is not configured for Emergency Notification' \
          ' Config. <br> <b>Error Description:</b> Access Denied' \
          ' </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p><b>Condition:</b> Specified' \
          ' emergency notification endpoint order id does not' \
          ' exist for this account <br> <b>Error Description:</b>' \
          ' The resource does not exist </p> <br>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body,
        'EmergencyNotificationEndpointOrderResponse',
        EmergencyNotificationGroupEndpointAssociationResponse
      )
      )
    end

    # This endpoint allows you to fetch the configuration of a current emergency
    # notification group by identifier.URI parameters:<ul>  <li> 
    # <b>accountId</b> - the account id of the account to which the emergency
    # notification recipient belongs.  </li>  <li>  <b>engId</b> - the emergency
    # notification group identifier assigned to the emergency notification group
    # when it was created.  </li></ul>Query parameters:            <table>      
    #              <tr>                      <th>Parameter Name</th>            
    #          <th>Example</th>                      <th>Default</th>           
    #           <th>Usage</th>                    </tr>                    <tr> 
    #                       <td valign="top">                            <p>    
    #                            IncludeEepTns                            </p>  
    #                      </td>                        <td  valign="top">      
    #                      <p>                                IncludeEepTns=true
    #                            </p>                        </td>              
    #          <td valign="top">                            <p>                 
    #               false                            </p>                       
    # </td>                        <td valign="top">                           
    # <p>                                  Set this optional parameter to true
    # if you wish to include a list                                  of all
    # Emergency Endpoint TNs associated with this Emergency Notification Group. 
    #                           </p>                        </td>               
    #     </tr>                    <tr>                        <td valign="top">
    #                            <p>                               
    # IncludeEepAeuis                            </p>                       
    # </td>                        <td  valign="top">                           
    # <p>                                IncludeEepAeuis=true                   
    #         </p>                        </td>                        <td
    # valign="top">                            <p>                              
    #  false                            </p>                        </td>       
    #                 <td  valign="top">                            <p>         
    #                       Set this optional parameter to true if you wish to
    # include a list                                of all Emergency Endpoint
    # AEUIs associated with this Emergency Notification Group.                  
    #          </p>                        </td>                    </tr>       
    #             <tr>                        <td valign="top">                 
    #           <p>                                StartWithEepTn               
    #             </p>                        </td>                        <td
    # valign="top">                            <p>                              
    #  StartWithEepTn=203208110                            </p>                 
    #       </td>                        <td valign="top">                      
    #      <p>                                No filter                         
    #   </p>                        </td>                        <td
    # valign="top">                            <p>                              
    #  This parameter, which may only be specified if the IncludeEepTns
    # parameter is set to true,                                indicates the
    # starting digits of the emergency endpoint TN that you wish to begin with
    # in the                                list of emergency endpoints
    # associated with the emergency notification group. At least 3 digits       
    #                         must be supplied, and up to 10 digits may be
    # included.                            </p>                        </td>    
    #                </tr>                    <tr>                        <td
    # valign="top">                            <p>                              
    #  EepTnSize                            </p>                        </td>   
    #                     <td valign="top">                            <p>      
    #                          EepTnSize=200                            </p>    
    #                    </td>                        <td valign="top">         
    #                   <p>                                20                   
    #         </p>                        </td>                        <td
    # valign="top">                            <p>                              
    #  This parameter, which may only be specified if the IncludeEepTns
    # parameter is set to true,                                 indicates the
    # maximum number of associated emergency endpoint TNs you wish to include
    # for                                 each emergency notification group that
    # is returned in the query results. The value may range from 1 to 5000      
    #                      </p>                        </td>                   
    # </tr>                    <tr>                        <td  valign="top">   
    #                         <p>                               
    # StartWithEepAeui                            </p>                       
    # </td>                        <td  valign="top">                           
    # <p>                                StartWithEepAeui=Frank                 
    #           </p>                        </td>                        <td 
    # valign="top">                            <p>                              
    #  No filter                            </p>                        </td>   
    #                     <td  valign="top">                            <p>     
    #                           This parameter, which may only be specified if
    # the IncludeEepAeuis parameter is set to true,                             
    #    indicates the starting characters of the emergency endpoint AEUI that
    # you wish to begin with                                  in the list of
    # emergency endpoints associated with the emergency notification group.     
    #                             At least 3 characters must be supplied, and up
    # to 50 characters may be included.                            </p>         
    #               </td>                    </tr>                    <tr>      
    #                  <td  valign="top">                            <p>        
    #                        EepAeuiSize                            </p>        
    #                </td>                        <td  valign="top">            
    #                <p>                                EepAeuiSize=50          
    #                  </p>                        </td>                       
    # <td  valign="top">                            <p>                         
    #       20                            </p>                        </td>     
    #                   <td  valign="top">                            <p>       
    #                         This parameter, which may only be specified if the
    # IncludeEepAeuis parameter is set to true,                               
    # indicates the maximum number of associated emergency endpoint AEUIs you
    # wish to include for                                each emergency
    # notification group that is returned in the query results. The value may
    # range from 1 to 5000.                            </p>                     
    #   </td>                    </tr>            </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] eng_id Required parameter: Example:
    # @param [String] include_eep_tns Optional parameter: Example:false
    # @param [String] include_eep_aeuis Optional parameter: Example:false
    # @param [String] start_with_eep_tn Optional parameter: Example:
    # @param [Integer] eep_tn_size Optional parameter: Example:20
    # @param [String] start_with_eep_aeui Optional parameter: Example:
    # @param [Integer] eep_aeui_size Optional parameter: Example:20
    # @return [Object] response from the API call
    def retrieve_emergency_notification_group(account_id,
                                              eng_id,
                                              include_eep_tns: 'false',
                                              include_eep_aeuis: 'false',
                                              start_with_eep_tn: nil,
                                              eep_tn_size: 20,
                                              start_with_eep_aeui: nil,
                                              eep_aeui_size: 20)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationgroups/{engId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'engId' => { 'value' => eng_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'IncludeEepTns' => include_eep_tns,
        'IncludeEepAeuis' => include_eep_aeuis,
        'StartWithEepTn' => start_with_eep_tn,
        'EepTnSize' => eep_tn_size,
        'StartWithEepAeui' => start_with_eep_aeui,
        'EepAeuiSize' => eep_aeui_size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b> User does not have' \
          ' permission to view emergency notification groups,' \
          ' either due to Role/Permission or because the account' \
          ' is not configured for Emergency Notification Config.' \
          ' <br> <b>Error Description:</b> Access Denied </p>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The resource does not exist <br> <p><b>Condition:</b> Specified' \
          ' emergency notification group id does not exist for' \
          ' this account <br> <b>Error Description:</b> The' \
          ' resource does not exist </p> <br>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # <p> Fetch emergency notification groups that are currently configured on
    # the account.  Use the provided query parameters to filter the results.
    # <br>URI Parameters: <b>accountId</b> - the account id of the account to
    # which the emergency notification group belongs </p><p><b>Query
    # parameters:</b><br>The GET operation has no request payload, but the
    # accountId must be specified in the URI parameter.Results are returned by
    # default in the order of newest to oldest modification date of the
    # Emergency Notification Group.  This default order is reversed from oldest
    # to newest when the ModifiedAfterDate query parameter is included in the
    # query.Query parameters act as filters on the data. If more than one query
    # parameter is provided, the results will be the intersection of the results
    # from each query parameter. In other words, the query parameters are
    # logically ANDed.Query parameters are appended to the end of the endpoint,
    # separated by a '?' and in the format parameter=value.  If you wish to
    # specify more than one query parameter, separate them using an '&'
    # character.  The order of query parameters does not matter.  For example:
    # <br>GET
    # /accounts/{accountId}/emergencyNotificationGroups?EngDescription=Bldg
    # 200&EnrEmailAddress=gateSecurity@mycompany.com <br>...will return all
    # Emergency Notification Groups having a description field including the
    # string "Bldg 200", and having an emergency notification recipient with the
    # specified email address. <br>The following query parameters are supported.
    #  All query parameters are optional.</p><table>        <tr>         
    # <th>Parameter Name</th>          <th>Example</th>         
    # <th>Default</th>          <th>Usage</th>        </tr>        <tr>         
    #   <td valign="top">                <p>                    EngDescription  
    #              </p>            </td>            <td  valign="top">          
    #      <p>                    EngDescription=Building 4                </p> 
    #           </td>            <td valign="top">                <p>           
    #         No filter                </p>            </td>            <td
    # valign="top">                <p>                  A substring that will
    # exist in the Description for all returned Emergency Notification Groups.  
    #              </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    EnrId               
    # </p>            </td>            <td  valign="top">                <p>    
    #                EnrId=                   
    # 63865500-0904-46b1-9b4f-7bd237a26363                </p>            </td> 
    #           <td valign="top">                <p>                    No
    # filter                </p>            </td>            <td  valign="top"> 
    #               <p>                    The Identifier of an Emergency
    # Notification Recipient that is associated with the Emergency Notification
    # Groups returned.                </p>            </td>        </tr>       
    # <tr>            <td valign="top">                <p>                   
    # EnrDescription                </p>            </td>            <td
    # valign="top">                <p>                    EnrDescription=front
    # desk                </p>            </td>            <td valign="top">    
    #            <p>                    No filter                </p>           
    # </td>            <td valign="top">                <p>                    A
    # substring that will exist in all Emergency Notification Recipient
    # Descriptions associated with the Emergency Notification Groups returned.  
    #              </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    EnrNotificationType   
    #             </p>            </td>            <td valign="top">            
    #    <p>                    EnrNotificationType=TTS                </p>     
    #       </td>            <td valign="top">                <p>               
    #     No filter                </p>            </td>            <td
    # valign="top">                <p>                    The type of
    # notification (EMAIL, SMS, TTS, or CALLBACK) specified for Emergency
    # Notification Recipients associated with the Emergency Notification Groups
    # returned.                </p>            </td>        </tr>        <tr>   
    #         <td  valign="top">                <p>                    EnrSmsTn 
    #               </p>            </td>            <td  valign="top">         
    #       <p>                    EnrSmsTn=3037458827                </p>      
    #      </td>            <td  valign="top">                <p>               
    #     No filter                </p>            </td>            <td 
    # valign="top">                <p>                    The Short Message
    # Service telephone number in all SMS type Emergency Notification Recipients
    # associated with the Emergency Notification Groups returned.               
    # </p>            </td>        </tr>        <tr>            <td 
    # valign="top">                <p>                    EnrTtsTn              
    #  </p>            </td>            <td  valign="top">                <p>   
    #                 EnrTtsTn=402288875                </p>            </td>   
    #         <td  valign="top">                <p>                    No filter
    #                </p>            </td>            <td  valign="top">        
    #        <p>                    The Text To Speech telephone number in all
    # TTS type Emergency Notification Recipients associated with the Emergency
    # Notification Groups returned.                </p>            </td>       
    # </tr>        <tr>            <td  valign="top">                <p>        
    #            EnrEmailAddress                </p>            </td>           
    # <td  valign="top">                <p>                   
    # EnrEmailAddress=fred@aol.com                </p>            </td>         
    #   <td  valign="top">                <p>                    No filter      
    #          </p>            </td>            <td  valign="top">              
    #  <p>                    The email address in all EMAIL type Emergency
    # Notification Recipients associated with the Emergency Notification Groups
    # returned.                </p>            </td>        </tr>        <tr>   
    #         <td  valign="top">                <p>                   
    # EnrCallbackUrl                </p>            </td>            <td 
    # valign="top">                <p>                    EnrCallbackUrl=       
    #             https://e911.callback.mycompany.com                </p>       
    #     </td>            <td  valign="top">                <p>                
    #    No filter                </p>            </td>            <td 
    # valign="top">                <p>                    The callback URL in
    # all CALLBACK type Emergency Notification Recipients associated with the
    # Emergency Notification Groups returned.                </p>           
    # </td>        </tr>        <tr>            <td  valign="top">              
    #  <p>                    EnrCallbackUsername                </p>           
    # </td>            <td  valign="top">                <p>                   
    # EnrCallbackUsername=ljames                </p>            </td>           
    # <td  valign="top">                <p>                    No filter        
    #        </p>            </td>            <td  valign="top">               
    # <p>                    The callback username in all CALLBACK type
    # Emergency Notification Recipients associated with the Emergency
    # Notification Groups returned.                </p>            </td>       
    # </tr>        <tr>            <td  valign="top">                <p>        
    #            EnrDetails                </p>            </td>            <td 
    # valign="top">                <p>                    EnrDetails=true       
    #         </p>            </td>            <td  valign="top">               
    # <p>                    false                </p>            </td>         
    #   <td  valign="top">                <p>                    If set to true,
    # the results will include full details about each Emergency Notification
    # Recipient associated with the Emergency Notification Groups satisfying the
    # query.  Otherwise, only Emergency Notification Recipient identifiers are
    # included.                </p>            </td>        </tr>        <tr>   
    #         <td  valign="top">                <p>                    Page     
    #           </p>            </td>            <td  valign="top">             
    #   <p>                    Page=2020-04-07T00:00:00Z                </p>    
    #        </td>            <td  valign="top">                <p>             
    #       Now                </p>            </td>            <td 
    # valign="top">                <p>                  This represents the
    # position in the data set from which you want your output to begin.  If
    # this parameter is omitted, results will include Emergency Notification
    # Groups last modified on or before the current date and time.  If a date
    # and time is provided, results will include Emergency Notification Groups
    # last modified on or before that date and time.  Date/time format is
    # YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z indicate UTC time, or
    # YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm" represents the local time
    # offset, plus or minus, from UTC time.                </p>            </td>
    #        </tr>        <tr>            <td  valign="top">                <p> 
    #                   Size                </p>            </td>            <td
    #  valign="top">                <p>                    Size=10              
    #  </p>            </td>            <td  valign="top">                <p>   
    #                 100                </p>            </td>            <td 
    # valign="top">                <p>                  The maximum number of
    # Emergency Notification Group results to include in the response payload. 
    # This value may be between 1 and 500.                </p>            </td> 
    #       </tr></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:100
    # @param [String] eng_description Optional parameter: Example:
    # @param [String] enr_id Optional parameter: Example:
    # @param [String] enr_description Optional parameter: Example:
    # @param [EnrNotificationTypeEnum] enr_notification_type Optional parameter:
    # Example:
    # @param [String] enr_sms_tn Optional parameter: Example:
    # @param [String] enr_tts_tn Optional parameter: Example:
    # @param [String] enr_email_address Optional parameter: Example:
    # @param [String] enr_callback_url Optional parameter: Example:
    # @param [String] enr_callback_username Optional parameter: Example:
    # @param [String] enr_details Optional parameter: Example:false
    # @return [Object] response from the API call
    def retrieve_emergency_notification_groups(account_id,
                                               page: nil,
                                               size: 100,
                                               eng_description: nil,
                                               enr_id: nil,
                                               enr_description: nil,
                                               enr_notification_type: nil,
                                               enr_sms_tn: nil,
                                               enr_tts_tn: nil,
                                               enr_email_address: nil,
                                               enr_callback_url: nil,
                                               enr_callback_username: nil,
                                               enr_details: 'false')
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/emergencynotificationgroups'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'EngDescription' => eng_description,
        'EnrId' => enr_id,
        'EnrDescription' => enr_description,
        'EnrNotificationType' => enr_notification_type,
        'EnrSmsTn' => enr_sms_tn,
        'EnrTtsTn' => enr_tts_tn,
        'EnrEmailAddress' => enr_email_address,
        'EnrCallbackUrl' => enr_callback_url,
        'EnrCallbackUsername' => enr_callback_username,
        'EnrDetails' => enr_details
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request <br> <p><b>Condition:</b> Unrecognized query' \
          ' parameter <br> <b>Error Description:</b>Query' \
          ' parameter xxx is not recognized. </p> <br>' \
          ' <p><b>Condition:</b>Unsupported value for query' \
          ' parameter <br> <b>Error Description:</b>Invalid value' \
          ' xxx for query parameter yyy. Supported values are aaa,' \
          ' bbb, etc. </p>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access Denied <br> <p> <b>Condition:</b>User does not have' \
          ' permission to view emergency notification orders,' \
          ' either due to Role/Permission or because the account' \
          ' is not configured for Emergency Notification' \
          ' Config.<br> <b>Error Description:</b>Access Denied </p>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Create E911 order to associate the address with the telephone number.The
    # key data elements in the submission are as follows. <table
    # style="text-align: left; width: 80%;"  border="1" cellpadding="2"
    # cellspacing="2">  <tbody>    <tr>      <td>TelephoneNumbers</td>     
    # <td>A list of telephone numbers you need link to the street address.</td> 
    #   </tr>    <tr>      <td>CallerName</td>      <td>CallerName that will be
    # linked to TNs. This field is required in the case of a new address
    # assignment.</td>    </tr>    <tr>      <td>Address</td>      <td>This
    # field is required in the case of a new address assignment.  Inner fields:
    # HousePrefix, HouseNumber, HouseSuffix, PreDirectional, StreetName,
    # StreetSuffix, PostDirectional, AddressLine2, City, StateCode, Zip,
    # PlusFour.  Streetname, City, and State are required.  House Number is
    # currently required, although this enforcement may be relaxed in the
    # future. Depending on the type of E911 service, the Location ID may be
    # updated by the Bandwidth Dashboard API</td>    </tr>    <tr>     
    # <td>DeleteTNSpecificE911Address</td>      <td>Can be true or false. If
    # value is true then Address and CallerName should not be specified.</td>   
    # </tr>    <tr>      <td>AlternateEndUserIdentifiers</td>      <td>A list of
    # AEUIs acts as a replacement for the list of telephone numbers. It replaces
    # the TelephoneNumbers and AdditionalAddress payload element. If ACID exists
    # in external system it will be updated with given values.</td>    </tr>   
    # <tr>      <td>AdditionalAddresses</td>      <td>A list of Address
    # sections. This address information for all potential endpoints which will
    # be provisioned to the Bandwidth 911 system. At call time, the customer
    # will submit this address information within the SIP header and, if a match
    # is determined, the call will be routed to the PSAP nearest to that
    # address. Otherwise, the call will be routed to an ECC. These Address
    # sections will be the same in format to the Address section in the
    # top-level of the E911Order payload. It replaces the TelephoneNumbers and
    # AlternateEndUserIdentifiers payload element. </td>    </tr>    <tr>     
    # <td>CustomerOrderId</td>      <td>The Customer Order ID is an ID assigned
    # by the account owner to provide a reference number for the Order. The
    # element is optional. Only alphanumeric values, dashes and spaces are
    # allowed. Max length is 40 characters.</td>    </tr> 
    # </tbody></table><br/>Examples of POST requests:<table>  <tbody>    <tr>   
    #   <th width="20%">Description</th>      <th width="80%">Example</th>   
    # </tr>    <tr>      <td>        <strong>CONVENTIONAL E911</strong><br>     
    #   TN/Address-provisioning order.<br>        <b>TelephoneNumbers</b>,
    # <b>TelephoneNumber</b>, and <b>Address</b> are required.      </td>     
    # <td>        <!-- We have to leave this indent as-is because the <pre> tag
    # is stupid and uses non-relative whitespacing.-->       
    # <pre>&lt;E911Order&gt;  &lt;TelephoneNumbers&gt;   
    # &lt;TelephoneNumber&gt;9706542332&lt;/TelephoneNumber&gt;   
    # &lt;TelephoneNumber&gt;9706542333&lt;/TelephoneNumber&gt; 
    # &lt;/TelephoneNumbers&gt; 
    # &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;  &lt;Address&gt;  
    #  &lt;HouseNumber&gt;915&lt;/HouseNumber&gt;    &lt;HouseSuffix/&gt;   
    # &lt;PreDirectional/&gt;    &lt;StreetName&gt;Elm&lt;/StreetName&gt;   
    # &lt;StreetSuffix&gt;Ave&lt;/StreetSuffix&gt;    &lt;PostDirectional/&gt;  
    #  &lt;AddressLine2/&gt;    &lt;City&gt;Carpinteria&lt;/City&gt;   
    # &lt;StateCode&gt;CA&lt;/StateCode&gt;    &lt;Zip&gt;93013&lt;/Zip&gt;   
    # &lt;PlusFour/&gt;    &lt;County/&gt;    &lt;Country&gt;United
    # States&lt;/Country&gt;  &lt;/Address&gt;&lt;/E911Order&gt;        </pre>  
    #    </td>    </tr>    <tr>      <td>        <strong>CONVENTIONAL
    # E911</strong><br>        TN/address-deletion order.<br>       
    # <b>TelephoneNumbers</b> and <b>TelephoneNumber</b> are required.<br>      
    #  <b>DeleteTNSpecificE911Address</b> is required and must be set to 'true'.
    #      </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;TelephoneNumbers&gt;   
    # &lt;TelephoneNumber&gt;9706542332&lt;/TelephoneNumber&gt;   
    # &lt;TelephoneNumber&gt;9706542333&lt;/TelephoneNumber&gt; 
    # &lt;/TelephoneNumbers&gt; 
    # &lt;DeleteTNSpecificE911Address&gt;true&lt;/DeleteTNSpecificE911Address&gt
    # ;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>      <td>   
    #     <strong>PIDF-LO</strong><br>        PIDF-LO AEUI endpoint-provisioning
    # order with additional address provisioning and without pre-defined
    # location id.<br>        <b>AlternateEndUserIdentifiers</b>,
    # <b>AlternateEndUserIdentifier</b>, <b>Address</b>, and <b>Identifier</b>
    # are required.<br>        <b>Identifier</b> can only contain alphanumeric
    # characters and must be between 1 and 30 characters.<br>       
    # <b>PIDFLOEnabled</b> is required and must be 'true'.<br>        Default
    # value of <b>PreferredLanguage</b> is 'en'.      </td>      <td>       
    # <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;Address&gt;    &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;   
    # &lt;StreetName&gt;MAIN CAMPUS&lt;/StreetName&gt;   
    # &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;   
    # &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt; 
    #   &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;/PlusFour&gt;   
    # &lt;Country&gt;United States&lt;/Country&gt;   
    # &lt;AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;     
    # &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;blep123&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;     
    # &lt;PreferredLanguage&gt;en&lt;/PreferredLanguage&gt;   
    # &lt;/AlternateEndUserIdentifier&gt; 
    # &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>     
    # </td>    </tr>    <tr>      <td>        <strong>PIDF-LO</strong><br>      
    #  PIDF-LO AEUI endpoint-provisioning order with additional address
    # provisioning and with pre-defined location id.<br>       
    # <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>,
    # <b>Address</b>, and <b>Identifier</b> are required.<br>       
    # <b>Identifier</b> can only contain alphanumeric characters and must be
    # between 1 and 30 characters.<br>        <b>PIDFLOEnabled</b> is required
    # and must be 'true'.<br>        Default value of <b>PreferredLanguage</b>
    # is 'en'.      </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;Address&gt;   
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;   
    # &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;StreetName&gt;MAIN
    # CAMPUS&lt;/StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;  
    #  &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt;
    #    &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;/PlusFour&gt;  
    #  &lt;Country&gt;United States&lt;/Country&gt;   
    # &lt;AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;     
    # &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;blep123&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;     
    # &lt;PreferredLanguage&gt;en&lt;/PreferredLanguage&gt;   
    # &lt;/AlternateEndUserIdentifier&gt; 
    # &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>     
    # </td>    </tr>    <tr>      <td>        <strong>PIDF-LO</strong><br>      
    #  PIDF-LO AEUI endpoint-provisioning order with provisioned location
    # id.<br>        <b>AlternateEndUserIdentifiers</b>,
    # <b>AlternateEndUserIdentifier</b>, <b>LocationId</b>, and
    # <b>Identifier</b> are required.<br>        <b>Identifier</b> can only
    # contain alphanumeric characters and must be between 1 and 30
    # characters.<br>        <b>PIDFLOEnabled</b> is required and must be
    # 'true'.<br>        Default value of <b>PreferredLanguage</b> is 'en'.     
    # </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;     
    # &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;blep123&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;     
    # &lt;PreferredLanguage&gt;en&lt;/PreferredLanguage&gt;   
    # &lt;/AlternateEndUserIdentifier&gt; 
    # &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>     
    # </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong> and
    # <strong>SIMPLE AEUI</strong><br>        Mixed PIDF-LO AEUI and Non-PIDF-LO
    # AEUI endpoint-provisioning order.<br>       
    # <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>,
    # <b>Address</b>, and <b>Identifier</b> are required.<br>        Default
    # value of <b>PreferredLanguage</b> is 'en'.<br>       
    # <strong>Non-PIDF-LO:</strong><br>        <b>CallbackNumber</b> is
    # required.<br>        <b>Identifier</b> can only contain alphanumeric
    # characters and must be between 6 and 30 characters.<br>       
    # <strong>PIDF-LO:</strong><br>        <b>PIDFLOEnabled</b> is required and
    # must be 'true'.<br>        <b>Identifier</b> can only contain alphanumeric
    # characters and must be between 1 and 30 characters.      </td>      <td>  
    #      <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;  &lt;Address&gt;  
    #  &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;   
    # &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;StreetName&gt;MAIN
    # CAMPUS&lt;/StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;  
    #  &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt;
    #    &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;/PlusFour&gt;  
    #  &lt;Country&gt;United States&lt;/Country&gt;   
    # &lt;AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;     
    # &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;blep123&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;     
    # &lt;PreferredLanguage&gt;en&lt;/PreferredLanguage&gt;   
    # &lt;/AlternateEndUserIdentifier&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallbackNumber&gt;9706542334&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;blepblop&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;false&lt;/PIDFLOEnabled&gt;   
    # &lt;/AlternateEndUserIdentifier&gt; 
    # &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>     
    # </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong> and
    # <strong>SIMPLE AEUI</strong><br>        PIDF-LO and Non-PIDF-LO
    # endpoint-deletion order.<br>        <b>AlternateEndUserIdentifiers</b>,
    # <b>AlternateEndUserIdentifier</b>, and <b>Identifier</b> are required.<br>
    #        <b>DeleteTNSpecificE911Address</b> is required and must be
    # 'true'.<br>        <strong>Non-PIDF-LO:</strong><br>       
    # <b>CallbackNumber</b> is required.<br>        <b>Identifier</b> can only
    # contain alphanumeric characters 6 and 30 characters.<br>       
    # <strong>PIDF-LO:</strong><br>        <b>PIDFLOEnabled</b> is required and
    # must be 'true'.<br>        <b>Identifier</b> can only contain alphanumeric
    # characters and must be between 1 and 30 characters.      </td>      <td>  
    #      <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;Identifier&gt;identifier&lt;/Identifier&gt;   
    # &lt;/AlternateEndUserIdentifier&gt;  &lt;/AlternateEndUserIdentifiers&gt; 
    # &lt;DeleteTNSpecificE911Address&gt;true&lt;/DeleteTNSpecificE911Address&gt
    # ;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>     
    # <td><strong>PIDF-LO</strong><br>        PIDF-LO address-provisioning
    # order.<br>        <b>AdditionalAddresses</b> and <b>Address</b> are
    # required.      </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;AdditionalAddresses&gt;    &lt;Address&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;     
    # &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;      &lt;StreetName&gt;MAIN
    # CAMPUS&lt;/StreetName&gt;      &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;
    #      &lt;City&gt;RALEIGH&lt;/City&gt;     
    # &lt;StateCode&gt;NC&lt;/StateCode&gt;      &lt;Zip&gt;27606&lt;/Zip&gt;   
    #   &lt;PlusFour&gt;5244&lt;/PlusFour&gt;      &lt;Country&gt;United
    # States&lt;/Country&gt;      &lt;AddressType&gt;E911&lt;/AddressType&gt;   
    # &lt;/Address&gt;    &lt;Address&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;     
    # &lt;HouseNumber&gt;645&lt;/HouseNumber&gt;     
    # &lt;PreDirectional&gt;E&lt;/PreDirectional&gt;     
    # &lt;StreetName&gt;MANCHESTER&lt;/StreetName&gt;     
    # &lt;StreetSuffix&gt;AVE&lt;/StreetSuffix&gt;      &lt;City&gt;LOS
    # ANGELES&lt;/City&gt;      &lt;StateCode&gt;United States&lt;/StateCode&gt;
    #      &lt;Zip&gt;90001&lt;/Zip&gt;      &lt;Country&gt;United
    # States&lt;/Country&gt;    &lt;/Address&gt; 
    # &lt;/AdditionalAddresses&gt;&lt;/E911Order&gt;        </pre>      </td>   
    # </tr>    <tr>      <td><strong>PIDF-LO</strong> <br>        PIDF-LO
    # address-editing order.<br>        <b>Address</b> and <b>LocationId</b> are
    # required.<br>        Allows a user to update all address fields except
    # <b>PlusFour</b> and <b>Country</b>.      </td>      <td>       
    # <pre>&lt;E911Order&gt;  &lt;AdditionalAddresses&gt;    &lt;Address&gt;    
    #  &lt;HouseNumber&gt;645&lt;/HouseNumber&gt;     
    # &lt;PreDirectional&gt;E&lt;/PreDirectional&gt;     
    # &lt;HouseSuffix&gt;1/2&lt;/HouseSuffix&gt;     
    # &lt;PostDirectional&gt;S&lt;/PostDirectional&gt;     
    # &lt;StreetName&gt;Manchester&lt;/StreetName&gt;     
    # &lt;StreetSuffix&gt;AVE&lt;/StreetSuffix&gt;      &lt;AddressLine2&gt;test
    # address line 2&lt;/AddressLine2&gt;      &lt;City&gt;Los
    # Angeles&lt;/City&gt;      &lt;StateCode&gt;CA&lt;/StateCode&gt;     
    # &lt;Zip&gt;90001&lt;/Zip&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;   
    # &lt;/Address&gt;  &lt;/AdditionalAddresses&gt;&lt;/E911Order&gt;         
    # </pre>      </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong><br>  
    #      PIDF-LO address-deletion order.<br>       
    # <b>AdditionalAddresses</b>, <b>Address</b>, and <b>LocationId</b> are
    # required.<br>        <b>DeleteTNSpecificE911Address</b> is required and
    # must be 'true'.      </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;AdditionalAddresses&gt;    &lt;Address&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString1&lt;/LocationId&gt;   
    # &lt;/Address&gt;    &lt;Address&gt;     
    # &lt;LocationId&gt;Some32CharacterOrLessString1&lt;/LocationId&gt;   
    # &lt;/Address&gt;  &lt;/AdditionalAddresses&gt; 
    # &lt;DeleteTNSpecificE911Address&gt;true&lt;/DeleteTNSpecificE911Address&gt
    # ;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>     
    # <td><strong>SIMPLE AEUI</strong><br>        Non-PIDF-LO
    # endpoint-provisioning order.<br>       
    # <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>,
    # <b>Address</b>, <b>CallbackNumber</b>, and <b>Identifier</b> are
    # required<br>        <b>Identifier</b> can only contain alphanumeric
    # characters, must contain at least one letter, and must be between 6 and 30
    # characters.<br>      </td>      <td>        <pre>&lt;E911Order&gt; 
    # &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt; 
    # &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;  &lt;Address&gt;  
    #  &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;   
    # &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;StreetName&gt;MAIN
    # CAMPUS&lt;/StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;  
    #  &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt;
    #    &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;/PlusFour&gt;  
    #  &lt;Country&gt;United States&lt;/Country&gt;   
    # &lt;AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt; 
    # &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt; 
    #     &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;     
    # &lt;Identifier&gt;abc123&lt;/Identifier&gt;     
    # &lt;PIDFLOEnabled&gt;false&lt;/PIDFLOEnabled&gt;   
    # &lt;/AlternateEndUserIdentifier&gt; 
    # &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>     
    # </td>    </tr>  </tbody></table><br/><b>Error Codes.</b><br/>For all
    # possible error codes that can be returned in an E911 order, refer to
    # section 6.4 of the Error Code Reference.
    # @param [Integer] account_id Required parameter: Example:
    # @param [E911OrderPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_e911_order(account_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/e911s'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('E911Order', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request<br>A 400 response indicates that the order could not' \
          ' be created.<br>Error text and an error code will be' \
          ' provided in the ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve a list of the externalTns orders that are associated with the
    # account. <p>A maximum of 1,000 orders can be retrieved per request. If no
    # date range or specific query parameter (marked by <b
    # class="required">*</b> below) is provided, the order results will be
    # limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [List of String] status Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] last_modified_by Optional parameter: Example:
    # @param [List of String] activity_state Optional parameter: Example:
    # @param [List of String] bandwidth_prime Optional parameter: Example:
    # @param [String] last_modified_after Optional parameter: Example:
    # @param [String] created_date_from Optional parameter: Example:
    # @param [String] created_date_to Optional parameter: Example:
    # @param [Boolean] order_details Optional parameter: Example:false
    # @param [String] order_id_fragment Optional parameter: Example:
    # @param [String] action Optional parameter: Example:
    # @param [String] type Optional parameter: Example:
    # @return [Object] response from the API call
    def get_orders_2(account_id,
                     status: nil,
                     modified_date_from: nil,
                     modified_date_to: nil,
                     tn: nil,
                     customer_order_id: nil,
                     last_modified_by: nil,
                     activity_state: nil,
                     bandwidth_prime: nil,
                     last_modified_after: nil,
                     created_date_from: nil,
                     created_date_to: nil,
                     order_details: false,
                     order_id_fragment: nil,
                     action: nil,
                     type: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/externalTns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'status' => status,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'tn' => tn,
        'customerOrderId' => customer_order_id,
        'lastModifiedBy' => last_modified_by,
        'activityState' => activity_state,
        'bandwidthPrime' => bandwidth_prime,
        'lastModifiedAfter' => last_modified_after,
        'createdDateFrom' => created_date_from,
        'createdDateTo' => created_date_to,
        'orderDetails' => order_details,
        'orderIdFragment' => order_id_fragment,
        'action' => action,
        'type' => type
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'No externalTns orders can be found that match the query parameters.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ExternalTnsOrderReportResponse', String)
      )
    end

    # Create a externalTns order to add or remove telephone numbers provided by
    # the customer from the Bandwidth network.Note: the attempt to import a
    # telephone number that is already present in the account will *not* create
    # an error, but will reset all of the  attributes of that telephone number
    # in the Dashboard system as if the telephone number was being imported for
    # the first timeThe key data elements in the submission are - <table
    # style="text-align: left; width: 80%;" border="1" cellpadding="2"
    # cellspacing="2">  <tbody>    <tr>      <td>CustomerOrderId</td>     
    # <td>An order ID created by the customer for their tracking purposes. Only
    # alphanumeric values, dashes and spaces are allowed. Max length is 40
    # characters.</td>    </tr>    <tr>      <td>SiteId</td>      <td>(Required)
    # The ID of the Site that the Telephone Numbers are to be provisioned
    # to.</td>    </tr>    <tr>      <td>SipPeerId</td>      <td>(Optional) The
    # ID of the SIP Peer that the Telephone Numbers are to be provisioned
    # to.</td>    </tr>    <tr>      <td>Action</td>      <td>(Required)
    # Indentify the action on external TNs. Allowed values... IMPORT or
    # REMOVE.</td>    </tr>    <tr>      <td>LoaType</td>      <td>(Optional)
    # Indentify the LoaType on external TNs. Allowed values... CARRIER or 
    # SUBSCRIBER. Default value is CARRIER</td>    </tr>  </tbody></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [ExternalTnsOrderPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_order_1(account_id,
                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/externalTns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ExternalTnsOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request <br> A 400 response Indicates that the order could' \
          ' not be created.Error text and an error code will be' \
          ' provided in the ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve information about a TelephoneNumbersAssignment order with
    # specified ID.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order(account_id,
                  order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/numbersAssignment/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(
        _response.raw_body,
        'TelephoneNumbersAssignmentOrderReportResponse', String
      )
      )
    end

    # Request a collection of BDRs be aggregated and ZIPped ready for
    # distribution.  The payload for the POST declares the date range for the
    # request.
    # @param [Integer] account_id Required parameter: Example:
    # @param [BdrArchiveCreationDescriptor] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_bdr(account_id,
                   body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bdrs'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Bdr', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A 400 response indicates that there was an error in processing' \
          ' the payload, perhaps something like incorrectly' \
          ' formatted or chosen dates. ',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'BdrResponse', String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] bdr_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_bdr_archive_file(account_id,
                             bdr_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bdrs/{bdrId}/file'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'bdrId' => { 'value' => bdr_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'BdrFileResponse',
                                   String)
      )
    end

    # A GET on the BDR ID will return a "still processing" indication if the
    # file creation has not completed, or will redirect to the file to be
    # downloaded.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] bdr_id Required parameter: Example:
    # @return [BdrArchiveRetrievalResponse] response from the API call
    def get_bdr(account_id,
                bdr_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bdrs/{bdrId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'bdrId' => { 'value' => bdr_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 indicates that the BDR id is malformed. ',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'A 404 indicates that the BDR id cannot be found. ',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'BdrRetrievalResponse',
                                   BdrArchiveRetrievalResponse)
      )
    end

    # Retrieve billing report instances within the account scope and billing
    # type.The valid Billing Types
    # are...<ul><li>BDR</li><li>MDR</li><li>INVOICE</li><li>STMTBDR</li><li>DIDS
    # NAP</li><li>DIDSNAP_MSG</li><li>RECORDINGBDR</li><li>RECORDINGSTMTBDR</li>
    # <li>TRANSCRIPTIONBDR</li><li>TRANSCRIPTIONSTMTBDR</li><li>CNAMBDR</li><li>
    # CNAMSTMTBDR</li><li>CONFBDR</li><li>CONFSTMTBDR</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] kind Optional parameter: Example:
    # @return [BillingReportsRetrievalResponse] response from the API call
    def retrieve_reports(account_id,
                         kind: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/billingreports'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'kind' => kind
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 response indicates that report type is incorrect.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'BillingReportsRetrievalResponse',
                                   BillingReportsRetrievalResponse)
      )
    end

    # The payload for the POST declares the date range and type for the desired
    # reports. The valid Types are... <ul> <li>BDR - Billing Detail Records -
    # per call information</li> <li>MDR - Message Detail Records - per messagin
    # information</li> <li>INVOICE - A copy of the invoice file or files for the
    # specified date range</li> <li>STMTBDR - BDR records that are aligned with
    # the invoice</li> <li>DIDSNAP - a list of telephone numbers aligned as
    # closely as we can with the billing window</li> <li>DIDSNAP_MSG - a list of
    # telephone numbers with active messaging</li> </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [BillingReportCreationPayload] body Optional parameter: Example:
    # @return [BillingReportCreationResponse] response from the API call
    def create_report(account_id,
                      body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/billingreports'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('BillingReport', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A 400 response indicates that there was an error in processing' \
          ' the payload, perhaps something like incorrectly' \
          ' formatted or chosen dates. ',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'BillingReportCreationResponse',
                                   BillingReportCreationResponse)
      )
    end

    # A GET on the /file resource subtending a report ID will cause the download
    # of the file.  Executing this resource path within a browser will cause the
    # download of the file.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] archive_id Required parameter: Example:
    # @return [BillingReportArchiveRetrievalResponse] response from the API call
    def retrieve_report_archive(account_id,
                                archive_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/billingreports/{archiveId}/file'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'archiveId' => { 'value' => archive_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 indicates that the report ID is malformed.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'A 404 indicates that the requested report cannot be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'BillingReportArchiveRetrievalResponse',
                                   BillingReportArchiveRetrievalResponse)
      )
    end

    # Get Billing Report
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] archive_id Required parameter: Example:
    # @return [BillingReportRetrievalResponse] response from the API call
    def retrieve_report(account_id,
                        archive_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/billingreports/{archiveId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'archiveId' => { 'value' => archive_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 indicates that the report ID is malformed.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'A 404 indicates that the requested report cannot be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'BillingReportRetrievalResponse',
                                   BillingReportRetrievalResponse)
      )
    end

    # Retrieve the history information associated with a named DLDA order.  This
    # indicates the various states that the order has passed through, as well as
    # the current state of the order as the last entry.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_dlda_order_history(account_id,
                               order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/dldas/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'DldaOrderReportResponse', String)
      )
    end

    # Retrieve information about a externalTns order with specified ID.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_2(account_id,
                    order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/externalTns/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ExternalTnsOrderReportResponse', String)
      )
    end

    # Retrieve the history information associated with an order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_history_1(account_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/externalTns/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ExternalTnsOrderReportResponse', String)
      )
    end

    # Retrieve information about a importTnOrder with specified ID.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_4(account_id,
                    order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importtnorders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ImportTnOrdersReportResponse', String)
      )
    end

    # Retrieves the importtnorders requests for the given account ID. <p>A
    # maximum of 1,000 orders can be retrieved per request. If no date range or
    # specific query parameter (marked by <b class="required">*</b> below) is
    # provided, the order results will be limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] invert_account_id_search Optional parameter: Example:
    # @param [Integer] site_id Optional parameter: Example:
    # @param [Integer] sippeer_id Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] last_modified_by Optional parameter: Example:
    # @param [String] order_id_fragment Optional parameter: Example:
    # @param [List of String] activity_state Optional parameter: Example:
    # @param [List of String] bandwidth_prime Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] last_modified_after Optional parameter: Example:
    # @param [String] created_date_from Optional parameter: Example:
    # @param [String] created_date_to Optional parameter: Example:
    # @param [List of String] include_in_response Optional parameter: Example:
    # @param [Boolean] order_details Optional parameter: Example:false
    # @param [String] status Optional parameter: Example:
    # @return [Object] response from the API call
    def get_orders_4(account_id,
                     invert_account_id_search: nil,
                     site_id: nil,
                     sippeer_id: nil,
                     page: nil,
                     size: nil,
                     tn: nil,
                     customer_order_id: nil,
                     last_modified_by: nil,
                     order_id_fragment: nil,
                     activity_state: nil,
                     bandwidth_prime: nil,
                     modified_date_from: nil,
                     modified_date_to: nil,
                     last_modified_after: nil,
                     created_date_from: nil,
                     created_date_to: nil,
                     include_in_response: nil,
                     order_details: false,
                     status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importtnorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'invertAccountIdSearch' => invert_account_id_search,
        'siteId' => site_id,
        'sippeerId' => sippeer_id,
        'page' => page,
        'size' => size,
        'tn' => tn,
        'customerOrderId' => customer_order_id,
        'lastModifiedBy' => last_modified_by,
        'orderIdFragment' => order_id_fragment,
        'activityState' => activity_state,
        'bandwidthPrime' => bandwidth_prime,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'lastModifiedAfter' => last_modified_after,
        'createdDateFrom' => created_date_from,
        'createdDateTo' => created_date_to,
        'includeInResponse' => include_in_response,
        'orderDetails' => order_details,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ImportTnOrdersReportResponse', String)
      )
    end

    # Creates an importTnOrders request to add numbers under the given site ID
    # and sippeer ID as specified in the body.A successfully submitted order
    # will have a status of "RECEIVED". A successfully completed order will have
    # a status of "COMPLETE" if all of the telephone numbers were successfully
    # imported and  "PARTIAL" if some of the telephone numbers were imported. A
    # failed order with will have a staus of "FAILED" and no telephone numbers
    # would have been imported.The elements supplied in the payloads are
    # described in the following table:<table border="1" cellspacing="0"
    # cellpadding="0" width="624">    <tbody>        <tr>            <td
    # valign="top">                <p>                   
    # <strong>Parameter</strong>                </p>            </td>           
    # <td valign="top">                <p>                   
    # <strong>Required</strong>                </p>            </td>           
    # <td width="351" valign="top">                <p>                   
    # <strong>Description</strong>                </p>            </td>       
    # </tr>        <tr>            <td valign="top">                <p>         
    #           accountId (URL Parameter)                </p>            </td>  
    #          <td valign="top">                <p align="center">              
    #      Yes                </p>            </td>            <td width="351"
    # valign="top">                <p>                    The account ID for
    # porting the numbers.                </p>            </td>        </tr>    
    #    <tr>            <td valign="top">                <p>                   
    # CustomerOrderId                </p>            </td>            <td
    # valign="top">                <p align="center">                    No     
    #           </p>            </td>            <td width="351" valign="top">  
    #              <p>                    Internal customer order id for
    # tracking the order.  Only alphanumeric values, dashes and spaces are
    # allowed. Max length is 40 characters.                </p>            </td>
    #        </tr>        <tr>            <td valign="top">                <p>  
    #                  Name                </p>            </td>            <td
    # valign="top">                <p align="center">                    Yes    
    #            </p>            </td>            <td width="351" valign="top"> 
    #               <p>                    Subscriber business / customer name. 
    #               </p>            </td>        </tr>        <tr>           
    # <td valign="top">                <p>                    HouseNumber       
    #         </p>            </td>            <td valign="top">               
    # <p align="center">                    Yes                </p>           
    # </td>            <td width="351" valign="top">                <p>         
    #           Street address number.                </p>            </td>     
    #   </tr>        <tr>            <td valign="top">                <p>       
    #             StreetName                </p>            </td>            <td
    # valign="top">                <p align="center">                    Yes    
    #            </p>            </td>            <td width="351" valign="top"> 
    #               <p>                    Street name.                </p>     
    #       </td>        </tr>        <tr>            <td valign="top">         
    #       <p>                    City                </p>            </td>    
    #        <td valign="top">                <p align="center">                
    #    Yes                </p>            </td>            <td width="351"
    # valign="top">                <p>                    City.               
    # </p>            </td>        </tr>        <tr>            <td
    # valign="top">                <p>                    StateCode             
    #   </p>            </td>            <td valign="top">                <p
    # align="center">                    Yes                </p>           
    # </td>            <td width="351" valign="top">                <p>         
    #           Two letter state code.                </p>            </td>     
    #   </tr>        <tr>            <td valign="top">                <p>       
    #             Zip                </p>            </td>            <td
    # valign="top">                <p align="center">                    Yes    
    #            </p>            </td>            <td width="351" valign="top"> 
    #               <p>                    Zip code.                </p>        
    #    </td>        </tr>        <tr>            <td valign="top">            
    #    <p>                    LoaAuthorizingPerson                </p>        
    #    </td>            <td valign="top">                <p align="center">   
    #                 Yes                </p>            </td>            <td
    # width="351" valign="top">                <p>                    First and
    # last name of person who authorized LOA.                </p>           
    # </td>        </tr>        <tr>            <td valign="top">               
    # <p>                    LoaType                </p>            </td>       
    #     <td valign="top">                <p align="center">                   
    # Yes                </p>            </td>            <td width="351"
    # valign="top">                <p>                    (Optional) Indentify
    # the LoaType on TNs. Allowed values... CARRIER or  SUBSCRIBER. Default
    # value is SUBSCRIBER.                </p>            </td>        </tr>    
    #    <tr>            <td valign="top">                <p>                   
    # TelephoneNumber                </p>            </td>            <td
    # valign="top">                <p align="center">                    Yes    
    #            </p>            </td>            <td width="351" valign="top"> 
    #               <p>                    Ten digit phone number with no dots
    # or dashes. One or more is required. Use a PhoneNumber tag for each phone
    # number in the list.                </p>            </td>        </tr>     
    #   <tr>            <td valign="top">                <p>                   
    # SiteId                </p>            </td>            <td valign="top">  
    #              <p align="center">                    Yes                </p>
    #            </td>            <td width="351" valign="top">               
    # <p>                    See section on Sites                </p>           
    # </td>        </tr>        <tr>            <td valign="top">               
    # <p>                    SipPeerId                </p>            </td>     
    #       <td valign="top">                <p align="center">                 
    #   No                </p>            </td>            <td width="351"
    # valign="top">                <p>                    See section on SIP
    # Peers                </p>            </td>        </tr>   
    # </tbody></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [ImportTnOrdersPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_order_2(account_id,
                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importtnorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ImportTnOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The order failed; one of the input parameters is invalid. The' \
          ' error text and an error code will be provided in the' \
          ' ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the history of the specified importTnOrder.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_history_3(account_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importtnorders/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ImportTnOrdersReportResponse', String)
      )
    end

    # Retrieve the history information associated with an order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_lidb_order_history_1(account_id,
                                 order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lidbs/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LidbOrderReportResponse', String)
      )
    end

    # Retrieve information about a specific Lidb Order identified as the
    # resource.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_lidb_order(account_id,
                       order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lidbs/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LidbOrderReportResponse', String)
      )
    end

    # Retrieve a list of the LIDB orders that are associated with the account.
    # <p>A maximum of 1,000 orders can be retrieved per request. If no date
    # range or specific query parameter (marked by <b class="required">*</b>
    # below) is provided, the order results will be limited to the last two
    # years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] last_modified_after Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @return [Object] response from the API call
    def get_lidb_order_2(account_id,
                         last_modified_after: nil,
                         modified_date_from: nil,
                         modified_date_to: nil,
                         tn: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lidbs'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'lastModifiedAfter' => last_modified_after,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'tn' => tn
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUNDIf any errors are found in the processing of the query' \
          ' string a 404 will be returned.  Note that parameters' \
          ' that are not recognized are not considered errors, and' \
          ' are just ignored.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LidbOrderReportResponse', String)
      )
    end

    # Create TN Option order to assign line features to the telephone number.The
    # key data elements in the submission are - <table style="text-align: left;
    # width: 80%;" border="1" cellpadding="2" cellspacing="2">  <tbody>    <tr> 
    #     <td>TnOptionGroups</td>      <td>A list of TnOptionGroups.</td>   
    # </tr>    <tr>      <td>TnOptionGroup</td>      <td>Contains list of
    # telephone numbers and set of TN options you want to assign to all TNs in
    # the list.</td>    </tr>    <tr>        <td>CustomerOrderId</td>       
    # <td>Optional value for Id set by customer. Only alphanumeric values,
    # dashes and spaces are allowed. Max length is 40 characters.</td>    </tr> 
    # </tbody></table>There are TN Option values:<ul><li> TelephoneNumber - [
    # 10digit ] </li><li> CallingNameDisplay - [ on | off | <i>unchanged</i> |
    # <i>systemDefault</i> ] </li><li> PortOutPasscode - [ alphanumeric string
    # 4-10 characters | unchanged | systemDefault ] </li><li> NumberFormat - [
    # 10digit | 11digit | e164 | <i>unchanged</i> | <i>systemDefault</i> ]
    # </li><li> RPIDFormat - [ 10digit | 11digit | e164 | <i>unchanged</i> |
    # <i>systemDefault</i> ] </li><li> RewriteUser - [ string | <i>unchanged</i>
    # | <i>systemDefault</i>] </li><li> CallForward - [ 10digit |
    # <i>unchanged</i> | <i>systemDefault</i>] </li><li> Protected - [ true |
    # false | <i>unchanged</i> | <i>systemDefault</i>] </li><li> Sms - [ on |
    # off | <i>unchanged</i>] </li><li> FinalDestinationURI - [ string |
    # <i>unchanged</i> | <i>systemDefault</i>] </li><ul>  <li>a 10 digit
    # telephone number, or</li>  <li>a SIP URI ( without the sip: prefix )   
    # <ul>      <li>in the form address-string@host IP:port, where </li>     
    # <li>the host IP is an IPv4 address in the standard numerical n.n.n.n.
    # form, and </li>      <li>the port is numeric, and optional</li>     
    # <li>containing [a-z,A-Z,0-9], with ':', '.' and '@' to delimit the
    # components of the overall string, and</li>      <li>less than 60
    # characters long.</li>    </ul>  </li></ul><li> NNID [ integer |
    # <i>unchanged</i> | <i>systemDefault</i> ] </li><li> ESPID [ string |
    # <i>unchanged</i> | <i>systemDefault</i> ] </li><li> A2pSettings </li><ul> 
    # <li>MessageClass - [ string {1,64} ] </li>  <li>CampaignId - [ string
    # {1,64} ] </li>  <li>Action - [ <i>asSpecified</i> | <i>off</i> |
    # <i>unchanged</i> | <i>systemDefault</i> ] </li></ul><li> Origination Route
    # Plan </li><ul>  <li>Route List</li>    <ul>    <li>Endpoint</li>      <ul>
    #        <li>a NANP telephone number, or</li>        <li>a SIP URI, or</li> 
    #       <li>a IPv4 address, or </li>        <li>a Fully Qualified Domain
    # name(FQDN) </li>      </ul>    <li>Priority</li>    <li>Weight</li>   
    # </ul>  <li>Action - [ <i>asSpecified</i> | <i>off</i> | <i>unchanged</i>]
    # </li></ul></ul>Where:  <ul>    <li>for A2pSettings attribute</li>   
    # <table style="text-align: left; width: 80%;"           border="1"
    # cellpadding="2" cellspacing="0">        <tbody>        <tr>         
    # <th>Number attribute</th>          <th>Action value</th>         
    # <th>Describe of action</th>        </tr>        <tr>         
    # <td>LongCode</td>          <td><i>systemDefault</i></td>         
    # <td>Removes the per-TN A2P attributes, and it reverts to the Location/SIP
    # Peer characteristics. Any values for Class or Campaign ID are not
    # valid</td>        </tr>        <tr>          <td>LongCode</td>         
    # <td><i>asSpecified</i></td>          <td>Sets the message class and
    # campaign ID - this is the default if unspecified</td>        </tr>       
    # <tr>          <td>LongCode</td>          <td><i>off</i></td>         
    # <td>Will set the TN as a 'P' TN. Any values for Class or Campaign ID are
    # not valid</td>        </tr>        <tr>          <td>LongCode</td>        
    #  <td><i>unchanged</i></td>          <td>Do nothing with respect to
    # A2P</td>        </tr>        <tr>          <td>TollFree</td>         
    # <td><i>systemDefault</i></td>          <td>Removes the per-TN A2P
    # attributes, and it reverts to the Location/SIP Peer characteristics. Any
    # values for Class or Campaign ID are not valid</td>        </tr>       
    # <tr>          <td>TollFree</td>          <td><i>asSpecified</i></td>      
    #    <td>Sets the message class and campaign ID - this is the default if
    # unspecified</td>        </tr>        <tr>          <td>TollFree</td>      
    #    <td><i>off</i></td>          <td>If the Togglz value is set to 'on'
    # this is invalid for Toll Free telephone numbers. Any values for Class or
    # Campaign ID in the payload are invalid. If the Togglz value is set to off
    # this behaves like and A2P TN, where the characteristics of the TNs is set
    # to 'P'</td>        </tr>        <tr>          <td>TollFree</td>         
    # <td><i>unchanged</i></td>          <td>Do nothing with respect to A2P</td>
    #        </tr>        </tbody>    </table>    <li>for Origination Route plan
    # attribute</li>    <table style="text-align: left; width: 80%;"          
    # border="1" cellpadding="2" cellspacing="0">        <tbody>        <tr>    
    #      <th>Action value</th>          <th>Describe of action</th>       
    # </tr>        <tr>          <td>asSpecified</td>         
    # <td>Creates/updates the origination route plan for the TN with route plan
    # details provided in the request </td>        </tr>        <tr>         
    # <td>off</td>          <td>Removes the origination route plan for the TN.
    # Route list is the request must be empty</td>        </tr>        <tr>     
    #     <td>unchanged</td>          <td>Doesn't update/create the origination
    # route plan, even when route plan details exist in the request</td>       
    # </tr>        </tbody>    </table>    <ul>      <li> Origination route plan
    # is validated against CallForward and RewriteUser</li>        <ul>         
    # <li type="square">Route plan and CallForward cannot co-exist. Order is
    # accepted but will respond with error messages on GET.</li>          <li
    # type="square">Route plan and RewriteUser cannot co-exist. Order is
    # accepted but will respond with error messages on GET.</li>        </ul>   
    # </ul>    <li>for other attribute</li>    <ul>      <li type="square">
    # <i>systemDefault</i> - implies that the element profile value should be
    # removed so that the TN changes back to the default system behavior;</li>  
    #    <li type="square"> <i>unchanged</i> - the value should remain unchanged
    # - implies a read before write model.</li>      <li
    # type="square"><u>Leaving the element out of the payload is equivalent to
    # <i>unchanged</i>.</u></li>    </ul>  </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [TnOptionOrderPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_order_5(account_id,
                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/tnoptions'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('TnOptionOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request <br> A 400 response Indicates that the order could' \
          ' not be created.Error text and an error code will be' \
          ' provided in the ErrorList element.',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict <br> A 409 response indicates that order could not be' \
          ' created.Error text and an error code will be provided' \
          ' in the ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves a list of lsrorders.  Various query parameters can be used to
    # filter the list of LSR Orders as documented below. <p>A maximum of 1,000
    # orders can be retrieved per request. If no date range or specific query
    # parameter (marked by <b class="required">*</b> below) is provided, the
    # order results will be limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] created_date_from Optional parameter: Example:
    # @param [String] created_date_to Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] order_id_fragment Optional parameter: Example:
    # @param [List of String] status Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] pon Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @return [Object] response from the API call
    def get_order_7(account_id,
                    created_date_from: nil,
                    created_date_to: nil,
                    customer_order_id: nil,
                    order_id_fragment: nil,
                    status: nil,
                    tn: nil,
                    pon: nil,
                    modified_date_from: nil,
                    modified_date_to: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'createdDateFrom' => created_date_from,
        'createdDateTo' => created_date_to,
        'customerOrderId' => customer_order_id,
        'orderIdFragment' => order_id_fragment,
        'status' => status,
        'tn' => tn,
        'pon' => pon,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found.  If any errors are found in the processing of the' \
          ' query string a 404 will be returned.  Note that' \
          ' parameters that are not recognized are not considered' \
          ' errors, and are just ignored.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LsrOrderReportResponse',
                                   String)
      )
    end

    # A POST creates a lsrorder request to initiate a port-out action.<br>The
    # payload fields are described below...<br><table style="text-align: left;
    # width: 80%;"     border="1" cellpadding="2" cellspacing="2">      <tbody> 
    #       <tr>          <td>Pon</td>          <td>The Pon is customer
    # specified order indentifier field. Allowed alphanumeric and "#","-","_".
    # Up to 25 characters long. (required).</td>        </tr>        <tr>       
    #   <td>CustomerOrderId</td>          <td>The CustomerOrderId is customer
    # specified order indentifier field. Allowed alphanumeric, spaces and
    # dashes. Up to 40 characters long. (optional).</td>        </tr>       
    # <tr>          <td>SPID</td>          <td>Identifier used in porting
    # process. If account is no multi-SPID option - default with account value,
    # otherwise value is required. Up to 4 characters long. (required)</td>     
    #   </tr>        <tr>          <td>BillingTelephoneNumber</td>         
    # <td>Non-tollfree 10 digit phone number (optional).</td>        </tr>      
    #  <tr>          <td>RequestedFocDate</td>          <td>optional (next day
    # if not specified).</td>        </tr>        <tr>         
    # <td>SubscriberType</td>          <td>Subscriber type. BUSINESS |
    # RESEDENTIAL (optional) (RESEDENTIAL if not specified).</td>        </tr>  
    #      <tr>          <td>BusinessName</td>          <td>Subscriber business
    # name for BUSINESS SubscriberType. Up to 25 characters long. (required
    # BusinessName or LastName).</td>        </tr>        <tr>         
    # <td>LastName</td>          <td>Subscriber last name for RESEDENTIAL
    # SubscriberType. Up to 25 characters long. (required BusinessName or
    # LastName).</td>        </tr>        <tr>          <td>FirstName</td>      
    #    <td>Subscriber first name for RESEDENTIAL SubscriberType. Up to 25
    # characters long. (optional).</td>        </tr>        <tr>         
    # <td>MiddleInitial</td>          <td>Subscriber middle initial for
    # RESEDENTIAL SubscriberType. 1 character (optional).</td>        </tr>     
    #                   <tr>          <td>AccountNumber</td>         
    # <td>AccountNumber.  Alphanumeric, up to 32 characters. (optional).</td>   
    #     </tr>                        <tr>          <td>PinNumber</td>         
    # <td>PinNumber. Alphanumeric, up to 10 characters. (optional).</td>       
    # </tr>        <tr>          <td>AuthorizingPerson</td>         
    # <td>AuthorizingPerson. Alphanumeric, up to 100 characters (required).</td>
    #        </tr>        <tr>          <td>HousePrefix</td>         
    # <td>HousePrefix. Alphanumeric, up to 6 characters.</td>        </tr>      
    #  <tr>          <td>HouseNumber</td>          <td>HouseNumber.
    # Alphanumeric, up to 45 characters  (required).</td>        </tr>       
    # <tr>          <td>HouseSuffix</td>          <td>HouseSuffix. Alphanumeric,
    # up to 45 characters.</td>        </tr>        <tr>         
    # <td>PreDirectional</td>          <td>PreDirectional. Alphanumeric, up to 2
    # characters.</td>        </tr>        <tr>          <td>StreetName</td>    
    #      <td>StreetName. Alphanumeric, up to 200 characters  (required).</td> 
    #       </tr>        <tr>          <td>StreetSuffix</td>         
    # <td>StreetSuffix. Alphanumeric, up to 45 characters.</td>        </tr>    
    #    <tr>          <td>PostDirectional</td>          <td>PostDirectional.
    # Alphanumeric, up to 2 characters.</td>        </tr>        <tr>         
    # <td>AddressLine2</td>          <td>AddressLine2. Alphanumeric, up to 200
    # characters.</td>        </tr>        <tr>          <td>County</td>        
    #  <td>County. Alphanumeric, up to 45 characters.</td>        </tr>       
    # <tr>          <td>City</td>          <td>City. Alphanumeric, up to 100
    # characters  (required).</td>        </tr>        <tr>         
    # <td>StateCode</td>          <td>StateCode. Alphanumeric, 2 characters 
    # (required).</td>        </tr>        <tr>          <td>Zip</td>         
    # <td>Zip code. Allowed formats: 5 numbers, 5+4 or Canadian 
    # (required).</td>        </tr>        <tr>         
    # <td>ListOfTelephoneNumbers</td>          <td>List of tns to be processed 
    # (required).</td>        </tr>        </tbody>    </table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [LsrOrderPayload] body Optional parameter: Example:
    # @return [LsrOrderResponse] response from the API call
    def create_lsr_order(account_id,
                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('LsrOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request shows that lsrorder request does not pass validation.' \
          ' Fror more info see LsrOrderErrors section in response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LsrOrderResponse',
                                   LsrOrderResponse)
      )
    end

    # Retrieves the information associated with the specified lsr ID number.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_8(account_id,
                    order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LsrOrderReportResponse',
                                   String)
      )
    end

    # Retrieves the history of the specified lsr order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_history_5(account_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LsrOrderReportResponse',
                                   String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @return [LongXMLWrapper] response from the API call
    def get_total_orders_by_status(account_id,
                                   status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Quantity',
                                   LongXMLWrapper)
      )
    end

    # Retrieve information about a removeImportedTnOrder with specified ID.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_9(account_id,
                    order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/removeImportedTnOrders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'RemoveImportedTnOrdersReportResponse',
                                   String)
      )
    end

    # Retrieves the removeImportedTnOrders requests for the given account ID.
    # <p>A maximum of 1,000 orders can be retrieved per request. If no date
    # range or specific query parameter (marked by <b class="required">*</b>
    # below) is provided, the order results will be limited to the last two
    # years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] invert_account_id_search Optional parameter: Example:
    # @param [Integer] site_id Optional parameter: Example:
    # @param [Integer] sippeer_id Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] last_modified_by Optional parameter: Example:
    # @param [String] order_id_fragment Optional parameter: Example:
    # @param [List of String] activity_state Optional parameter: Example:
    # @param [List of String] bandwidth_prime Optional parameter: Example:
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @param [String] last_modified_after Optional parameter: Example:
    # @param [String] created_date_from Optional parameter: Example:
    # @param [String] created_date_to Optional parameter: Example:
    # @param [List of String] include_in_response Optional parameter: Example:
    # @param [Boolean] order_details Optional parameter: Example:false
    # @param [String] status Optional parameter: Example:
    # @return [Object] response from the API call
    def get_orders_7(account_id,
                     invert_account_id_search: nil,
                     site_id: nil,
                     sippeer_id: nil,
                     page: nil,
                     size: nil,
                     tn: nil,
                     customer_order_id: nil,
                     last_modified_by: nil,
                     order_id_fragment: nil,
                     activity_state: nil,
                     bandwidth_prime: nil,
                     modified_date_from: nil,
                     modified_date_to: nil,
                     last_modified_after: nil,
                     created_date_from: nil,
                     created_date_to: nil,
                     include_in_response: nil,
                     order_details: false,
                     status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/removeImportedTnOrders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'invertAccountIdSearch' => invert_account_id_search,
        'siteId' => site_id,
        'sippeerId' => sippeer_id,
        'page' => page,
        'size' => size,
        'tn' => tn,
        'customerOrderId' => customer_order_id,
        'lastModifiedBy' => last_modified_by,
        'orderIdFragment' => order_id_fragment,
        'activityState' => activity_state,
        'bandwidthPrime' => bandwidth_prime,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to,
        'lastModifiedAfter' => last_modified_after,
        'createdDateFrom' => created_date_from,
        'createdDateTo' => created_date_to,
        'includeInResponse' => include_in_response,
        'orderDetails' => order_details,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'RemoveImportedTnOrdersReportResponse',
                                   String)
      )
    end

    # Creates a removeImportedTnOrders request to remove imported telephone
    # numbers from the given site ID and sippeer ID as specified in the body. A
    # successfully submitted order will have a status of "PROCESSING". A
    # successfully completed order will have a status of "COMPLETE" if all of
    # the telephone numbers were successfully removed and  "PARTIAL" if some of
    # the telephone numbers were removed. A failed order with will have a staus
    # of "FAILED" and no telephone numbers would have been removed.The elements
    # supplied in the payloads are described in the following table:<table
    # border="1" cellspacing="0" cellpadding="0" width="624">    <tbody>       
    # <tr>            <td valign="top">                <p>                   
    # <strong>Parameter</strong>                </p>            </td>           
    # <td valign="top">                <p>                   
    # <strong>Required</strong>                </p>            </td>           
    # <td width="351" valign="top">                <p>                   
    # <strong>Description</strong>                </p>            </td>       
    # </tr>        <tr>            <td valign="top">                <p>         
    #           accountId (URL Parameter)                </p>            </td>  
    #          <td valign="top">                <p align="center">              
    #      Yes                </p>            </td>            <td width="351"
    # valign="top">                <p>                    The account ID for
    # porting the numbers.                </p>            </td>        </tr>    
    #    <tr>            <td valign="top">                <p>                   
    # CustomerOrderId                </p>            </td>            <td
    # valign="top">                <p align="center">                    No     
    #           </p>            </td>            <td width="351" valign="top">  
    #              <p>                    Internal customer order id for
    # tracking the order.  Only alphanumeric values, dashes and spaces are
    # allowed. Max length is 40 characters.                </p>            </td>
    #        </tr>        <tr>            <td valign="top">                <p>  
    #                  TelephoneNumber                </p>            </td>     
    #       <td valign="top">                <p align="center">                 
    #   Yes                </p>            </td>            <td width="351"
    # valign="top">                <p>                    Ten digit phone number
    # with no dots or dashes. One or more is required. Use a PhoneNumber tag for
    # each phone number in the list.                </p>            </td>       
    # </tr>    </tbody></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [RemoveImportedTnOrdersPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_order_4(account_id,
                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/removeImportedTnOrders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('RemoveImportedTnOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The order failed; one of the input parameters is invalid. The' \
          ' error text and an error code will be provided in the' \
          ' ErrorList element.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the history of the specified removeImportedTnOrder.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_history_7(account_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/removeImportedTnOrders/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'RemoveImportedTnOrdersReportResponse',
                                   String)
      )
    end

    # Retrieve the history information associated with an order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_order_history_8(account_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @return [Object] response from the API call
    def get_total_orders_by_status_1(account_id,
                                     status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # returns a list of phone numbers associated with the ID of a given account.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_t_ns_by_order_id(account_id,
                             order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}/tns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # Retrieves the area codes of the phone numbers from the specified order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_report_by_npa(account_id,
                          order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}/areaCodes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # GET is used to retrieve order ids and order details for previously
    # attempted Telephone Number orders. <p>A maximum of 1,000 orders can be
    # retrieved per request. If no date range or specific query parameter
    # (marked by <b class="required">*</b> below) is provided, the order results
    # will be limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] userid Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @return [Object] response from the API call
    def get_tn_orders_1(account_id,
                        userid: nil,
                        startdate: nil,
                        enddate: nil,
                        status: nil,
                        customer_order_id: nil,
                        page: nil,
                        size: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'userid' => userid,
        'startdate' => startdate,
        'enddate' => enddate,
        'status' => status,
        'customerOrderId' => customer_order_id,
        'page' => page,
        'size' => size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - malformed Query Parameters can result in a 400 Bad' \
          ' request.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Not Found - returned if the retrieval request cannot be' \
          ' satisfied, either because the order id cannot be found' \
          ' or the order id is not recognized.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # Retrieves the Telephone Numbers associated by the given order ID
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:0
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_tns_by_order_id(account_id,
                            site_id,
                            order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/orders/{orderId}/tns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # GET all of the details associated with an identified order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [Boolean] tndetail Optional parameter: Example:false
    # @return [Object] response from the API call
    def get_tn_order_1(account_id,
                       order_id,
                       tndetail: false)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'tndetail' => tndetail
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # The GET method retrieves all the orders associated with the given site.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:0
    # @param [String] userid Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @return [Object] response from the API call
    def get_tn_orders_by_site(account_id,
                              site_id,
                              userid: nil,
                              startdate: nil,
                              enddate: nil,
                              status: nil,
                              page: nil,
                              size: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/orders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'userid' => userid,
        'startdate' => startdate,
        'enddate' => enddate,
        'status' => status,
        'page' => page,
        'size' => size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Orders cannot be found for that site. Possible explanations:<ul> ' \
          '   <li>There are no orders associated with that' \
          ' site.</li>    <li>The given parameters are' \
          ' invalid.</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:0
    # @param [String] order_id Required parameter: Example:
    # @param [Boolean] tndetail Optional parameter: Example:false
    # @return [Object] response from the API call
    def get_tn_order_for_site_id(account_id,
                                 site_id,
                                 order_id,
                                 tndetail: false)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/orders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'tndetail' => tndetail
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # Retrieves the total quantity of phone numbers from the specified order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_count_t_ns_by_order_id(account_id,
                                   order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # Retrieves the Npa-Nxx of the phone numbers from the specified order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_report_by_npanxx(account_id,
                             order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/orders/{orderId}/npaNxx'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TnOrderReportResponse',
                                   String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] product_name Required parameter: Example:
    # @return [ProductTnHistoryResponse] response from the API call
    def get_product_tn_history(account_id,
                               product_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/products/{productName}/tntotals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'productName' => { 'value' => product_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ProductTNDetailsResponse',
                                   ProductTnHistoryResponse)
      )
    end

    # Retrieve count of Telephone numbers for Sip Peer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [List of String] feature Optional parameter: Example:
    # @return [SipPeerTelephoneNumbersCountResponse] response from the API call
    def get_sip_peer_telephone_numbers_count(account_id,
                                             site_id,
                                             sip_peer_id,
                                             feature: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/totaltns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'feature' => feature
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumbersCountResponse',
                                   SipPeerTelephoneNumbersCountResponse)
      )
    end

    # TODO
    # @param [List of Integer] account_id Optional parameter: Example:
    # @param [Integer] site_id Optional parameter: Example:
    # @param [Integer] sippeer_id Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] fullnumber Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [Integer] lata Optional parameter: Example:
    # @param [Integer] tier Optional parameter: Example:
    # @param [String] npa Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxx_x Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] host Optional parameter: Example:
    # @param [String] order_id Optional parameter: Example:
    # @param [String] last_modified_date_from Optional parameter: Example:
    # @param [String] last_modified_date_to Optional parameter: Example:
    # @param [String] protected Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @return [TelephoneNumbersHistoryResponse] response from the API call
    def search_account_telephone_numbers(account_id: nil,
                                         site_id: nil,
                                         sippeer_id: nil,
                                         page: nil,
                                         size: nil,
                                         fullnumber: nil,
                                         rate_center: nil,
                                         lata: nil,
                                         tier: nil,
                                         npa: nil,
                                         npa_nxx: nil,
                                         npa_nxx_x: nil,
                                         city: nil,
                                         state: nil,
                                         host: nil,
                                         order_id: nil,
                                         last_modified_date_from: nil,
                                         last_modified_date_to: nil,
                                         protected: nil,
                                         status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'accountId' => account_id,
        'siteId' => site_id,
        'sippeerId' => sippeer_id,
        'page' => page,
        'size' => size,
        'fullnumber' => fullnumber,
        'rateCenter' => rate_center,
        'lata' => lata,
        'tier' => tier,
        'npa' => npa,
        'npaNxx' => npa_nxx,
        'npaNxxX' => npa_nxx_x,
        'city' => city,
        'state' => state,
        'host' => host,
        'orderId' => order_id,
        'lastModifiedDateFrom' => last_modified_date_from,
        'lastModifiedDateTo' => last_modified_date_to,
        'protected' => protected,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumbersResponse',
                                   TelephoneNumbersHistoryResponse)
      )
    end

    # TODO
    # @param [TelephoneNumbersPayload] body Optional parameter: Example:
    # @return [TelephoneNumbersHistoryResponse] response from the API call
    def create_get_telephone_numbers_details_by_telephone_numbers(body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('TnList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumbersResponse',
                                   TelephoneNumbersHistoryResponse)
      )
    end

    # Retrieves detailed information about the phone number.TnAttributes - Does
    # this telephone number is protected or not.
    # @param [String] fullnumber Required parameter: Example:
    # @return [TelephoneNumberDetailHistoryResponse] response from the API call
    def get_telephone_number_details(fullnumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{fullnumber}/tndetails'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'fullnumber' => { 'value' => fullnumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - failed to get detailed information about the' \
          ' current phone number.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumberResponse',
                                   TelephoneNumberDetailHistoryResponse)
      )
    end

    # Retrieves the telephone number's information.
    # @param [String] fullnumber Required parameter: Example:
    # @return [TelephoneNumberStatusWrapper] response from the API call
    def get_telephone_number(fullnumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{fullnumber}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'fullnumber' => { 'value' => fullnumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumberResponse',
                                   TelephoneNumberStatusWrapper)
      )
    end

    # Retrieves the rate centers associated with that telephone number.
    # @param [String] fullnumber Required parameter: Example:
    # @return [TelephoneNumberDetailHistoryResponse] response from the API call
    def get_telephone_number_rate_center(fullnumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{fullnumber}/ratecenter'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'fullnumber' => { 'value' => fullnumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumberResponse',
                                   TelephoneNumberDetailHistoryResponse)
      )
    end

    # Retrieves the lata associated with that telephone number.
    # @param [String] fullnumber Required parameter: Example:
    # @return [TelephoneNumberDetailHistoryResponse] response from the API call
    def get_telephone_number_lata(fullnumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{fullnumber}/lata'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'fullnumber' => { 'value' => fullnumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumberResponse',
                                   TelephoneNumberDetailHistoryResponse)
      )
    end

    # Retrieves information about available NnRoutes for the phone number.
    # @param [String] fullnumber Required parameter: Example:
    # @return [TelephoneNumberAvailableNnRoutesResponse] response from the API call
    def get_telephone_number_available_routes(fullnumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/tns/{fullnumber}/availableNnRoutes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'fullnumber' => { 'value' => fullnumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - failed to get available NnRoutes information for' \
          ' the current phone number.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AvailableNNRoutesResponse',
                                   TelephoneNumberAvailableNnRoutesResponse)
      )
    end

    # Returns the total number of in-service numbers for the given account.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] tier Optional parameter: Example:
    # @param [Integer] lata Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [String] area_code Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxxx Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @return [TelephoneNumberTotalsHistory] response from the API call
    def get_inservice_telephone_numbers(account_id,
                                        tier: nil,
                                        lata: nil,
                                        rate_center: nil,
                                        area_code: nil,
                                        npa_nxx: nil,
                                        npa_nxxx: nil,
                                        state: nil,
                                        city: nil,
                                        startdate: nil,
                                        enddate: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/inservicenumbers/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'tier' => tier,
        'lata' => lata,
        'rateCenter' => rate_center,
        'areaCode' => area_code,
        'npaNxx' => npa_nxx,
        'npaNxxx' => npa_nxxx,
        'state' => state,
        'city' => city,
        'startdate' => startdate,
        'enddate' => enddate
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Quantity',
                                   TelephoneNumberTotalsHistory)
      )
    end

    # Retrieves all the telephone numbers currently in service for the given
    # site.<br>There are multiple parameters to search and sort the in-service
    # numbers:<ul>    <li>LATA</li>    <li>Tier</li>    <li>Rate center</li>   
    # <li>Area code</li>    <li>Npa-Nxx</li>    <li>State</li>    <li>City</li> 
    #   <li>Start Date</li>    <li>End date</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [Integer] tier Optional parameter: Example:
    # @param [Integer] lata Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [String] area_code Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxxx Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @return [AccountTelephoneNumbersHistoryResponse] response from the API call
    def get_inservice_telephone_numbers_1(account_id,
                                          site_id,
                                          page: nil,
                                          size: nil,
                                          tier: nil,
                                          lata: nil,
                                          rate_center: nil,
                                          area_code: nil,
                                          npa_nxx: nil,
                                          npa_nxxx: nil,
                                          state: nil,
                                          city: nil,
                                          startdate: nil,
                                          enddate: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/inservicenumbers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'tier' => tier,
        'lata' => lata,
        'rateCenter' => rate_center,
        'areaCode' => area_code,
        'npaNxx' => npa_nxx,
        'npaNxxx' => npa_nxxx,
        'state' => state,
        'city' => city,
        'startdate' => startdate,
        'enddate' => enddate
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TNs',
                                   AccountTelephoneNumbersHistoryResponse)
      )
    end

    # Retrieves a list of in-service phone numbers associated with the account
    # ID. There are multiple search parameters for searching for in-service
    # numbers:<ul>    <li>size and page for pagination</li>    <li>area
    # code</li>    <li>Npa-Nxx</li>    <li>LATA</li>    <li>state</li>   
    # <li>rate center</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [Integer] tier Optional parameter: Example:
    # @param [Integer] lata Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [String] area_code Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxxx Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @return [AccountTelephoneNumbersHistoryResponse] response from the API call
    def get_inservice_telephone_numbers_2(account_id,
                                          page: nil,
                                          size: nil,
                                          tier: nil,
                                          lata: nil,
                                          rate_center: nil,
                                          area_code: nil,
                                          npa_nxx: nil,
                                          npa_nxxx: nil,
                                          state: nil,
                                          city: nil,
                                          startdate: nil,
                                          enddate: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/inservicenumbers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'tier' => tier,
        'lata' => lata,
        'rateCenter' => rate_center,
        'areaCode' => area_code,
        'npaNxx' => npa_nxx,
        'npaNxxx' => npa_nxxx,
        'state' => state,
        'city' => city,
        'startdate' => startdate,
        'enddate' => enddate
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - The search parameters are invalid and prevent finding' \
          ' any content',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TNs',
                                   AccountTelephoneNumbersHistoryResponse)
      )
    end

    # A GET on the number desired will return a 200 OK if the number is in
    # service on the account, or a 404 not found.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] telephone_number Required parameter: Example:
    # @return [Object] response from the API call
    def get_inservice_telephone_numbers_3(account_id,
                                          telephone_number)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/inservicenumbers/{telephoneNumber}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'telephoneNumber' => { 'value' => telephone_number, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The telephone number is not currently in service.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves a list of disconnected numbers associated with the account.
    # There are optional search parameters to limit the discNumbers payload
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @return [AccountDisconnectedNumbersResponse] response from the API call
    def get_disconnected_telephones(account_id,
                                    page: nil,
                                    size: nil,
                                    startdate: nil,
                                    enddate: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/discnumbers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'startdate' => startdate,
        'enddate' => enddate
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TNs',
                                   AccountDisconnectedNumbersResponse)
      )
    end

    # Retrieves a total number of disconnects.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @return [TelephoneNumberTotalsHistory] response from the API call
    def get_disconnected_telephone_number_totals(account_id,
                                                 startdate: nil,
                                                 enddate: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/discnumbers/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'startdate' => startdate,
        'enddate' => enddate
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Quantity',
                                   TelephoneNumberTotalsHistory)
      )
    end

    # Retrieve information about one or more Telephone Numbers (TNs) with port
    # out passcode.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Optional parameter: Example:
    # @param [Integer] sippeer_id Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] fullnumber Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [Integer] lata Optional parameter: Example:
    # @param [Integer] tier Optional parameter: Example:
    # @param [String] npa Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxx_x Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] host Optional parameter: Example:
    # @param [String] order_id Optional parameter: Example:
    # @param [String] last_modified_date_from Optional parameter: Example:
    # @param [String] last_modified_date_to Optional parameter: Example:
    # @param [String] protected Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @return [TnPortOutPasscodesResponse] response from the API call
    def get_tns_passcode(account_id,
                         site_id: nil,
                         sippeer_id: nil,
                         page: nil,
                         size: nil,
                         fullnumber: nil,
                         rate_center: nil,
                         lata: nil,
                         tier: nil,
                         npa: nil,
                         npa_nxx: nil,
                         npa_nxx_x: nil,
                         city: nil,
                         state: nil,
                         host: nil,
                         order_id: nil,
                         last_modified_date_from: nil,
                         last_modified_date_to: nil,
                         protected: nil,
                         status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/tnportoutpasscodes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'siteId' => site_id,
        'sippeerId' => sippeer_id,
        'page' => page,
        'size' => size,
        'fullnumber' => fullnumber,
        'rateCenter' => rate_center,
        'lata' => lata,
        'tier' => tier,
        'npa' => npa,
        'npaNxx' => npa_nxx,
        'npaNxxX' => npa_nxx_x,
        'city' => city,
        'state' => state,
        'host' => host,
        'orderId' => order_id,
        'lastModifiedDateFrom' => last_modified_date_from,
        'lastModifiedDateTo' => last_modified_date_to,
        'protected' => protected,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - any syntax error in the parameters will cause a 400' \
          ' error with a payload similar to the payload in the' \
          ' example, with an error code and text description.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumbersResponse',
                                   TnPortOutPasscodesResponse)
      )
    end

    # Retrieve information about one or more Telephone Numbers (TNs), where the
    # TNs are specified in POST body.
    # @param [Integer] account_id Required parameter: Example:
    # @param [TelephoneNumbersPayload] body Optional parameter: Example:
    # @return [TnPortOutPasscodesResponse] response from the API call
    def create_get_tns_port_out_passcodes_by_telephone_numbers(account_id,
                                                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/tnportoutpasscodes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('TnList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - when in the POST body specified more then' \
          ' {pagination.maxsize} TNs.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'TelephoneNumbersResponse',
                                   TnPortOutPasscodesResponse)
      )
    end

    # Retrieves a list of in-service phone numbers associated with the account
    # ID. There are multiple search parameters for searching for in-service
    # numbers:<ul>    <li>size and page for pagination</li>    <li>area
    # code</li>    <li>Npa-Nxx</li>    <li>LATA</li>    <li>state</li>   
    # <li>rate center</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] type Optional parameter: Example:
    # @return [TelephoneNumbersDetailsHistory] response from the API call
    def get_telephone_numbers_details_history(account_id,
                                              type: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/inserviceNumbers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'type' => type
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'Not Found - The search parameters are invalid and prevent finding' \
          ' any content',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TNs',
                                   TelephoneNumbersDetailsHistory)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [UcTrunkingPremiseTrunksResponse] response from the API call
    def get_account_toll_free_totals(account_id,
                                     site_id,
                                     sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/uctrunks'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'UcTrunkingPremiseSettingsResponse',
                                   UcTrunkingPremiseTrunksResponse)
      )
    end

    # Retrieves the total count of Toll-Free Telephone Numbers for the given SIP
    # peer.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerTollFreeTotalsResponse] response from the API call
    def get_sip_peer_toll_free_totals(account_id,
                                      site_id,
                                      sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/tftotals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTollFreeTotalsResponse',
                                   SipPeerTollFreeTotalsResponse)
      )
    end

    # Retrieves the total number of seats.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SiteTnTotalResponse] response from the API call
    def get_product_tn_history_1(account_id,
                                 site_id,
                                 sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/totalSeats'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The account ID given does not have UC Trunking associated with it.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteTNsResponse',
                                   SiteTnTotalResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @return [SiteTnTotalResponse] response from the API call
    def get_product_tn_history_2(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/totalSeats'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteTNsResponse',
                                   SiteTnTotalResponse)
      )
    end

    # Retrieves the total number of seats.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @return [SiteTnTotalResponse] response from the API call
    def get_product_tn_history_3(account_id,
                                 site_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/totalSeats'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The account ID given does not have UC Trunking associated with it.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SiteTNsResponse',
                                   SiteTnTotalResponse)
      )
    end

    # Request portability information on a set of TNs
    # @param [Integer] account_id Required parameter: Example:
    # @param [ImportTnCheckerPayload] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_check_import_tn_availability(account_id,
                                            body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importTnChecker'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ImportTnCheckerPayload',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Response - there were errors in evaluating the body of the' \
          ' requestPotential errors include:<ul>  <li> List of TNs' \
          ' is empty.  <li> List of TNs is more than 5000 TNs. ' \
          ' <li> The account does not have the necessary' \
          ' (IMPORT_TNS) flag.  <li> TNs are invalid (they are not' \
          ' actual TNs, and there are duplicates).</ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Gets a single Import To Account order by its ID
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [Boolean] tndetail Optional parameter: Example:false
    # @return [ImportToAccountNumberOrderResponse] response from the API call
    def get_all_t_ns_for_import_order(account_id,
                                      orderid,
                                      tndetail: false)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/importToAccount/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'tndetail' => tndetail
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ImportToAccountNumberOrderResponse',
                                   ImportToAccountNumberOrderResponse)
      )
    end

    # Gets all telephone numbers associated with a Port In order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [TelephoneNumberListWrapper] response from the API call
    def get_t_ns_by_order_id_1(account_id,
                               orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}/tns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TelephoneNumbers',
                                   TelephoneNumberListWrapper)
      )
    end

    # Gets the quantity of telephone numbers in a single Port In order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [LongXMLWrapper] response from the API call
    def get_count_t_ns_by_order_id_1(account_id,
                                     orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Quantity',
                                   LongXMLWrapper)
      )
    end

    # Gets a list of Port In orders which match the included criteria
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] customer_order_id Optional parameter: Example:
    # @param [String] pon Optional parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @param [String] date Optional parameter: Example:
    # @param [String] tn Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] bulkportinorderid Optional parameter: Example:
    # @return [LnpResponseListWrapper] response from the API call
    def get_portins(account_id,
                    customer_order_id: nil,
                    pon: nil,
                    startdate: nil,
                    enddate: nil,
                    status: nil,
                    date: nil,
                    tn: nil,
                    page: nil,
                    size: nil,
                    bulkportinorderid: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'customerOrderId' => customer_order_id,
        'pon' => pon,
        'startdate' => startdate,
        'enddate' => enddate,
        'status' => status,
        'date' => date,
        'tn' => tn,
        'page' => page,
        'size' => size,
        'bulkportinorderid' => bulkportinorderid
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LNPResponseWrapper',
                                   LnpResponseListWrapper)
      )
    end

    # Creates a port-in request for the accountId, SiteId, and PeerId. If PeerId
    # is omitted, the default PeerId (Location) for the Site (Sub-Account) will
    # be used.  Once the payload is successfully submitted, the order will
    # temporarily have a status of  "PENDING_DOCUMENTS", then
    # "SUBMITTED".<br><br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [LnpOrder] body Optional parameter: Example:
    # @return [LnpOrderResponse] response from the API call
    def create_lnp_order(account_id,
                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('LnpOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The order failed; one of the input parameters is invalid.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LnpOrderResponse',
                                   LnpOrderResponse)
      )
    end

    # Gets detailed information about a single Port In order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [LnpOrderResponse] response from the API call
    def get_lnp_object_by_id(account_id,
                             orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LnpOrderResponse',
                                   LnpOrderResponse)
      )
    end

    # It is possible to change ("SUPP" in LNP terms) an existing LNP order. 
    # This is done via a PUT on the existing order-id.Since many of the entries
    # in an LNP Order cannot be changed after the initial order is placed the
    # PUT on a porting order-id does *not* require that the full order payload
    # is included.<br/>If SUPP is done to <strong>draft</strong> portin no
    # validations will be applied except validation of tn list if at least 1 tn
    # is provided.Items that can be included in a SUPP request
    # include:<ul><li>CustomerOrderId</li><li>RequestedFocDate</li><li>BillingTe
    # lephoneNumber</li><li>NewBillingTelephoneNumber</li><li>AccountNumber</li>
    # <li>PinNumber</li><li>TnAttributes elements</li><li>Subscriber elements,
    # including the subscriber type, the name elements, and the street address
    # elements.  See the discussion below on
    # ResetAddressFields</li><li>SiteId</li><li>PeerId</li><li>PartialPort,
    # and</li><li>LoaAuthorizingPerson</li><li>ListOfPhoneNumbers</li><li>Trigge
    # red</li><li>Immediately</li></ul>Note: If the order ProcessingStatus is
    # DRAFT, the rules about what can be changed are much more relaxed.
    # Validation is performed when the ProcessingStatus is changed from DRAFT to
    # SUBMITTED.<p>The AltSpid element can be modified if it is not configured
    # at the system level.<p>List of phone numbers can be modified only for
    # Automated on-net port type.<p><b>ProcessingStatus</b> - you can only
    # provide this field with a value of SUBMITTED and only if the current
    # ProcessingStatus of the port-in is DRAFT.<p><b>ResetAddressFields -</b> As
    # stated above the general approach to handling <i>this</i> API call is to
    # replace the elements included in the request body, and leave other
    # preexisting elements in an unmodified condition.  This is typical of a
    # PATCH method, but because of our commitment to backwards compatibility we
    # have elected not to "Fix" this behavior.As a result, providing only a few
    # fields in the street address will result in an update to just those
    # fields. This prevents removal of an element of the address.  The
    # ResetAddressFields element is provided to resolve this issue.  The default
    # setting of 'false' is to consistency with the initial implementation.The
    # recommendation is to replace the entire street address.  This ensures that
    # you are enforcing the street address content of the port-in order.  As
    # part of this recommendation the ResetAddressFields element should be set
    # to true, which will force the street address to be exactly what you
    # specified in the payload.<br> <br> When a port-in is being processed by
    # off-net partner Level 3 (you can tell this because /lnpchecker indicates a
    # Port Type of AUTOMATEDOFFNET), the rules for what can be changed in a SUPP
    # operation are more restrictive. If the order has NOT yet received FOC, you
    # may change the following:<ul>  <li>RequestedFocDate</li> 
    # <li>BillingTelephoneNumber</li>  <li>SubscriberType</li>  <li>Subscriber
    # name elements or BusinessName, provided that SubscriberType is
    # provided</li></ul>After FOC has been received, only RequestedFocDate may
    # be changed.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [Boolean] local_order_update Optional parameter: Example:false
    # @param [LnpOrderSupp] body Optional parameter: Example:
    # @return [LnpOrderResponse] response from the API call
    def update_supp_lnp_order(account_id,
                              orderid,
                              local_order_update: false,
                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'LocalOrderUpdate' => local_order_update
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('LnpOrderSupp', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'List of telephone numbers cannot be changed due to validation' \
          ' errors.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LnpOrderResponse',
                                   LnpOrderResponse)
      )
    end

    # If portin is in DRAFT state the order will be deleted. Otherwise the call
    # simply places the existing order in a cancelled state.Note that only a
    # pending port-in order can be cancelled; if the order was previously
    # cancelled or completed, then a DELETE will not be possible.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def delete_cancel_lnp_order(account_id,
                                orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Order id is invalid, order does not exist or the port-in order is' \
          ' already processed, and therefore cannot be deleted.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Gets the number of Port In orders with the specified vendor and status
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] vendor Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @return [LongXMLWrapper] response from the API call
    def get_port_count_per_vendor(account_id,
                                  vendor: nil,
                                  status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/totals'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'vendor' => vendor,
        'status' => status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Quantity',
                                   LongXMLWrapper)
      )
    end

    # Gets Port In orders which were last modified in the specified date range
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] startdate Optional parameter: Example:
    # @param [String] enddate Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @return [LnpResponseListWrapper] response from the API call
    def get_all_ports_by_account_id_and_range(account_id,
                                              startdate: nil,
                                              enddate: nil,
                                              page: nil,
                                              size: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/status'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'startdate' => startdate,
        'enddate' => enddate,
        'page' => page,
        'size' => size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LNPResponseWrapper',
                                   LnpResponseListWrapper)
      )
    end

    # Gets history of changes to a Port In order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [OrderHistoryWrapper] response from the API call
    def get_history_by_order_id(account_id,
                                orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderid}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'OrderHistoryWrapper',
                                   OrderHistoryWrapper)
      )
    end

    # Gets a list of Port In orders for the specified site (sub-account)
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:0
    # @param [String] status Optional parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @return [LnpResponseListWrapper] response from the API call
    def get_site_port_in_orders(account_id,
                                site_id,
                                status: nil,
                                page: nil,
                                size: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/portins'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'status' => status,
        'page' => page,
        'size' => size
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LNPResponseWrapper',
                                   LnpResponseListWrapper)
      )
    end

    # Request portability information on a set of TNs
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] full_check Optional parameter: Example:
    # @param [NumberPortabilityRequest] body Optional parameter: Example:
    # @return [NumberPortabilityResponse] response from the API call
    def create_check_lnp_availability(account_id,
                                      full_check: nil,
                                      body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lnpchecker'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'fullCheck' => full_check
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('NumberPortabilityRequest',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Response - there were errors in evaluating the body of the' \
          ' requestPotential errors include: <ul><li> Telephone' \
          ' number is already being processed on another' \
          ' order.<li> Rate Center Not Present in Bandwidth' \
          ' Dashboard API.<li> Account not enabled for LNP </ul> ',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'NumberPortabilityResponse',
                                   NumberPortabilityResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] telephonenumber Required parameter: Example:
    # @return [LnpAvailabilityCheckResponse] response from the API call
    def get_check_lnp_availability_1(account_id,
                                     telephonenumber)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/availabilityCheck/{telephonenumber}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'telephonenumber' => { 'value' => telephonenumber, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LnpAvailabilityCheckResponse',
                                   LnpAvailabilityCheckResponse)
      )
    end

    # Updates or cancels a port-out ID. THe payload to this method is similar to
    # the GET on /accounts/{accountid}/portouts.<br>In the payload, CallbackUrl
    # and InternalPort are optional additives.<br>There are also multiple
    # options for the following:<table>    <tr>        <th>Option</th>       
    # <th>Choices</th>    </tr>    <tr>       
    # <td>Supplemental</td><td>NONE<br>CANCEL<br>UPDATE<br>OTHER<br></td>   
    # </tr>    <tr>       
    # <td>PortOutAction</td><td>NEW<br>SUPP<br>MODIFY<br>CANCEL<br></td>   
    # </tr></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [ManualPortOutRequest] body Optional parameter: Example:
    # @return [ManualPortOutResponse] response from the API call
    def update_port_out(account_id,
                        order_id,
                        body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portouts/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('PortOutRequest', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'PortOutResponse',
                                   ManualPortOutResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [ManualPortOutRequest] body Optional parameter: Example:
    # @return [ManualPortOutResponse] response from the API call
    def update_supp_port_out(account_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portouts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('PortOutRequest', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'PortOutResponse',
                                   ManualPortOutResponse)
      )
    end

    # Creates a port-out request.<br>In the payload, CallbackUrl and
    # InternalPort are optional.<br>There are also multiple options for the
    # following:<table>    <tr>        <th>Option</th>        <th>Choices</th>  
    #  </tr>    <tr>       
    # <td>Supplemental</td><td>NONE<br>CANCEL<br>UPDATE<br>OTHER<br></td>   
    # </tr>    <tr>       
    # <td>PortOutAction</td><td>NEW<br>SUPP<br>MODIFY<br>CANCEL<br></td>   
    # </tr>    <tr>        <td>InternalPort</td><td>true or false<br></td>   
    # </tr></table>
    # @param [Integer] account_id Required parameter: Example:
    # @param [ManualPortOutRequest] body Optional parameter: Example:
    # @return [ManualPortOutResponse] response from the API call
    def create_port_out(account_id,
                        body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portouts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('PortOutRequest', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'PortOutResponse',
                                   ManualPortOutResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [ManualPortOutRequest] body Optional parameter: Example:
    # @return [ManualPortOutResponse] response from the API call
    def delete_cancel_port_out(account_id,
                               body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portouts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('PortOutRequest', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'PortOutResponse',
                                   ManualPortOutResponse)
      )
    end

    # Retrieves the history of the specified bulk port-in order. Obtaining
    # history for a draft bulk port-in is not supported.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_port_in_order_history_1(account_id,
                                    order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderId}/history'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the order id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the Bulk Port-in requests for the given account ID. <p>A maximum
    # of 1,000 orders can be retrieved per request. If no date range or specific
    # query parameter (marked by <b class="required">*</b> below) is provided,
    # the order results will be limited to the last two years.</p>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] status Optional parameter: Example:
    # @param [String] order_date Optional parameter: Example:
    # @param [Boolean] order_details Optional parameter: Example:false
    # @param [String] modified_date_from Optional parameter: Example:
    # @param [String] modified_date_to Optional parameter: Example:
    # @return [Object] response from the API call
    def get_bulk_portins(account_id,
                         page: nil,
                         size: nil,
                         status: nil,
                         order_date: nil,
                         order_details: false,
                         modified_date_from: nil,
                         modified_date_to: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'status' => status,
        'orderDate' => order_date,
        'orderDetails' => order_details,
        'modifiedDateFrom' => modified_date_from,
        'modifiedDateTo' => modified_date_to
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Creates a Bulk Port-in request to be used as a template for a collections
    # of individual port-in orders. This will be applied to port-ins that result
    # from decomposing a collection of Telephone Numbers that span carriers, or
    # have attributes that drive the decomposition into a number of individual
    # port-in orders.<p>Upon a successfully-submitted payload, the order will
    # have a status of "DRAFT", denoting that further modification to the
    # template is expected.<p>Releated sub-resources are used to decompose the
    # collection of Telephone Numbers into individual port-in orders.<p>The only
    # valid value for the <ProcessingStatus> element in a POST is 'DRAFT', which
    # is the default value.
    # @param [Integer] account_id Required parameter: Example:
    # @param [BulkPortin] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_bulk_portins_order(account_id,
                                  body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('BulkPortin', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Order could not be processed and no order ID was created.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the information associated with the specified port-in ID number.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def get_by_id(account_id,
                  orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'The indicated Bulk Port-in order could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # It is possible to change ("SUPP" in LNP terms) an existing Bulk Port-in
    # order.  This is done via a PUT or PATCH on the existing order-id.Since the
    # Bulk Portin order resource acts as a template for portin orders in DRAFT
    # status, any record can be changed at any time.The PUT will completely
    # replace the existing Bulk Portin order with the payload of the PUT.The
    # only valid value for the <ProcessingStatus> element in a PUT is 'DRAFT'
    # where 'DRAFT' is the default value.If the portin orders contained within
    # the Bulk Port are in DRAFT state, any field can be modified.  If any
    # portin order in the Bulk Port is in any other state, normal SUPP rules
    # apply, and the list of appropriate fields is smaller.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [BulkPortin] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_bulk_portins_order(account_id,
                                  orderid,
                                  body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('BulkPortin', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request. Invalid input.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The indicated Bulk Port-in order could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Delete Bulk Port-in order with subdending port-ins. Deleting a bulk
    # port-in allowed for 'DRAFT' state only.Deleting a bulk port-in will delete
    # all DRAFT port-ins associated with it.If a bulk port-in contains a
    # CANCELLED port-in (due to port decomposition finding non-portable
    # TNs),that port-in will be disassociated with the bulk port-in, but not
    # deleted.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def delete_bulk_portins_order(account_id,
                                  orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request. Bulk Port-in order not in DRAFT state.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The indicated Bulk Port-in order could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # It is possible to change ("SUPP" in LNP terms) an existing Bulk Port-in
    # order.  This is done via a PUT or PATCH on the existing order-id.Since the
    # Bulk Portin order resource acts as a template for portin orders in DRAFT
    # status, any record can be changed at any time.The PATCH will replace
    # elements of the referenced Bulk Portin order, but it will replace *only*
    # the records included in the request payload.  Other elements will remain
    # untouched.User may include delete attribute to whatever element which
    # causes deletion of that element.For example: <CustomerOrderId
    # delete="true"/> will cause CustomerOrderId to be removed.The only valid
    # values for the <ProcessingStatus> element in a PUT or PATCH are 'DRAFT' or
    # 'IN&lowbar;PROGRESS' where 'DRAFT' is the default value.<b>Changing the
    # &lt;ProcessingStatus&gt; to 'IN&lowbar;PROGRESS' will force all subtending
    # portins to to begin processing</b>. This is only valid if there are
    # subtending portins.Changing the fields in a Bulk Portin order will cause
    # the system to reapply all changed values to the ports contained in the
    # list of subtending portin orders.Note that if the portin orders contained
    # within the Bulk Port are in DRAFT state, any field can be modified.  If
    # any portin order in the Bulk Port is in any other state, normal SUPP rules
    # apply, and the list of appropriate fields is smaller.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [BulkPortinPatch] body Optional parameter: Example:
    # @return [Object] response from the API call
    def patch_bulk_portins_order(account_id,
                                 orderid,
                                 body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.patch(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('BulkPortin', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request. Invalid input.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The indicated Bulk Port-in order could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves a list of Port-in Orders that are all associated with the
    # identified Bulk Port-in.   This response is not paginated due to its
    # inherently limited size
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def get_portin_list(account_id,
                        orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}/portinlist'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # A PUT on a PortinList resource will cause replacement of the list of
    # Port-in orders associated with a Bulk Port-in.    This PUT will
    # *completely replace* the existing list of port-in orders associated with
    # the Bulk Port-in.  If all port-in orders in the list are not valid the PUT
    # request will fail, due to the potential for losing the port-in to Bulk
    # Port-in relationships for a range of port-in orders.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [BulkPortinList] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_portin_list(account_id,
                           orderid,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}/portinlist'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('PortinList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'There was an error - one or more of the port-in orders was' \
          ' invalid.  The response payload will indicate the' \
          ' errors that were detected, and no changes will be made' \
          ' to the list of portin orders associated with the bulk' \
          ' order.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves a list of all telephone numbers associated with a Bulk Portin.  
    # This response is not paginated due to its inherently limited size
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @return [Object] response from the API call
    def get_bulk_tn_list(account_id,
                         orderid)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}/tnlist'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # A PUT on a TnList resource causes the decomposition of that list of TNs
    # into individual port-in orders that comply with the rules for atomic
    # ports.  The result is the creation of a set of port-in orders, with TNs
    # associated with each order.  The response payload indicates the TNs that
    # were successfully decomposed, and the TNs that could not be ported. The
    # response payload contains three optional elements:<ul><li>the
    # 'ValidTnList' - a collection of telephone numbers that can be
    # ported</li><li>the 'NonPortableTnList' - a collection of telephone numbers
    # that cannot be ported, and </li><li>the 'InvalidTnList' - a collection of
    # any strings that were submitted as telephone numbers, but that are not
    # syntactically valid</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [BulkTnList] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_populate_bulk_order(account_id,
                                   orderid,
                                   body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/bulkportins/{orderid}/tnlist'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('TnList', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The TN List payload was malformed, and the list could not be' \
          ' processed.  No response payload is returned.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the information associated with the specified port-in ID number.
    # Note: For users of Enterprise Telephony accounts, AlternateSpid,
    # LosingCarrierSPID, LosingCarrierName, and LosingCarrierIsWireless, are
    # omitted from the success output.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [PortinLosingCarrierResponse] response from the API call
    def get_update_tn_activation_status(account_id,
                                        order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'PortinLosingCarrierResponse',
                                   PortinLosingCarrierResponse)
      )
    end

    # Updates the information associated with the specified LSR.  This is also
    # used to cancel an order, by changing the order status field to cancelled. 
    # This is the only case where the status can be changed, and when this is
    # done, all other fields are left as they were prior to the cancellation. 
    # Please see the example below.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] orderid Required parameter: Example:
    # @param [LsrOrderPayload] body Optional parameter: Example:
    # @return [LsrOrderResponse] response from the API call
    def update_lsr_order(account_id,
                         orderid,
                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lsrorders/{orderid}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderid' => { 'value' => orderid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('LsrOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Validation error occurred.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Requested lsr not found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'LsrOrderResponse',
                                   LsrOrderResponse)
      )
    end

    # Retrieve the status (activated or not activated) of TNs associated with
    # the customer activated (triggered) order. <br><br>At this time all phone
    # numbers associated with a PON will be activated at the same time.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [TnActivationStatusResponse] response from the API call
    def retrieve_tn_activation_status(account_id,
                                      order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderId}/activationStatus'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Return a 400 error if the port-in Order is not in FOC status, or' \
          ' if not executed on the day of FOC or within the delay' \
          ' interval.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Return a 404 if the Port-in Order is missing, or if the' \
          ' activation is complete, and thus the ActivationStatus' \
          ' resource has been erased.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ActivationStatusResponse',
                                   TnActivationStatusResponse)
      )
    end

    # Sets the activation time for the port-in order.  <br> <br>This API call is
    # used to set the Activation time of the customer activated (triggered)
    # port.<ul><li>If the time is in the past all of the TNs in the port-in
    # request will be activated 'immediately'.</li><li>For automated on-net
    # port-ins, if the time is within three days after the approved FoC date,
    # the auto-activation time for the port will be set to that
    # time.</li><li>For automated off-net port-ins, if the date matches the
    # actual FOC date and the time is between 6:00 AM ET and 10:00 PM ET, the
    # auto-activation time for the port will be set to that time.</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [TnActivationStatus] body Optional parameter: Example:
    # @return [TnActivationStatusResponse] response from the API call
    def update_tn_activation_status_1(account_id,
                                      order_id,
                                      body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/portins/{orderId}/activationStatus'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ActivationStatus', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Not Found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ActivationStatusResponse',
                                   TnActivationStatusResponse)
      )
    end

    # A PUT on the filename will update / replace the identified file id.  The
    # format of the PUT is identical to that of the POST.<br>Header settings
    # typical of a valid upload are...<br><code>Host: api.inetwork.com
    # <br>Authorization: Basic xxxxxxxxxxxxxxxxxxxx== <br>Content-Type:
    # application/pdf <br>Accept: */* <br>Accept-Encoding: gzip, deflate
    # <br>Accept-Language: en-US,en;q=0.8 <br>Cache-Control: no-cache <br>   
    # <br>----WebKitFormBoundaryE19zNvXGzXaLvS5C <br>Content-Disposition:
    # form-data; name="george"; filename="Bandwidth Dashboard.pdf"
    # <br>Content-Type: application/pdf <br>    <br>   
    # <br>----WebKitFormBoundaryE19zNvXGzXaLvS5C <br></code>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [String] file_name Required parameter: Example:
    # @param [Object] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_file_direct(account_id,
                           order_type,
                           order_id,
                           file_name,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/loas/{fileName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'fileName' => { 'value' => file_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 indicates that the requested upload failed.',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'A 404 indicates that the file was not available for replacement.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Deletes the file associated with the order
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [String] file_name Required parameter: Example:
    # @return [Object] response from the API call
    def delete_file(account_id,
                    order_type,
                    order_id,
                    file_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/loas/{fileName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'fileName' => { 'value' => file_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'a 404 indicates that the indicated file was not found in' \
          ' conjunction with the order id.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # POSTing to the /loas resource will enable the upload of the file.  The key
    # attribute to the POST is ensuring that the headers are correctly set to
    # support the file upload.<br>    <br>Header settings typical of a valid
    # upload are...<br>    <br><code>Host: api.inetwork.com <br>Authorization:
    # Basic xxxxxxxxxxxxxxxxxxxx== <br>Content-Type: application/pdf <br>Accept:
    # */* <br>Accept-Encoding: gzip, deflate <br>Accept-Language: en-US,en;q=0.8
    # <br>Cache-Control: no-cache <br>   
    # <br>----WebKitFormBoundaryE19zNvXGzXaLvS5C <br>Content-Disposition:
    # form-data; name="george"; filename="Bandwidth Dashboard.pdf"
    # <br>Content-Type: application/pdf <br>    <br>   
    # <br>----WebKitFormBoundaryE19zNvXGzXaLvS5C <br></code>
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [File | UploadIO] body Optional parameter: Example:
    # @return [Object] response from the API call
    def upload_file_direct(account_id,
                           order_type,
                           order_id,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/loas'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      if body.is_a? FileWrapper
        body_wrapper = body.file
        body_content_type = body.content_type
      else
        body_wrapper = body
        body_content_type = 'application/octet-stream'
      end

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare form parameters.
      _parameters = {
        'body' => Faraday::UploadIO.new(
          body_wrapper,
          body_content_type
        )
      }
      _parameters = APIHelper.form_encode_parameters(_parameters)

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: _parameters
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'A 400 indicates that the requested upload failed.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [String] file_name Required parameter: Example:
    # @return [FileMetaDataPayload] response from the API call
    def get_file_meta_data(account_id,
                           order_type,
                           order_id,
                           file_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{accountId}/{orderType}/{orderId}/{fileName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'fileName' => { 'value' => file_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'FileMetaData',
                                   FileMetaDataPayload)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [String] file_name Required parameter: Example:
    # @param [FileMetaDataPayload] body Optional parameter: Example:
    # @return [FileMetaDataPayload] response from the API call
    def update_file_meta_data(account_id,
                              order_type,
                              order_id,
                              file_name,
                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{accountId}/{orderType}/{orderId}/{fileName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'fileName' => { 'value' => file_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('FileMetaData', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'FileMetaData',
                                   FileMetaDataPayload)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [String] file_name Required parameter: Example:
    # @return [FileMetaDataPayload] response from the API call
    def remove_file_meta_data(account_id,
                              order_type,
                              order_id,
                              file_name)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/{accountId}/{orderType}/{orderId}/{fileName}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'fileName' => { 'value' => file_name, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'FileMetaData',
                                   FileMetaDataPayload)
      )
    end

    # GET is used to retrieve all subscriptions for the account (including email
    # and callback subscriptions).The returned information reflects the
    # subscription as it has been defined, and for callback subscriptions will
    # reflect the status of the latest attempt to place the callback.  The
    # <Status> element will indicate if an error is being encountered when the
    # Bandwidth Dashboard API attempts to place the callback.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Optional parameter: Example:
    # @param [String] order_id Optional parameter: Example:
    # @param [String] event_type Optional parameter: Example:
    # @return [Object] response from the API call
    def get_subscriptions(account_id,
                          order_type: nil,
                          order_id: nil,
                          event_type: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/subscriptions'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'orderType' => order_type,
        'orderId' => order_id,
        'eventType' => event_type
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'if the account specified does not exist or is locked it will' \
          ' result in a bad request',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SubscriptionsResponse',
                                   String)
      )
    end

    # A POST on the /subscriptions resource is used to request a new
    # subscription for an account.<br>The POST creates a new e-mail or callback
    # subscription. A well-formed POST will create a subscription resource, and
    # return asubscription ID as part of the location header. The ID is used to
    # uniquely identify the subscription.The user should submit the desired
    # e-mail address for notifications and the frequency with which he wants to
    # get the updates:DAILY (for daily digests) or NONE (immediately after
    # events). OrderId is optional. If OrderId is specified only notifications
    # willbe sent for events related to that order. If OrderId is omitted,
    # notifications will be sent related to events of all orders of the
    # specified type.<br>For email subscriptions on order status notification
    # use a body like this:<br>```<Subscription>    <OrderType> [ portins |
    # portouts | orders | disconnects | dldas | lsrorders | e911s | tnoptions |
    # externalTns | lidb | bulkPortins| importtnorders | removeImportedTnOrders
    # | emergencyNotificationGroup | emergencyEndpointGroup] </OrderType> <!--
    # required -->    <OrderId> [ UUID ] </OrderId> <!-- optional, if provided
    # notifications will only be sent for events regarding this specific order,
    # if omitted notifications regarding events for all orders of the specified
    # type will be sent -->    <EmailSubscription>        <Email> [ email
    # address] </Email>        <DigestRequested> [ NONE | DAILY ]
    # </DigestRequested> <!-- required -->   
    # </EmailSubscription></Subscription>```For email subscriptions on event
    # notification use a body like this:<br>```<Subscription>    <EventType> [
    # MESSAGING_LOST ] </EventType> <!-- required -->    <EmailSubscription>    
    #    <Email> [ email address] </Email>        <DigestRequested> [ NONE |
    # DAILY ] </DigestRequested> <!-- required -->   
    # </EmailSubscription></Subscription>```For callback subscriptions on order
    # status notification use a body like this:<br>```<Subscription>   
    # <OrderType> [portins | portouts | orders | disconnects | dldas | lsrorders
    # | e911s | tnoptions | externalTns | lidb | importtnorders |
    # removeImportedTnOrders| emergencyNotificationGroup |
    # emergencyEndpointGroup] </OrderType> <!-- same rules and values as above
    # -->    <OrderId> [UUID]</OrderId> <!-- same rules and value as above -->  
    #  <CallbackSubscription>        <URL> [valid publically addressable URL]
    # </URL> <!-- the URL that notifications should get POSTed to, HTTPS is
    # highly recommended -->        <Expiry> [time in seconds] </Expiry> <!--
    # the number of seconds after which to expire this subscription -->       
    # <CallbackCredentials> <!-- optional, but recommended; these credentials
    # will be used to when authenticating with the notification receiving server
    # -->            <BasicAuthentication> <!-- optional, the endpoint may be
    # secured with BASIC auth -->                <Username> [username]
    # </Username> <!-- max 100 characters -->                <Password>
    # [password] </Password> <!-- the password will be stored encrypted and
    # never returned via the API -->            </BasicAuthentication>          
    #  <!-- optional, a BASE64 encoded public key matching the notification
    # receiving server -->            <PublicKey>LS0tLS1CRUdJTiBDRVJUSUZJ [...]
    # kQgQ0VSVElGSUNBVEUtLS0tLQ0K</PublicKey>        </CallbackCredentials>   
    # </CallbackSubscription></Subscription>```For callback subscriptions on
    # event notification use a body like this:<br>```<Subscription>   
    # <EventType> [ MESSAGING_LOST ] </EventType> <!-- required -->   
    # <CallbackSubscription>        <URL> [valid publically addressable URL]
    # </URL> <!-- the URL that notifications should get POSTed to, HTTPS is
    # highly recommended -->        <Expiry> [time in seconds] </Expiry> <!--
    # the number of seconds after which to expire this subscription -->       
    # <CallbackCredentials> <!-- optional, but recommended; these credentials
    # will be used to when authenticating with the notification receiving server
    # -->            <BasicAuthentication> <!-- optional, the endpoint may be
    # secured with BASIC auth -->                <Username> [username]
    # </Username> <!-- max 100 characters -->                <Password>
    # [password] </Password> <!-- the password will be stored encrypted and
    # never returned via the API -->            </BasicAuthentication>          
    #  <!-- optional, a BASE64 encoded public key matching the notification
    # receiving server -->            <PublicKey>LS0tLS1CRUdJTiBDRVJUSUZJ [...]
    # kQgQ0VSVElGSUNBVEUtLS0tLQ0K</PublicKey>        </CallbackCredentials>   
    # </CallbackSubscription></Subscription>```The credentials used to impose
    # security on the callbacks are defined in the <CallbackCredentials>
    # element.  The Basic authentication is straightforward, but the <PublicKey>
    # requires a little more explanation.  Please see the document to the left
    # on Mutual Authentication for CallBacks.<p>When status changes on an order
    # that had been subscribed to with a callback subscription (order update,
    # note added to order), the following payloadwill be POSTed to the URL of
    # the callback subscription.<br>More detail can be found in the API
    # documentation for the fictitious endpoint /callbacks```xml<Notification>  
    #  <SubscriptionId>...</SubscriptionId>    <OrderType>portins | portouts |
    # orders | disconnects | dldas | lsrorders | e911s| tnoptions | externalTns
    # | lidb | importtnorders | removeImportedTnOrders </OrderType>   
    # <OrderId>...</OrderId>    <!-- for order update events -->   
    # <Status>COMPLETE | FAILED | PARTIAL | EXCEPTION ... </Status>    <!-- for
    # order update events -->    <Message>...</Message>    <!-- for note events
    # -->    <Note>...</Note>    <!-- for portins/portouts/orders/disconnects
    # OrderTypes -->    <CompletedTelephoneNumbers>        <TelephoneNumber> ...
    # </TelephoneNumber>        <!-- ... -->   
    # </CompletedTelephoneNumbers></Notification>```When a event happens that
    # had been subscribed to with a callback subscription (messaging lost,
    # messaging gained etc.), the following payloadwill be POSTed to the URL of
    # the callback subscription.<br>More detail can be found in the API
    # documentation for the fictitious endpoint /callbacks```xml<Notification>  
    #  <SubscriptionId>...</SubscriptionId>   
    # <EventType>MESSAGING_LOST</EventType>    <CompletedTelephoneNumbers>      
    #  <TelephoneNumber>9192345678</TelephoneNumber>       
    # <TelephoneNumber>9192345679</TelephoneNumber>   
    # </CompletedTelephoneNumbers></Notification>```
    # @param [Integer] account_id Required parameter: Example:
    # @param [Subscription] body Optional parameter: Example:
    # @return [SubscriptionResponse] response from the API call
    def create_subscription(account_id,
                            body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/subscriptions'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Subscription', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'if the account specified does not exist or is locked it will' \
          ' result in a bad request',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'if the subscription validation failed (e.g. invalid URL, invalid' \
          ' expiration date, invalid public key)',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'if the subscription for this subscription target already exits it' \
          ' will result in a CONFLICT response',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SubscriptionResponse',
                                   SubscriptionResponse)
      )
    end

    # Retrieves the information associated with the subscription ID.The returned
    # information reflects the subscription as it has been defined, and for
    # callback subscriptions will reflect the status of the latest attempt to
    # place the callback.  The <status> element will indicate if an error is
    # being encountered when the Bandwidth Dashboard API attempts to place the
    # callback.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] subscription_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_subscription(account_id,
                         subscription_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/subscriptions/{subscriptionId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'subscriptionId' => { 'value' => subscription_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SubscriptionsResponse',
                                   String)
      )
    end

    # Updates the subscription. This can be be used to update various values
    # (expiry, email address, url, credentials...).Note that the initial state
    # changes for an order may happen very quickly, so subscribing to anorder
    # once the system creates it needs to account for the fact that the initial
    # state may bedifferent based on timing factors. It is recommended that the
    # application creating thesubscription check the order status after the
    # subscription is created to ensure the correct initialcondition. <br>The
    # same rules around valid or possible values as for POSTs apply.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] subscription_id Required parameter: Example:
    # @param [Subscription] body Optional parameter: Example:
    # @return [SubscriptionResponse] response from the API call
    def update_subscription(account_id,
                            subscription_id,
                            body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/subscriptions/{subscriptionId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'subscriptionId' => { 'value' => subscription_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Subscription', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Subscription values failed validation',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Subscription does not exist',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SubscriptionResponse',
                                   SubscriptionResponse)
      )
    end

    # Deletes the specified subscription. Note that deleting subscriptions is
    # only supported on a one-by-one basis.Deleting all subscriptions associated
    # with an order requires GETting all of those subscriptions, then deleting
    # them one by one.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] subscription_id Required parameter: Example:
    # @return [SubscriptionResponse] response from the API call
    def delete_subscription(account_id,
                            subscription_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/subscriptions/{subscriptionId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'subscriptionId' => { 'value' => subscription_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'subscription does not exist',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SubscriptionResponse',
                                   SubscriptionResponse)
      )
    end

    # Import a large number of previously ported or otherwise acquired numbers
    # into the accountThe various parameters in the importToAccount payload
    # are...        <table style="text-align: left; width: 80%;"        
    # border="1" cellpadding="2" cellspacing="2">          <thead>           
    # <tr>              <th>Parameter</th><th>Description</th>            </tr> 
    #         </thead>          <tbody>            <tr>             
    # <td>accountid</td>              <td>The numerical Account ID assigned to
    # the Account.</td>            </tr>            <tr>             
    # <td>SiteId</td>              <td>The ID of the Site that the set of TNs is
    # to be associated with. </td>            </tr>            <tr>             
    # <td>PeerId</td>              <td>The ID of the SIP Peer that the set of
    # TNs is to be associated with. (optional) </td>            </tr>           
    # <tr>              <td>BatchId</td>              <td>A user-chosen id for
    # the batch of phone numbers.  This Batch ID can span multiple number
    # submissions.  Up to 10 alphanumeric characters.  If  the submission is not
    # intended to be grouped into a batch of submissions then the Batch ID must
    # be globally unique.  <b>It is recommended that the batch ids be globally
    # unique, and that imports not be grouped together in batches by use of a
    # common batch id.</b></td>            </tr>            <tr>             
    # <td>BatchSize</td>              <td>The number of TNs in the batch,
    # aggregated across all of the orders in the batch. This total spans API
    # Calls, so if 3 calls are necessary to import 15000 numbers, this value
    # would be 15000.  It is recommended to use a batch size equal to the number
    # of telephone numbers in the API call, and use a different batch name for
    # each API call - essentially limiting a batch to a single API call.</td>   
    #         </tr>            <tr>              <td>VendorName</td>            
    #  <td>The vendor that owns the number that is being ported in.  If the
    # number is manually ported to a partners network then this would reflect
    # that partner</td>            </tr>            <tr>               
    # <td>BillingType</td>                <td>Type of billing rules to be
    # applied. Possible values... NOCHARGE, PORTIN, NEWNUMBER, PROJECTPORT.</td>
    #            </tr>            <tr>                <td>NumberFormat</td>     
    #           <td>Format of TNs to import. Optional parameter. Possible
    # values... 10D, E164, USMOBILESC.</td>            </tr>            <tr>    
    #          <td>TelehoneNumberList</td>              <td>List of TNs to
    # import - limited to 5000 Telephone Numbers.</td>            </tr>         
    #   <tr>              <td>TnAttributes</td>              <td>List of phone
    # number attributes to be assigned. Optional parameter. Possible values:
    # "Protected".</td>            </tr>            <tr>            
    # <td>InitialStatus</td>             <td>TN status that be assigned to
    # imported telephone numbers. Required existence of "Protected" TnAttribute.
    # Possible values: "Available". </td>            </tr>          </tbody>    
    #    </table>
    # @param [Integer] accountid Required parameter: Example:
    # @param [ImportToAccountNumberOrder] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_import_to_account_order(accountid,
                                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountid}/importToAccount'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountid' => { 'value' => accountid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ImportToAccountNumberOrder',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Create a Disconnect order, and disconnect the numbers listed in the
    # disconnect order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [DisconnectTelephoneNumberOrder] body Optional parameter:
    # Example:
    # @return [Object] response from the API call
    def create_disconnect_number_order(account_id,
                                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/disconnects'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml(
          'DisconnectTelephoneNumberOrder', body
        )
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Response - there were errors in evaluating the body of the' \
          ' request.Potential errors include: <ul>  <li> Protected' \
          ' attribute is invalid. Valid values: TRUE, FALSE,' \
          ' UNCHANGED.</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieves the information associated with the specified port-in ID number.
    # Note: For users of Enterprise Telephony accounts, AlternateSpid,
    # LosingCarrierSPID, LosingCarrierName, and LosingCarrierIsWireless, are
    # omitted from the success output.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [AdminParametersResponse] response from the API call
    def get_admin_parameters(account_id,
                             order_type,
                             order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AdminParametersResponse',
                                   AdminParametersResponse)
      )
    end

    # It is possible to change ("SUPP" in LNP terms) an existing LNP order. 
    # This is done via a PUT on the existing order-id.Since many of the entries
    # in an LNP Order cannot be changed after the initial order is placed the
    # PUT on a porting order-id does *not* require that the full order payload
    # is included.<br/>If SUPP is done to <strong>draft</strong> portin no
    # validations will be applied except validation of tn list if at least 1 tn
    # is provided.Items that can be included in a SUPP request
    # include:<ul><li>CustomerOrderId</li><li>RequestedFocDate</li><li>BillingTe
    # lephoneNumber</li><li>NewBillingTelephoneNumber</li><li>AccountNumber</li>
    # <li>PinNumber</li><li>TnAttributes elements</li><li>Subscriber elements,
    # including the subscriber type, the name elements, and the street address
    # elements.  See the discussion below on
    # ResetAddressFields</li><li>SiteId</li><li>PeerId</li><li>PartialPort,
    # and</li><li>LoaAuthorizingPerson</li><li>ListOfPhoneNumbers</li><li>Trigge
    # red</li><li>Immediately</li></ul>Note: If the order ProcessingStatus is
    # DRAFT, the rules about what can be changed are much more relaxed.
    # Validation is performed when the ProcessingStatus is changed from DRAFT to
    # SUBMITTED.<p>The AltSpid element can be modified if it is not configured
    # at the system level.<p>List of phone numbers can be modified only for
    # Automated on-net port type.<p><b>ProcessingStatus</b> - you can only
    # provide this field with a value of SUBMITTED and only if the current
    # ProcessingStatus of the port-in is DRAFT.<p><b>ResetAddressFields -</b> As
    # stated above the general approach to handling <i>this</i> API call is to
    # replace the elements included in the request body, and leave other
    # preexisting elements in an unmodified condition.  This is typical of a
    # PATCH method, but because of our commitment to backwards compatibility we
    # have elected not to "Fix" this behavior.As a result, providing only a few
    # fields in the street address will result in an update to just those
    # fields. This prevents removal of an element of the address.  The
    # ResetAddressFields element is provided to resolve this issue.  The default
    # setting of 'false' is to consistency with the initial implementation.The
    # recommendation is to replace the entire street address.  This ensures that
    # you are enforcing the street address content of the port-in order.  As
    # part of this recommendation the ResetAddressFields element should be set
    # to true, which will force the street address to be exactly what you
    # specified in the payload.<br> <br> When a port-in is being processed by
    # off-net partner Level 3 (you can tell this because /lnpchecker indicates a
    # Port Type of AUTOMATEDOFFNET), the rules for what can be changed in a SUPP
    # operation are more restrictive. If the order has NOT yet received FOC, you
    # may change the following:<ul>  <li>RequestedFocDate</li> 
    # <li>BillingTelephoneNumber</li>  <li>SubscriberType</li>  <li>Subscriber
    # name elements or BusinessName, provided that SubscriberType is
    # provided</li></ul>After FOC has been received, only RequestedFocDate may
    # be changed.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [AdminParametersPayload] body Optional parameter: Example:
    # @return [AdminParametersResponse] response from the API call
    def update_admin_parameters(account_id,
                                order_type,
                                order_id,
                                body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('AdminParameters', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'List of telephone numbers cannot be changed due to validation' \
          ' errors.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AdminParametersResponse',
                                   AdminParametersResponse)
      )
    end

    # If portin is in DRAFT state the order will be deleted. Otherwise the call
    # simply places the existing order in a cancelled state.Note that only a
    # pending port-in order can be cancelled; if the order was previously
    # cancelled or completed, then a DELETE will not be possible.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [AdminParametersResponse] response from the API call
    def remove_admin_parameters(account_id,
                                order_type,
                                order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Order id is invalid, order does not exist or the port-in order is' \
          ' already processed, and therefore cannot be deleted.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'AdminParametersResponse',
                                   AdminParametersResponse)
      )
    end

    # This link is used for configuring multiple telephone numbers with specific
    # attributes:<br/>CNAM, NumberFormat, RPIDFormat, RewriteUser, CallForward,
    # Protected and Sms.<br/>There are some possible attribute values:<ul><li>
    # TelephoneNumber - [ 10digit ] </li><li> CallingNameDisplay - [ on | off |
    # <i>unchanged</i> | <i>systemdefault</i> ] </li><li> NumberFormat - [
    # 10digit | 11digit | e164 | <i>unchanged</i> | <i>systemdefault</i> ]
    # </li><li> RPIDFormat - [ 10digit | 11digit | e164 | <i>unchanged</i> |
    # <i>systemdefault</i> ] </li><li> RewriteUser - [ string | <i>unchanged</i>
    # | <i>systemdefault</i>] </li><li> CallForward - [ 10digit |
    # <i>unchanged</i> | <i>systemdefault</i>] </li><li> Protected - [ true |
    # false | <i>unchanged</i> | <i>systemdefault</i>] </li><li> Sms - [ on |
    # off | <i>unchanged</i>] </li></ul>Where:<ul><li type="square">
    # <i>systemdefault</i> - implies that the element profile value should be
    # removed so that the TN changes back to the default system
    # behavior;</li><li type="square"> <i>unchanged</i> - the value should
    # remain unchanged - implies a read before write model.</li><li
    # type="square"><u>Leaving the element out of the payload is equivalent to
    # <i>unchanged</i>.</u></li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [LineOptionOrderPayload] body Optional parameter: Example:
    # @return [LineOptionOrderResponse] response from the API call
    def create_line_option_order(account_id,
                                 body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/lineoptionorders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('LineOptionOrder', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Possible errors in response: <li> <li> 50xx "Telephone number is' \
          ' invalid."  </li><li> 50xx "Telephone number is not' \
          ' available on the system."    </li><li> 50xx "Duplicate' \
          ' telephone number."    </li><li> 50xx "Telephone number' \
          ' is required."       </li><li> 50xx "Telephone number' \
          ' is not available."    </li><li> 50xx "There is an' \
          ' issue with telephone number. Please contact Customer' \
          ' Service."    </li><li> 50xx "There are no valid' \
          ' telephone numbers."     </li><li> 50xx "Account has no' \
          ' \'CNAM\'/ \'CallForward\' product feature."     ' \
          ' </li><li> 50xx "CallingNameDisplay \'--\' is invalid.' \
          ' Valid values are: on, off, unchanged, systemdefault."' \
          ' </li><li> 50xx "Call Forwarding number \'--\' is not a' \
          ' valid 10-digit telephone number."     </li><li> 50xx' \
          ' "Number Format \'--\' is invalid."     </li><li> 50xx' \
          ' "Rewrite User \'--\' is invalid."     </li><li> 50xx' \
          ' "RPID Format \'--\' is invalid."      </li><li> 13xxx' \
          ' "Protected attribute \'--\' is invalid. Valid values' \
          ' are: true,  false,unchanged, systemdefault." </li><li>' \
          ' 13xxx "Toll free numbers are not candidates for' \
          ' Protected status." </li><li> 13xxx "Non-Tier-0 numbers' \
          ' are not candidates for Protected status." </li></ul>',
          _response
        )
      elsif _response.status_code == 401
        raise APIException.new(
          'If customer doesn\'t have a permissions for this link (required' \
          ' role: ROLE_API_CNAMLIDB), this error can appear       ' \
          '             ',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'LineOptionOrderResponse',
                                   LineOptionOrderResponse)
      )
    end

    # <span>A POST creates a request for Telephone Numbers</span><br>A POST on
    # the /orders resource is used to request that the system provide one or
    # more TNs for use by the account.  The post creates a new number order
    # record to preserve the request, as well as the response of the Bandwidth
    # Dashboard API to the request.  A well-formed POST on the /orders resource
    # will create an order record, and return an order-id string that can be
    # used to uniquely identify the new number order request.  The details of
    # success and failure of the request for TNs will be preserved and linked to
    # the returned order id.<br><br>The order-id is returned in the Location
    # Header, allowing the API user immediate access to the order.<br><br>There
    # are multiple ways that new telephone numbers can be requested.  The
    # various request payloads are documented below. <br><br>Common values in
    # <b>all</b> request payloads include: <br><table>    <tr>       
    # <th>Parameter</th>        <th>Description</th>    </tr>    <tr>       
    # <td>Quantity</td>        <td>The desired quantity of requested numbers.
    # values range from 1-5000. If no quantity is specified, the default of 5000
    # is returned.</td>    </tr>    <tr>        <td>name</td>        <td>The
    # name of the order. Max length restricted to 50 characters.</td>    </tr>  
    #  <tr>        <td>CustomerOrderId</td>        <td>Optional value for Id set
    # by customer. Only alphanumeric values, dashes and spaces are allowed. Max
    # length is 40 characters.</td>    </tr>    <tr>        <td>SiteId</td>     
    #   <td>The ID of the Site that the SIP Peer is to be associated with.</td> 
    #   </tr>    <tr>        <td>PeerId</td><td>The ID of the SIP Peer that the
    # telephone numbers are to be assigned to.</td>    </tr>    <tr>       
    # <td>PartialAllowed</td>        <td>By default all order submissions are
    # fulfilled partially. Setting the PartialAllowed to false would trigger the
    # entire order to be fulfilled (any error ecnountered such as 1 TN not being
    # available would fail all TNs in the order)<br>            By default, this
    # value is set to false</td>    </tr>    <tr>       
    # <td>BackOrderRequested</td>        <td>BackOrderRequested will indicate to
    # the system that if the entire quantity of numbers is not available on the
    # first attempt to fill the new number order, the request will be repeated
    # periodically until the request is successful or cancelled. Setting the
    # parameter to true indeicated a desire to backorder numbers if the entire
    # quantity is not available</td>    </tr></table><p>The following POST
    # payload elements are not common to all orders.  They are specific to one
    # or more types of orders:<br><table>    <tr>       
    # <th>Parameter</th><th>Description</th>    </tr>    <tr>       
    # <td>TelephoneNumberList</td><td>A list of telephone numbers to order</td> 
    #   </tr>    <tr>        <td>AreaCode</td><td>Allowed ranged: [2-9] for the
    # first digit and [0, 9] for both the second and third digits.</td>    </tr>
    #    <tr>        <td>RateCenter</td><td>A text Rate Center name.  Must be
    # combined with State information</td>    </tr>    <tr>       
    # <td>State</td><td>The two-letter abbreviation of the state</td>    </tr>  
    #  <tr>        <td>City</td><td>The name of the city that the Ordered
    # telephone numbers should apply to</td>    </tr>    <tr>       
    # <td>Zip</td><td>A five-digit (XXXXX) or nine-digit (XXXXX-XXXX) format
    # value.</td>    </tr>    <tr>        <td>Lata</td><td>A maximum five-digit
    # (XXXXX) numeric format.</td>    </tr>    <tr>       
    # <td>EnableLCA</td><td>If set to true, local calling access numbers will be
    # returned for Rate Center, NPA-NXX and NPANXXX orders if numbers are not
    # available for the given criteria. Default is true.</td>    </tr>    <tr>  
    #      <td>Npa-Nxx or Npa-Nxxxx with EnableLCA</td><td>NpaNxx combination to
    # be searched.<br>Valid Npa values:  [2-9] for the first digit, and [0-9]
    # for both the second and third digits.<br>Valid Nxx values: [2-9] for the
    # first digit, and [0-9] for both the second and third digits.<br>Valid
    # Xxvalues [0-9].<br><br>if set to true, enables the ability to get local
    # calling access numbers if numbers are not available for the given
    # criteria.</td>    </tr>    <tr>        <td>LocalVanity</td><td>A text
    # string used to request a regular vanity number. Valid range is between 4
    # and 7 alphanumeric characters.</td>    </tr>    <tr>       
    # <td>EndsIn</td><td>Intended to use with LocalVanity only. The parameter
    # value is true or false. If set to true, the search will look for only
    # numbers which end in specified LocalVanity, otherwise LocalVanity sequence
    # can be met anywhere in last 7 number digits. The default is false.</td>   
    # </tr>    <tr>        <td>TollFreeVanity</td><td>A text string used to
    # request a toll free vanity number. Valid range is between 4 and 7
    # alphanumeric characters.</td>    </tr>    <tr>       
    # <td>TollFreeWildCardPattern</td><td>A 3-digit wild card pattern for
    # specifying toll free prefixes, comprised of 8 followed by two stars, a
    # digit and a star or two digits</td>    </tr>    <tr>       
    # <td>ReservationIdList</td><td>If a telephone number or numbers have been
    # previously reserved, the ReservationIdList provides the IDs necessary to
    # release the numbers.  This only applies to reserved numbers - if no
    # reservation has been placed on the numbers this list is not required.</td>
    #    </tr>    <tr>        <td>TnAttributes</td>        <td>Attributes to be
    # assigned to the telephone number. Optional parameter. Possible values:
    # "Protected"</td>    </tr></table><br><br><b>Putting it all
    # together</b><br><br>The request to order numbers is performed via a POST
    # to the /orders resource.  As indicated above, the payload of this POST
    # varies depending on the type of search that is to be performed for the
    # numbers, with a unique payload element used to indicate each different
    # order type. <br><br>The unique components of the payload are described in
    # the table below.  These are combined with the common payload components in
    # the first table above to create a full order payload.  Some complete
    # payloads are captured in the examples. <br><br>The generic response
    # payload is also captured below: <br><table style="text-align: left; width:
    # 100%;" border="1" cellpadding="2" cellspacing="0">    <tbody>       
    # <tr><th>The 'wrapper' Request Payload'</th></tr>        <tr>           
    # <td>                <pre>&lt;?xml version=&quot;1.0&quot;
    # encoding=&quot;UTF-8&quot;?&gt;&lt;Order&gt;   
    # &lt;CustomerOrderId&gt;SJM00001&lt;/CustomerOrderId&gt;    &lt;!--       
    # There are various types of orders, all of which are submitted in the
    # 'xxxOrderType'        element of the Order Request payload.  The 'Payload
    # Segment' elements described in        the table below, which describe the
    # encoding for the various order types, replace        this comment to
    # create a complete payload that includes the order type and the       
    # common elements.        Take a look at the example payloads as well.   
    # --&gt;    &lt;SiteId&gt;202&lt;/SiteId&gt;   
    # &lt;PeerId&gt;518824&lt;/PeerId&gt;    &lt;TnAttributes/&gt;&lt;/Order&gt;
    #                </pre>            </td>        </tr>   
    # </tbody></table><table style="text-align: left; width: 100%;" border="1"
    # cellpadding="2" cellspacing="0">  <tbody>    <col width="60%">    <col
    # width="40%">    <tr>      <th>Payload segment</th>     
    # <th>Description</th>    </tr>    <tr>      <td>     
    # <pre>&lt;ExistingTelephoneNumberOrderType&gt;   
    # &lt;TelephoneNumberList&gt;       
    # &lt;TelephoneNumber&gt;9193752369&lt;/TelephoneNumber&gt;       
    # &lt;TelephoneNumber&gt;9193752720&lt;/TelephoneNumber&gt;       
    # &lt;TelephoneNumber&gt;9193752648&lt;/TelephoneNumber&gt;   
    # &lt;/TelephoneNumberList&gt;    &lt;ReservationIdList&gt;       
    # &lt;ReservationId&gt;[GUID]&lt;/ReservationId&gt;       
    # &lt;ReservationId&gt;[GUID]&lt;/ReservationId&gt;   
    # &lt;/ReservationIdList&gt;&lt;/ExistingTelephoneNumberOrderType&gt;</pre> 
    #     </td>      <td>Order a set of numbers known to be available. <br>     
    # This often results if the numbers have been<br>      found using a
    # separate <b>availableNumbers</b> search<br>        If the numbers have
    # previously been reserved, <br>        a reservation id must be
    # included</td>    </tr>    <tr>      <td>     
    # <pre>&lt;AreaCodeSearchAndOrderType&gt;   
    # &lt;AreaCode&gt;617&lt;/AreaCode&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;&lt;/AreaCodeSearchAndOrderType&gt;</pre
    # >      </td>      <td>Allowed ranges ~ <br>      [2-9] for the first digit
    # and <br>      [0, 9] for both the second and <br>      third digits.</td> 
    #   </tr>    <tr>      <td>      <pre>&lt;RateCenterSearchAndOrderType&gt;  
    #  &lt;RateCenter&gt;RALEIGH&lt;/RateCenter&gt;   
    # &lt;State&gt;NC&lt;/State&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;&lt;/RateCenterSearchAndOrderType&gt;</p
    # re>      </td>      <td>Specify the Rate Center and <br> the State</td>   
    # </tr>    <tr>      <td>      <pre>&lt;NPANXXSearchAndOrderType&gt;   
    # &lt;NpaNxx&gt;919439&lt;/NpaNxx&gt;   
    # &lt;EnableTNDetail&gt;true&lt;/EnableTNDetail&gt;   
    # &lt;EnableLCA&gt;false&lt;/EnableLCA&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;&lt;/NPANXXSearchAndOrderType&gt;</pre> 
    #     </td>      <td>Specify the NpaNxx combination to be ordered.<br>     
    # Valid Npa values ~ [2-9] for the first digit,<br>      and [0-9] for both
    # the second and third digits.<br>      Valid Nxx values ~ [2-9] for the
    # first digit, <br>      and [0-9] for both the second and third digits.<br>
    #      A similar approach is viable for NPANXXXX.<br>      The EnableLCA
    # flag turns LCA search on or off.      </td>    </tr>    <tr>      <td>    
    #  <pre>&lt;TollFreeVanitySearchAndOrderType&gt;  
    # &lt;Quantity&gt;1&lt;/Quantity&gt;      
    # &lt;TollFreeVanity&gt;newcars&lt;/TollFreeVanity&gt;&lt;/TollFreeVanitySea
    # rchAndOrderType&gt;</pre>      </td>      <td>      Specify a Toll Free
    # Vanity search, where the <br>      numbers ordered match a specific
    # alphanumeric <br>      pattern between 4 and 7 characters long</td>   
    # </tr>    <tr>      <td>     
    # <pre>&lt;TollFreeWildCharSearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;   
    # &lt;TollFreeWildCardPattern&gt;8**&lt;/TollFreeWildCardPattern&gt;&lt;/Tol
    # lFreeWildCharSearchAndOrderType&gt;</pre>      </td>      <td>Specify the
    # Toll Free wild card pattern.<br>      to be ordered, comprised of 3 digits
    # beginning with '8'.<br>      Examples are 8**, 87*, etc.</td>    </tr>   
    # <tr>      <td>      <pre>&lt;StateSearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;   
    # &lt;State&gt;NC&lt;/State&gt;&lt;/StateSearchAndOrderType&gt;</pre>     
    # </td>      <td>Specify the State to be searched<br>for telephone
    # numbers</td>    </tr>    <tr>      <td>     
    # <pre>&lt;CitySearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt; 
    #   &lt;City&gt;RALEIGH&lt;/City&gt;   
    # &lt;State&gt;NC&lt;/State&gt;&lt;/CitySearchAndOrderType&gt;</pre>     
    # </td>      <td>Specify the City and State to be ordered from.</td>   
    # </tr>    <tr>      <td>      <pre>&lt;ZIPSearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;   
    # &lt;Zip&gt;27606&lt;/Zip&gt;&lt;/ZIPSearchAndOrderType&gt;</pre>     
    # </td>      <td>Specify the Zip Code to be ordered from.</td>    </tr>   
    # <tr>      <td>      <pre>&lt;LATASearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;      
    # &lt;Lata&gt;224&lt;/Lata&gt;&lt;/LATASearchAndOrderType&gt;</pre>     
    # </td>      <td>Specify the LATA to order <br> telephone numbers from.</td>
    #    </tr>    <tr>      <td>      <pre>&lt;CombinedSearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;    &lt;AreaCode&gt;617&lt;/AreaCode&gt;
    #    &lt;RateCenter&gt;RALEIGH&lt;/RateCenter&gt;   
    # &lt;State&gt;NC&lt;/State&gt;    &lt;NpaNxx&gt;919439&lt;/NpaNxx&gt;   
    # &lt;NpaNxxX&gt;9194391&lt;/NpaNxxX&gt;    &lt;Lata&gt;224&lt;/Lata&gt;   
    # &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;   
    # &lt;EnableLCA&gt;false&lt;/EnableLCA&gt;&lt;/CombinedSearchAndOrderType&gt
    # ;</pre>      </td>      <td>Specify the any combination of:<br>     
    # <ul><li>AreaCode</li><li>RateCenter</li><li>State</li><li>NpaNxx</li><li>N
    # paNxxX</li><li>Lata</li><li>City</li><li>Zip</li></ul>      <br>But with
    # following limitations:<ul>    <li>Parameters AreaCode, NpaNxx and
    # NpaNxxX<br>are mutually exclusive</li>    <li>LCA search is supported only
    # for<br>one of the following
    # criteria:<ul><ul><li>NpaNxx</li><li>NpaNxxX</li><li>RateCenter and
    # State</li></ul></li>    <li>If City or RateCenter is specified<br>then
    # State is required</li></ul>     
    # </td><tr><td><pre>&lt;CombinedSearchAndOrderType&gt;   
    # &lt;Quantity&gt;1&lt;/Quantity&gt;    &lt;AreaCode&gt;617&lt;/AreaCode&gt;
    #    &lt;LocalVanity&gt;newcars&lt;/LocalVanity&gt;   
    # &lt;EndsIn&gt;false&lt;/EndsIn&gt;&lt;/CombinedSearchAndOrderType&gt;</pre
    # ></td><td>    Specify AreaCode and LocalVanity to order telephone numbers
    # matching a specific alphanumeric pattern between 4 and 7 characters
    # long.<br>    <br>    Limitations:    <ul>    <li>AreaCode is always
    # required</li>    <li>No parameter combinations are allowed here</li>   
    # <li>This order type is unsupported with BackOrderRequested=true</li>   
    # </ul></td></tr><tr><td><pre> &lt;TnAttributes&gt;   
    # &lt;TnAttribute&gt;Protected&lt;/TnAttribute&gt;   
    # &lt;/TnAttributes&gt;</pre>        </td>        <td>Specify TnAttribute to
    # be assigned to the ordered telephone numbers.</td>      </tr>    </tr> 
    # </tbody></table><br> <br> Some examples of POST payloads for some orders
    # are below...
    # @param [Integer] accountid Required parameter: Example:
    # @param [Order] body Optional parameter: Example:
    # @return [Object] response from the API call
    def create_order_3(accountid,
                       body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountid}/orders'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountid' => { 'value' => accountid, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Order', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'One or more of the input parameters are invalid.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # With the introduction of Backorder capabilities, new number orders may
    # stay in backordered state while the order is filled.   While in this state
    # it is possible to update the modifiable fields in the record, as well as
    # to request that backorder processing of the order be ended.The fields that
    # can be updated are...<ul><li>The order name</li><li>The customer order
    # id</li><li>The backordered state.</li></ul>Specifying a &lt;CloseOrder&gt;
    # value of true will cancel the backorder request, leaving the currently
    # ordered numbers on the account.  No further numbers will be added to the
    # account as a result of the order.
    # @param [Integer] accountid Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [Order] body Optional parameter: Example:
    # @return [Object] response from the API call
    def update_order(accountid,
                     order_id,
                     body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountid}/orders/{orderId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountid' => { 'value' => accountid, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Order', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The request payload is invalid',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'The order-id cannot be found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # Retrieve the set of notes associated with an order.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @return [NotesResponse] response from the API call
    def get_order_notes(account_id,
                        order_type,
                        order_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/notes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'Notes', NotesResponse)
      )
    end

    # Updates the Notes resource by adding a note. Adding a note to a port-in
    # order causes a notification to be sent to Bandwidth Operations, so that
    # they may assist as necessary.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [Note] body Optional parameter: Example:
    # @return [NoteResponse] response from the API call
    def create_order_note(account_id,
                          order_type,
                          order_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/notes'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Note', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - the note has not been created because the payload' \
          ' is incomplete or in error.  An error payload is' \
          ' provided in the response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'NoteResponse',
                                   NoteResponse)
      )
    end

    # Updates single note by it's id.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] order_type Required parameter: Example:
    # @param [String] order_id Required parameter: Example:
    # @param [Integer] note_id Required parameter: Example:
    # @param [Note] body Optional parameter: Example:
    # @return [NoteResponse] response from the API call
    def update_order_note(account_id,
                          order_type,
                          order_id,
                          note_id,
                          body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{orderType}/{orderId}/notes/{noteId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'orderType' => { 'value' => order_type, 'encode' => false },
        'orderId' => { 'value' => order_id, 'encode' => false },
        'noteId' => { 'value' => note_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Note', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request - the note has not been updated because the payload' \
          ' is incomplete or in error.  An error payload is' \
          ' provided in the response.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'NoteResponse',
                                   NoteResponse)
      )
    end

    # Reserves a telephone number for a default time of 4 hours. A successful
    # reservation returns a location header that can be used to retrieve the
    # reservation at a later time.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Reservation] body Optional parameter: Example:
    # @return [ReservationResponse] response from the API call
    def create_reservation(account_id,
                           body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/TnReservation'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Reservation', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'The Telephone Number requested is not available.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReservationResponse',
                                   ReservationResponse)
      )
    end

    # Retrieves a TN reservation's information.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] reservation_id Required parameter: Example:
    # @return [ReservationResponse] response from the API call
    def get_reservation(account_id,
                        reservation_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/TnReservation/{reservationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'reservationId' => { 'value' => reservation_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReservationResponse',
                                   ReservationResponse)
      )
    end

    # Deletes a TN reservation.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] reservation_id Required parameter: Example:
    # @return [ReservationResponse] response from the API call
    def delete_reservation(account_id,
                           reservation_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/TnReservation/{reservationId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'reservationId' => { 'value' => reservation_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReservationResponse',
                                   ReservationResponse)
      )
    end

    # This API call retrieves information about the account indicated by the
    # Account ID.
    # @param [Integer] account_id Required parameter: Example:
    # @return [ReportsResponse] response from the API call
    def get_acct_reports(account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportsResponse',
                                   ReportsResponse)
      )
    end

    # A GET issued on a specific report (as identified by it's ID) will return
    # all of the details of that report, allowing the API user to create an
    # instance of that report.  Those details include:    <ul>        <li>The
    # report name</li>        <li>a description of the report in general
    # terms</li>        <li>a set of parameters that are used to provide
    # boundaries on the information that is provided. &nbsp;These parameters
    # contain</li>        <ul>            <li>The parameter name,</li>          
    #  <li>a&nbsp;description of the parameter,</li>            <li>a
    # declaration of whether it is required or not, </li>            <li>is
    # multiple vales allowed or not, </li>            <li>the type of the
    # parameter, which can be one of</li>                <ul>                   
    # <li>Account ID (autofilled)</li>                    <li>Site ID</li>      
    #              <li>SipPeer ID</li>                    <li>String</li>       
    #             <li>Integer</li>                    <li>Boolean</li>          
    #          <li>Enum, with a list of possible values.</li>               
    # </ul>            <li>the help info for describing parameter</li>          
    #  </ul>        </ul>    </ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] report_id Required parameter: Example:
    # @return [ReportResponse] response from the API call
    def get_acct_report(account_id,
                        report_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'reportId' => { 'value' => report_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A report template matching the provided ID could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportResponse',
                                   ReportResponse)
      )
    end

    # Retrieve report instances associated with a specific report, including the
    # up-to-date report generation status.
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] user_instances_only Optional parameter: Example:
    # @return [ReportInstancesResponse] response from the API call
    def get_acct_report_instances(report_id,
                                  account_id,
                                  user_instances_only: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}/instances'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'userInstancesOnly' => user_instances_only
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ReportInstancesResponse',
                                   ReportInstancesResponse)
      )
    end

    # POSTing to the instances resource of a specific report will create an
    # instance of that report that pulls from data that is filtered by the
    # supplied parameters.  Those parameter values must match the parameters
    # that are required as defined by the report, as provided by issuing a GET
    # on the report. <br><br>The sequence of events is essentially to...<ol>   
    # <li>issue a GET on the desired report/report-id to retrieve the parameter
    # and other details of the report</li>    <li>issue a POST on the
    # /report/report-id/instances resource, using the parameter information
    # retrieved in the initial call to define the data that is
    # needed</li></ol>The Location header will provide a link to the created
    # report instance.  Note that the report instance itself contains only the
    # metadata describing the instance.  A subsequent call to
    # /report/report-id/instances/instance-id/file must be made to actually
    # download the file.
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [ReportInstance] body Optional parameter: Example:
    # @return [ReportInstanceResponse] response from the API call
    def create_acct_report_instance(report_id,
                                    account_id,
                                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}/instances'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Instance', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request',
          _response
        )
      elsif _response.status_code == 503
        raise APIException.new(
          'Service Unavailable',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportInstanceResponse',
                                   ReportInstanceResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [Boolean] user_instances_only Optional parameter: Example:
    # @return [ReportInstancesResponse] response from the API call
    def get_acct_instances(account_id,
                           user_instances_only: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/instances'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'userInstancesOnly' => user_instances_only
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ReportInstancesResponse',
                                   ReportInstancesResponse)
      )
    end

    # A GET on the specific instance will retrieve report instance details,
    # including the current report instance status.  All of the information
    # required to understand the nature and limits of the reported data are
    # contained in the payload, including the general description information as
    # well as the list of parameters and the values assigned to those
    # parameters.
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] report_instance_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @return [ReportInstanceResponse] response from the API call
    def get_acct_report_instance(report_id,
                                 report_instance_id,
                                 account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}/instances/{reportInstanceId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'reportInstanceId' => { 'value' => report_instance_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A report template matching the provided ID could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportInstanceResponse',
                                   ReportInstanceResponse)
      )
    end

    # TODO
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] report_instance_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @param [ReportInstance] body Optional parameter: Example:
    # @return [ReportInstanceResponse] response from the API call
    def update_acct_report_instance(report_id,
                                    report_instance_id,
                                    account_id,
                                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}/instances/{reportInstanceId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'reportInstanceId' => { 'value' => report_instance_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('Instance', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportInstanceResponse',
                                   ReportInstanceResponse)
      )
    end

    # Retrieve report instance output file, if output is available.
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] report_instance_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @return [Object] response from the API call
    def get_acct_report_instance_file(report_id,
                                      report_instance_id,
                                      account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/reports/{reportId}/instances/{reportInstanceId}/file'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'reportInstanceId' => { 'value' => report_instance_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'A report instance matching the supplied identification' \
          ' information could not be found.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'ReportInstanceFileResponse', String)
      )
    end

    # TODO
    # @param [Integer] report_id Required parameter: Example:
    # @param [Integer] report_instance_id Required parameter: Example:
    # @param [Integer] account_id Required parameter: Example:
    # @return [ReportInstanceResponse] response from the API call
    def delete_acct_report_instance(report_id,
                                    report_instance_id,
                                    account_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/{reportId}/instances/{reportInstanceId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'reportId' => { 'value' => report_id, 'encode' => false },
        'reportInstanceId' => { 'value' => report_instance_id, 'encode' => false },
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'ReportInstanceResponse',
                                   ReportInstanceResponse)
      )
    end

    # Retrieves the phone numbers according to the input parameters
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] area_code Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxxx Optional parameter: Example:
    # @param [String] rate_center Optional parameter: Example:
    # @param [String] lata Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] zip Optional parameter: Example:
    # @param [String] toll_free_wild_card_pattern Optional parameter: Example:
    # @param [String] toll_free_vanity Optional parameter: Example:
    # @param [String] local_vanity Optional parameter: Example:
    # @param [Boolean] ends_in Optional parameter: Example:
    # @param [Boolean] enable_tn_detail Optional parameter: Example:
    # @param [Integer] quantity Optional parameter: Example:
    # @param [String] order_by Optional parameter: Example:
    # @param [String] protected Optional parameter: Example:
    # @param [Boolean] lca Optional parameter: Example:
    # @return [SearchResult] response from the API call
    def search_telephone_numbers(account_id,
                                 area_code: nil,
                                 npa_nxx: nil,
                                 npa_nxxx: nil,
                                 rate_center: nil,
                                 lata: nil,
                                 city: nil,
                                 state: nil,
                                 zip: nil,
                                 toll_free_wild_card_pattern: nil,
                                 toll_free_vanity: nil,
                                 local_vanity: nil,
                                 ends_in: nil,
                                 enable_tn_detail: nil,
                                 quantity: nil,
                                 order_by: nil,
                                 protected: nil,
                                 lca: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/availableNumbers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'areaCode' => area_code,
        'npaNxx' => npa_nxx,
        'npaNxxx' => npa_nxxx,
        'rateCenter' => rate_center,
        'lata' => lata,
        'city' => city,
        'state' => state,
        'zip' => zip,
        'tollFreeWildCardPattern' => toll_free_wild_card_pattern,
        'tollFreeVanity' => toll_free_vanity,
        'localVanity' => local_vanity,
        'endsIn' => ends_in,
        'enableTNDetail' => enable_tn_detail,
        'quantity' => quantity,
        'orderBy' => order_by,
        'protected' => protected,
        'LCA' => lca
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Invalid/missing input parameter',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SearchResult',
                                   SearchResult)
      )
    end

    # Retrieves a list of available Npa-Nxx telephone numbers.
    # @param [Integer] account_id Required parameter: Example:
    # @param [String] area_code Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [Integer] quantity Optional parameter: Example:
    # @return [SearchResultForAvailableNpaNxx] response from the API call
    def search_available_npa_nxx(account_id,
                                 area_code: nil,
                                 state: nil,
                                 quantity: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/availableNpaNxx'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'areaCode' => area_code,
        'state' => state,
        'quantity' => quantity
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'There are no phone numbers within the specified scope.',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SearchResultForAvailableNpaNxx',
                                   SearchResultForAvailableNpaNxx)
      )
    end

    # The Rate Centers API Call returns information about the Bandwidth CLEC
    # Network, including coverage data, indicating both the extent of on-net and
    # off-net coverage, as well as number availability, again from an on-net and
    # off-net perspective. The rules are as follows- <ul><li>If supported=true
    # is specified, then the coverage or availability is reported for the
    # Bandwidth CLEC only. </li><li>If supported=true is omitted or false, then
    # the coverage or availability is reported for the combination of the
    # Bandwidth CLEC and our partners </li><li>If available=true is specified,
    # then only Rate Centers in which we have available numbers are reported.
    # </li><li>If available is omitted or false then all Rate Centers within the
    # scope defined by supported will be returned. </li></ul>These rules apply
    # for both the /rateCenters and /cities API calls. <table border="1"
    # cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top" > </td> <td
    # valign="top" > Supported = true </td> <td valign="top" > Supported is
    # missing </td> </tr> <tr> <td valign="top" > available = true </td> <td
    # valign="top" > Available numbers within the Bandwidth CLEC network </td>
    # <td valign="top" > Available numbers within the Bandwidth CLEC network
    # combined with our partner networks </td> </tr> <tr> <td valign="top" >
    # available is missing </td> <td valign="top" > Coverage in the Bandwidth
    # CLEC </td> <td valign="top" > Coverage of the combined Bandwidth CLEC +
    # Partner networks </td> </tr> </tbody> </table>
    # @param [String] state Optional parameter: Example:
    # @param [Boolean] supported Optional parameter: Example:
    # @param [Boolean] available Optional parameter: Example:
    # @return [RateCenterSearchResults] response from the API call
    def search_rate_centers(state: nil,
                            supported: nil,
                            available: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/rateCenters'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'state' => state,
        'supported' => supported,
        'available' => available
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'RateCenterResponse',
                                   RateCenterSearchResults)
      )
    end

    # The Rate Centers and Cities API Calls return information about the
    # Bandwidth CLEC Network, including coverage data, indicating both the
    # extent of on-net and off-net coverage, as well as number availability,
    # again from an on-net and off-net perspective. The rules are as follows-
    # <ul><li>If supported=true is specified, then the coverage or availability
    # is reported for the Bandwidth CLEC only. </li><li>If supported is omitted
    # or false, then the coverage or availability is reported for the
    # combination of the Bandwidth CLEC and our partners </li><li>If
    # available=true is specified, then only Rate Centers in which we have
    # available numbers are reported. </li><li>If available is omitted or false,
    # then all Rate Centers within the scope defined by supported will be
    # returned. </li></ul>These rules apply for both the /rateCenters and
    # /cities API calls. <table border="1" cellpadding="0" cellspacing="0">
    # <tbody> <tr> <td valign="top" > </td> <td valign="top" > Supported = true
    # </td> <td valign="top" > Supported is missing </td> </tr> <tr> <td
    # valign="top" > available = true </td> <td valign="top" > Available numbers
    # within the Bandwidth CLEC network </td> <td valign="top" > Available
    # numbers within the Bandwidth CLEC network combined with our partner
    # networks </td> </tr> <tr> <td valign="top" > available is missing </td>
    # <td valign="top" > Coverage in the Bandwidth CLEC </td> <td valign="top" >
    # Coverage of the combined Bandwidth CLEC + Partner networks </td> </tr>
    # </tbody> </table>
    # @param [String] state Optional parameter: Example:
    # @param [Boolean] supported Optional parameter: Example:
    # @param [Boolean] available Optional parameter: Example:
    # @return [CitySearchResults] response from the API call
    def search_cities(state: nil,
                      supported: nil,
                      available: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/cities'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'state' => state,
        'supported' => supported,
        'available' => available
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'CityResponse',
                                   CitySearchResults)
      )
    end

    # The Covered Rate Centers API Call return information about the Bandwidth
    # CLEC Network, including coverage data, indicating both the extent of
    # on-net and off-net coverage, as well as number availability. The various
    # query parameters are summarized in the following table ... <table
    # border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top"
    # width="114"> <p><strong>Query Parameter</strong> </p> </td> <td
    # valign="top"> <p><strong>Description</strong> </p> </td> </tr> <tr> <td
    # valign="top" width="114"> <p>page </p> </td> <td valign="top"> <p>The
    # starting value for a paginated response. The default is 1 indicating the
    # first page of results. </p> </td> </tr> <tr> <td valign="top" width="114">
    # <p>size </p> </td> <td valign="top"> <p>The number of rate centers to
    # include in a paginated result payload. </p> </td> </tr> <tr> <td
    # valign="top" width="114"> <p>state </p> </td> <td valign="top"> <p>A 2
    # character State code </p> </td> </tr> <tr> <td valign="top" width="114">
    # <p>abbreviation </p> </td> <td valign="top"> <p>A rate center abbreviation
    # </p> </td> </tr> <tr> <td valign="top" width="114"> <p>name </p> </td> <td
    # valign="top"> <p>A rate center name </p> </td> </tr> <tr> <td valign="top"
    # width="114"> <p>zip </p> </td> <td valign="top"> <p>A 5 digit zip code
    # </p> </td> </tr> <tr> <td valign="top" width="114"> <p>city </p> </td> <td
    # valign="top"> <p>A City name </p> </td> </tr> <tr> <td valign="top"
    # width="114"> <p>lata </p> </td> <td valign="top"> <p>A 3 or 5 digit LATA
    # </p> </td> </tr> <tr> <td valign="top" width="114"> <p>tier </p> </td> <td
    # valign="top"> <p>A bandwidth coverage tier; a value from 0 to 5. </p>
    # </td> </tr> <tr> <td valign="top" width="114"> <p>npa </p> </td> <td
    # valign="top"> <p>A 3 digit NPA or Area Code </p> </td> </tr> <tr> <td
    # valign="top" width="114"> <p>npaNxx </p> </td> <td valign="top"> <p>6
    # digits NPA and NXX values </p> </td> </tr> <tr> <td valign="top"
    # width="114"> <p>npaNxxX </p> </td> <td valign="top"> <p>7 digits of NPA,
    # NXX and thousands block values. </p> </td> </tr> <tr> <td valign="top"
    # width="114"> <p>embed </p> </td> <td valign="top"> <p>One of the values
    # [ZipCodes, Cities, NpaNxxX, AvailableNumberCount,
    # LimitedAvailableNumberCount, LocalRateCenters]. <br> This repeatable query
    # parameter will force a list (or multiple lists) of the indicated data to
    # be provided in the response. For example if the payload should contain a
    # list of the Cities covered by the Rate Centers then embed=cities would be
    # included as a query parameter.<br> No filter parameters are supported if
    # <q>LocalRateCenters</q> is specified. In this case only <q>size</q>,
    # <q>page</q> and any other <q>embed</q> parameters are supported. </p>
    # </td> </tr> </tbody> </table>
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] name Optional parameter: Example:
    # @param [String] abbreviation Optional parameter: Example:
    # @param [String] state Optional parameter: Example:
    # @param [String] zip Optional parameter: Example:
    # @param [String] city Optional parameter: Example:
    # @param [String] lata Optional parameter: Example:
    # @param [String] npa Optional parameter: Example:
    # @param [String] npa_nxx Optional parameter: Example:
    # @param [String] npa_nxx_x Optional parameter: Example:
    # @param [String] tier Optional parameter: Example:
    # @param [List of String] embed Optional parameter: Example:
    # @return [CoveredRateCenterSearchResponse] response from the API call
    def search_covered_rate_centers(page: nil,
                                    size: nil,
                                    name: nil,
                                    abbreviation: nil,
                                    state: nil,
                                    zip: nil,
                                    city: nil,
                                    lata: nil,
                                    npa: nil,
                                    npa_nxx: nil,
                                    npa_nxx_x: nil,
                                    tier: nil,
                                    embed: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/coveredRateCenters'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'name' => name,
        'abbreviation' => abbreviation,
        'state' => state,
        'zip' => zip,
        'city' => city,
        'lata' => lata,
        'npa' => npa,
        'npaNxx' => npa_nxx,
        'npaNxxX' => npa_nxx_x,
        'tier' => tier,
        'embed' => embed
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Invalid query parameter value',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'CoveredRateCenters',
                                   CoveredRateCenterSearchResponse)
      )
    end

    # Retrieve information about a specific covered rate center identified as
    # the resource.
    # @param [Integer] rate_center_id Required parameter: Example:
    # @return [CoveredRateCenter] response from the API call
    def search_covered_rate_center(rate_center_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/coveredRateCenters/{rateCenterId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'rateCenterId' => { 'value' => rate_center_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'NOT FOUND - the rate center id does not exist in the system',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'CoveredRateCenter',
                                   CoveredRateCenter)
      )
    end

    # TODO
    # @param [String] q Optional parameter: Example:
    # @param [String] type Optional parameter: Example:
    # @return [Object] response from the API call
    def get_do_typeahead_search(q: nil,
                                type: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/typeahead'
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'q' => q,
        'type' => type
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'response', String)
      )
    end

    # list the products associated with a SIP Peer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerProductsResponse] response from the API call
    def get_sip_peer_products(account_id,
                              site_id,
                              sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipPeerProductResponse',
                                   SipPeerProductsResponse)
      )
    end

    # Retrieve sipper messaging settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerMessagingSettingsResponse] response from the API call
    def retrieve_messaging_settings(account_id,
                                    site_id,
                                    sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerMessagingSettingsResponse',
                                   SipPeerMessagingSettingsResponse)
      )
    end

    # create/update/delete messaging settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerMessagingSettings] body Optional parameter: Example:
    # @return [SipPeerMessagingSettingsResponse] response from the API call
    def update_messaging_settings_1(account_id,
                                    site_id,
                                    sip_peer_id,
                                    body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerMessagingSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'settings were successfully created/updated',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerMessagingSettingsResponse',
                                   SipPeerMessagingSettingsResponse)
      )
    end

    # Retrieve sms feature settings for sippeer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerSmsFeatureResponse] response from the API call
    def retrieve_sms_feature(account_id,
                             site_id,
                             sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerSmsFeatureResponse',
                                   SipPeerSmsFeatureResponse)
      )
    end

    # Update sms feature settings. <br/><b>Warning</b>: settings A2pLongCode as
    # 'ON' or 'OFF' will enforce this value for all tns under target sippeer
    # <br/><b>Note</b>: In case of using SMPP protocol, it may be not possible
    # to add or delete hosts with large subnet masks. <br/>Please refer to the
    # documentation
    # ofaccounts/:accountid/sites/:siteid/sippeers/:sippeerid/products/:messagin
    # g/features/sms/smpp/hostsendpoint for information about restrictions and
    # other tips regarding smpp hosts.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerSmsFeature] body Optional parameter: Example:
    # @return [SipPeerSmsFeatureResponse] response from the API call
    def update_sms_feature_1(account_id,
                             site_id,
                             sip_peer_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerSmsFeature', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>CampaignID' \
          ' shouldn\'t be present if all of features' \
          ' \'A2pLongCode\', \'TollFree\' and \'ShortCode\' are' \
          ' disabled</li>   <li>CampaignID is required if at least' \
          ' one of features \'A2pLongCode\', \'TollFree\' and' \
          ' \'ShortCode\' is enabled</li>   <li>Campaign ID \'%s\'' \
          ' was not found in list of authorized Campaign IDs.</li>' \
          '   <li>A2P Campaign ID \'%s\' is not valid. Needs to be' \
          ' between 1 and 64 characters. Only alphanumeric' \
          ' characters,   whitespaces, dashes, underscores and' \
          ' dots are allowed.</li>   <li>A2P Message Class \'%s\'' \
          ' is not valid.</li>   <li>A2P Message Class is required' \
          ' if at least one of features \'A2pLongCode\',' \
          ' \'TollFree\' and \'ShortCode\' is enabled</li>  ' \
          ' <li>A2P Message Class shouldn\'t be present if all of' \
          ' features \'A2pLongCode\', \'TollFree\' and' \
          ' \'ShortCode\' are disabled</li>   <li>A2P Message' \
          ' Class \'%s\' was not found in list of authorized' \
          ' Message Classes.</li>   <li>A2P Message Class is' \
          ' required if \'A2pLongCode\' is enabled.</li>   <li>A2P' \
          ' Message Class shouldn\'t be present if \'A2pLongCode\'' \
          ' is disabled.</li>   <li>A2pLongCode value is invalid.' \
          ' Valid values are: \'ON\', \'OFF\', \'DefaultOn\',' \
          ' \'DefaultOff\'.</li>   <li>Host ip or mask can\'t be' \
          ' changed</li>   <li>47.0.0.0/12 has invalid mask. Valid' \
          ' mask values: 14-32</li>   <li>Termination IP' \
          ' 47.123.17.16/30 overlaps with an address that is' \
          ' already in use</li>   <li>Termination IP' \
          ' 47.123.17.16/30 overlaps with addresses that are' \
          ' already in use: 47.123.17.18</li>   <li>The IP address' \
          ' provided: &lt;47.123.17.17&gt; contains a non zero' \
          ' subnet portion. An equivalent   IP address such as' \
          ' &lt;47.123.17.16&gt; with a zero subnet value must be' \
          ' provided</li>   <li>Can not disable shortcode sms' \
          ' settings for a SipPeer if shortcode numbers with' \
          ' messaging enabled   are present on this' \
          ' SipPeer</li></ul>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access denied. Possible errors in response:<ul>   <li>Configuring' \
          ' subnet values larger than /20 requires Bandwidth staff' \
          ' intervention</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerSmsFeatureResponse',
                                   SipPeerSmsFeatureResponse)
      )
    end

    # Create sms feature settings. <br/><b>Warning</b>: settings A2pLongCode as
    # 'ON' or 'OFF' will enforce this value for all tns under target sippeer
    # <br/><b>Note</b>: In case of using SMPP protocol, it may be not possible
    # to add or delete hosts with large subnet masks. <br/>Please refer to the
    # documentation
    # ofaccounts/:accountid/sites/:siteid/sippeers/:sippeerid/products/:messagin
    # g/features/sms/smpp/hostsendpoint for information about restrictions and
    # other tips regarding smpp hosts.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerSmsFeature] body Optional parameter: Example:
    # @return [SipPeerSmsFeatureResponse] response from the API call
    def create_sms_feature_1(account_id,
                             site_id,
                             sip_peer_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerSmsFeature', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>    <li>Account' \
          ' level settings don`t exist</li>    <li>CampaignID' \
          ' shouldn\'t be present if all of features' \
          ' \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' are' \
          ' disabled</li>    <li>CampaignID is required if at' \
          ' least one of features \'A2pLongCode\', \'TollFree\'' \
          ' and    \'ShortCode\' is enabled</li>    <li>Campaign' \
          ' ID \'%s\' was not found in list of authorized Campaign' \
          ' IDs.</li>    <li>A2P Campaign ID \'%s\' is not valid.' \
          ' Needs to be between 1 and 64 characters. Only' \
          ' alphanumeric    characters, whitespaces, dashes,' \
          ' underscores and dots are allowed.</li>    <li>A2P' \
          ' Message Class \'%s\' is not valid.</li>    <li>A2P' \
          ' Message Class is required if at least one of features' \
          ' \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' is' \
          ' enabled</li>    <li>A2P Message Class shouldn\'t be' \
          ' present if all of features \'A2pLongCode\',' \
          ' \'TollFree\' and    \'ShortCode\' are disabled</li>   ' \
          ' <li>A2P Message Class \'%s\' was not found in list of' \
          ' authorized Message Classes.</li>    <li>A2P Message' \
          ' Class is required if \'A2pLongCode\' is enabled.</li> ' \
          '   <li>A2P Message Class shouldn\'t be present if' \
          ' \'A2pLongCode\' is disabled.</li>    <li>A2pLongCode' \
          ' value is invalid. Valid values are: \'ON\', \'OFF\',' \
          ' \'DefaultOn\', \'DefaultOff\'.</li>    <li>Host ip or' \
          ' mask can\'t be changed</li>    <li>47.0.0.0/12 has' \
          ' invalid mask. Valid mask values: 14-32</li>   ' \
          ' <li>Termination IP 47.123.17.16/30 overlaps with an' \
          ' address that is already in use</li>    <li>Termination' \
          ' IP 47.123.17.16/30 overlaps with addresses that are' \
          ' already in use: 47.123.17.18</li>    <li>The IP' \
          ' address provided: &lt;47.123.17.17&gt; contains a non' \
          ' zero subnet portion. An equivalent IP    address such' \
          ' as &lt;47.123.17.16&gt; with a zero subnet value must' \
          ' be provided</li>    <li>Account \'%s\' has no \'%s\'' \
          ' product feature</li>    <li>Can\'t create sip peer' \
          ' http protocol sms feature without account level http' \
          ' settings.</li></ul>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access denied. Possible errors in response:<ul>   <li>Configuring' \
          ' subnet values larger than /20 requires Bandwidth staff' \
          ' intervention</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerSmsFeatureResponse',
                                   SipPeerSmsFeatureResponse)
      )
    end

    # delete sms settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerSmsFeatureResponse] response from the API call
    def delete_sms_feature(account_id,
                           site_id,
                           sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>  <li>SMS feature' \
          ' can\'t be removed because MMS feature is present,' \
          ' remove it first.</li>  <li>Can not disable SMS feature' \
          ' on Sip Peer because it has telephone numbers with' \
          ' messaging enabled.</li></ul>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'sms settings do not exist',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerSmsFeatureResponse',
                                   SipPeerSmsFeatureResponse)
      )
    end

    # Retrieve mms feature settings for sippeer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [MmsFeatureMmsSettingsResponse] response from the API call
    def retrieve_mms_feature_settings_1(account_id,
                                        site_id,
                                        sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/mms/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'MmsFeatureMmsSettingsResponse',
                                   MmsFeatureMmsSettingsResponse)
      )
    end

    # Retrieve mms feature settings for sippeer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def retrieve_mms_feature(account_id,
                             site_id,
                             sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/mms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # update mms feature settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerMmsFeature] body Optional parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def update_mms_feature_1(account_id,
                             site_id,
                             sip_peer_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/mms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('MmsFeature', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # Set mms feature settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerMmsFeature] body Optional parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def create_mms_feature_1(account_id,
                             site_id,
                             sip_peer_id,
                             body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/mms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('MmsFeature', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Pauload' \
          ' contains two protocol</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # delete mms settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def delete_mms_feature_1(account_id,
                             site_id,
                             sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/mms'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'mms settings were not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # Retrieve smpp hosts
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SmsSmppHostsResponse] response from the API call
    def retrieve_sms_feature_smpp_hosts(account_id,
                                        site_id,
                                        sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms/smpp/hosts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Host ip or' \
          ' mask can\'t be changed</li>   <li>47.0.0.0/12 has' \
          ' invalid mask. Valid mask values: 14-32</li>  ' \
          ' <li>Termination IP 47.123.17.16/30 overlaps with an' \
          ' address that is already in use</li>   <li>Termination' \
          ' IP 47.123.17.16/30 overlaps with addresses that are' \
          ' already in use: 47.123.17.18</li>   <li>The IP address' \
          ' provided: <47.123.17.17> contains a non zero subnet' \
          ' portion. An equivalent IP address such as' \
          ' <47.123.17.16> with a zero subnet value must be' \
          ' provided</li></ul>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access denied. Possible errors in response:<ul>   <li>Configuring' \
          ' subnet values larger than /20 requires Bandwidth staff' \
          ' intervention</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SmsSmppHostsResponse',
                                   SmsSmppHostsResponse)
      )
    end

    # Add smpp host. Host address may or may not include the subnet mask (/32 is
    # assumed if not specified)Regular users can only specify subnets not larger
    # then /20. Updatingsubnet values larger than /20 requires Bandwidth staff
    # intervention (Bandwidth staff may define subnets upto /14)Also, host
    # address should not intersect with addresses used by other services or
    # other accounts,otherwise a validation error will occur.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SmsHost] body Optional parameter: Example:
    # @return [SmsSmppHostsResponse] response from the API call
    def create_sms_feature_smpp_hosts(account_id,
                                      site_id,
                                      sip_peer_id,
                                      body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms/smpp/hosts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SmsHost', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Host ip or' \
          ' mask can\'t be changed</li>   <li>47.0.0.0/12 has' \
          ' invalid mask. Valid mask values: 14-32</li>  ' \
          ' <li>Termination IP 47.123.17.16/30 overlaps with an' \
          ' address that is already in use</li>   <li>Termination' \
          ' IP 47.123.17.16/30 overlaps with addresses that are' \
          ' already in use: 47.123.17.18</li>   <li>The IP address' \
          ' provided: <47.123.17.17> contains a non zero subnet' \
          ' portion. An equivalent IP address such as' \
          ' <47.123.17.16> with a zero subnet value must be' \
          ' provided</li></ul>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access denied. Possible errors in response:<ul>   <li>Configuring' \
          ' subnet values larger than /20 requires Bandwidth staff' \
          ' intervention</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SmsSmppHostsResponse',
                                   SmsSmppHostsResponse)
      )
    end

    # Retrieve smpp host
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [Long] host_id Required parameter: Example:
    # @return [SmsSmppHostsResponse] response from the API call
    def retrieve_sms_feature_smpp_host(account_id,
                                       site_id,
                                       sip_peer_id,
                                       host_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms/smpp/hosts/{hostId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'hostId' => { 'value' => host_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SmsSmppHostsResponse',
                                   SmsSmppHostsResponse)
      )
    end

    # Update smpp host. Host address may or may not include the subnet mask (/32
    # is assumed if not specified)Regular users can only specify subnets not
    # larger then /20. Updatingsubnet values larger than /20 requires Bandwidth
    # staff intervention (Bandwidth staff may define subnets upto /14)Also, host
    # address should not intersect with addresses used by other services or
    # other accounts,otherwise a validation error will occur.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [Long] host_id Required parameter: Example:
    # @param [SmsHost] body Optional parameter: Example:
    # @return [SmsSmppHostsResponse] response from the API call
    def update_sms_feature_smpp_host(account_id,
                                     site_id,
                                     sip_peer_id,
                                     host_id,
                                     body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms/smpp/hosts/{hostId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'hostId' => { 'value' => host_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SmsHost', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Host ip or' \
          ' mask can\'t be changed</li>   <li>47.0.0.0/12 has' \
          ' invalid mask. Valid mask values: 14-32</li>  ' \
          ' <li>Termination IP 47.123.17.16/30 overlaps with an' \
          ' address that is already in use</li>   <li>Termination' \
          ' IP 47.123.17.16/30 overlaps with addresses that are' \
          ' already in use: 47.123.17.18</li>   <li>The IP address' \
          ' provided: <47.123.17.17> contains a non zero subnet' \
          ' portion. An equivalent IP address such as' \
          ' <47.123.17.16> with a zero subnet value must be' \
          ' provided</li></ul>',
          _response
        )
      elsif _response.status_code == 403
        raise APIException.new(
          'Access denied. Possible errors in response:<ul>   <li>Configuring' \
          ' subnet values larger than /20 requires Bandwidth staff' \
          ' intervention</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SmsSmppHostsResponse',
                                   SmsSmppHostsResponse)
      )
    end

    # Delete smpp host. Note: plain users can not delete hosts with subnet masks
    # that are larger then /20, becausethese hosts can only be managed by
    # Bandwidth staff.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [Long] host_id Required parameter: Example:
    # @return [SmsSmppHostsResponse] response from the API call
    def delete_sms_feature_smpp_hosts(account_id,
                                      site_id,
                                      sip_peer_id,
                                      host_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/features/sms/smpp/hosts/{hostId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'hostId' => { 'value' => host_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'smpp host was not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SmsSmppHostsResponse',
                                   SmsSmppHostsResponse)
      )
    end

    # Retrieve sipper application settings
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [String] application_settings Required parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def retrieve_messaging_application(account_id,
                                       site_id,
                                       sip_peer_id,
                                       application_settings)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/{applicationSettings}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'applicationSettings' => { 'value' => application_settings, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # Create/update/delete application settings for sippeer<br>Set the
    # ApplicationsSettings value to 'REMOVE' to unassign application <br>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [String] application_settings Required parameter: Example:
    # @param [ApplicationsSettings] body Optional parameter: Example:
    # @return [MmsFeatureResponse] response from the API call
    def update_messaging_application(account_id,
                                     site_id,
                                     sip_peer_id,
                                     application_settings,
                                     body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/messaging/{applicationSettings}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'applicationSettings' => { 'value' => application_settings, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('ApplicationsSettings', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'MmsFeatureResponse',
                                   MmsFeatureResponse)
      )
    end

    # Retrieve origination settings for sippeer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerOriginationSettingsResponse] response from the API call
    def retrieve_sip_peer_termination_gateway(account_id,
                                              site_id,
                                              sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/origination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerOriginationSettingsResponse',
                                   SipPeerOriginationSettingsResponse)
      )
    end

    # update origination settings<br><ul>   <li>VoiceProtocol is required with
    # possible values: HTTP, SIP</li>   <li>HttpSettings and HttpVoiceV2AppId
    # are optional fields and only allowed if VoiceProtocol is
    # HTTP</li></ul><br>Note: Changing the Voice Protocol from SIP to HTTP will
    # remove Voice Hosts or Voice Host Groups and Termination Hosts, which are
    # configured using API
    # /accounts/{accountId}/sites/{siteId}/sippeers/{sippeerId}.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerOriginationSettings] body Optional parameter: Example:
    # @return [SipPeerOriginationSettingsResponse] response from the API call
    def update_sip_peer_termination_gateway(account_id,
                                            site_id,
                                            sip_peer_id,
                                            body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/origination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerOriginationSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerOriginationSettingsResponse',
                                   SipPeerOriginationSettingsResponse)
      )
    end

    # Set sippeer origination settings<br><ul>    <li>VoiceProtocol is required
    # with possible values: HTTP, SIP</li>    <li>HttpSettings and
    # HttpVoiceV2AppId are optional fields and only allowed if VoiceProtocol is
    # HTTP</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerOriginationSettings] body Optional parameter: Example:
    # @return [SipPeerOriginationSettingsResponse] response from the API call
    def create_sip_peer_termination_gateway(account_id,
                                            site_id,
                                            sip_peer_id,
                                            body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/origination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerOriginationSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Account level' \
          ' settings don`t exist</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerOriginationSettingsResponse',
                                   SipPeerOriginationSettingsResponse)
      )
    end

    # get all sip peer gateway IPs and subnets
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerTerminationProductsResponse] response from the API call
    def get_sip_peer_termination_products(account_id,
                                          site_id,
                                          sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 500
        raise APIException.new(
          'Server Error',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TerminationResponse',
                                   SipPeerTerminationProductsResponse)
      )
    end

    # get all sip peer gateway IPs and subnets
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerGatewayIpsResponse] response from the API call
    def get_sip_peer_termination_gateways(account_id,
                                          site_id,
                                          sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/hosts'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TerminationHosts',
                                   SipPeerGatewayIpsResponse)
      )
    end

    # get sip peer gateway IP or subnet by id
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [Long] gateway_id Required parameter: Example:
    # @return [SipPeerGatewayIpResponse] response from the API call
    def get_sip_peer_termination_gateway(account_id,
                                         site_id,
                                         sip_peer_id,
                                         gateway_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/hosts/{gatewayId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'gatewayId' => { 'value' => gateway_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 404
        raise APIException.new(
          'sip peer gateway ip was not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerGatewayIpResponse',
                                   SipPeerGatewayIpResponse)
      )
    end

    # get all gateway attributes
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Long] gateway_id Required parameter: Example:
    # @param [String] sip_peer_id Required parameter: Example:
    # @return [SipPeerGatewayAttributesResponse] response from the API call
    def get_sip_peer_termination_gateway_attributes(account_id,
                                                    site_id,
                                                    gateway_id,
                                                    sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/hosts/{gatewayId}/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'gatewayId' => { 'value' => gateway_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerGatewayAttributesResponse',
                                   SipPeerGatewayAttributesResponse)
      )
    end

    # get gateway attribute by id
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Long] gateway_id Required parameter: Example:
    # @param [Long] attribute_id Required parameter: Example:
    # @param [String] sip_peer_id Required parameter: Example:
    # @return [SipPeerGatewayAttributeResponse] response from the API call
    def get_sip_peer_termination_gateway_attribute(account_id,
                                                   site_id,
                                                   gateway_id,
                                                   attribute_id,
                                                   sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/hosts/{gatewayId}/settings/{attributeId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'gatewayId' => { 'value' => gateway_id, 'encode' => false },
        'attributeId' => { 'value' => attribute_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerGatewayAttributeResponse',
                                   SipPeerGatewayAttributeResponse)
      )
    end

    # Retrieve termination settings for sippeer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [SipPeerTerminationSettingsResponse] response from the API call
    def retrieve_sip_peer_termination_gateway_1(account_id,
                                                site_id,
                                                sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTerminationSettingsResponse',
                                   SipPeerTerminationSettingsResponse)
      )
    end

    # update termination settings<br>Note: Changing the Voice Protocol from SIP
    # to HTTP will remove Voice Hosts or Voice Host Groups and Termination
    # Hosts, which are configured using API
    # /accounts/{accountId}/sites/{siteId}/sippeers/{sippeerId}.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerTerminationSettings] body Optional parameter: Example:
    # @return [SipPeerTerminationSettingsResponse] response from the API call
    def update_sip_peer_termination_gateway_1(account_id,
                                              site_id,
                                              sip_peer_id,
                                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerTerminationSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTerminationSettingsResponse',
                                   SipPeerTerminationSettingsResponse)
      )
    end

    # Set sippeer termination settings<br><ul>    <li>VoiceProtocol is required
    # with possible values: HTTP, SIP</li>    <li>HttpSettings and
    # HttpVoiceV2AppId are optional fields and only allowed if VoiceProtocol is
    # HTTP</li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerTerminationSettings] body Optional parameter: Example:
    # @return [SipPeerTerminationSettingsResponse] response from the API call
    def create_sip_peer_termination_gateway_1(account_id,
                                              site_id,
                                              sip_peer_id,
                                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/products/termination/settings'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerTerminationSettings',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Account level' \
          ' settings don`t exist</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTerminationSettingsResponse',
                                   SipPeerTerminationSettingsResponse)
      )
    end

    # Retrieve a the data associated with a Sip Peer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [TnSipPeerResponse] response from the API call
    def get_sip_peer(account_id,
                     site_id,
                     sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad request - Sip Peer id is wrong',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipPeerResponse',
                                   TnSipPeerResponse)
      )
    end

    # Update a Sip PeerThere are a few rules used to eliminate IP address
    # collisions.  The primary restriction is on the ability to share Term IP
    # addresses across the Bandwidth Dashboard API structural elements.
    # Essentially...<ul><li>Term Addresses cannot be shared
    # anywhere</li><li>VoiceHost and VoiceHostGroup addresses can be shared
    # between SIP Peers, and can be different than or the same as Term IP
    # Addresses </li></ul>
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [TnSipPeer] body Optional parameter: Example:
    # @return [TnSipPeerResponse] response from the API call
    def update_sip_peer(account_id,
                        site_id,
                        sip_peer_id,
                        body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeer', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>12113 "The' \
          ' provided street address could not be verified. Please' \
          ' submit a valid street address."</li>   <li>13569 "A' \
          ' termination host with HostName = 2.1.1.9 is already in' \
          ' use"</li>   <li>13509 "\'wrong.ip\' is not a valid' \
          ' host. Provide valid IP or domain name"</li>  ' \
          ' <li>13553 "Duplicate host (and port) in' \
          ' VoiceHosts"</li>   <li>13510 "\'wrong.url\' is not a' \
          ' valid Destination URI"</li>   <li>13522 "IsDefaultPeer' \
          ' cannot be false right now. The account requires at' \
          ' least one Default Sip Peer"</li>   <li>13552 "A' \
          ' termination host with HostName = %s and Port = %s is' \
          ' already in use"</li>   <li>12024 "Region with state' \
          ' \'%s\' and country \'%s\' does not exist"</li>  ' \
          ' <li>13576 "Account 9999999 has no CNAM product' \
          ' feature"</li>   <li>13581 "Display option is' \
          ' missing"</li>   <li>13582 "Enforce option is' \
          ' missing"</li>   <li>13563 "Sip Peer \'316167\' account' \
          ' \'9999999\' and site \'45\' does not exist"</li>  ' \
          ' <li>13590 "The supplied CustomerTrafficAllowed value' \
          ' on host %s:%s are not allowed for this sippeer"</li>  ' \
          ' <li>13591 "Termination Settings at the SIP Peer level' \
          ' are not allowed for accounts with the' \
          ' \'DedicatedPrivateNetworkTopology\' product."</li>  ' \
          ' <li>13592 "Calling name \'Display\' and \'Enforced\'' \
          ' values can\'t be updated for' \
          ' \'DedicatedPrivateNetworkTopology\' account.</li>  ' \
          ' <li>13593 "%s has invalid mask. Valid mask values:' \
          ' 24-32"</li>   <li>13594 "%s is not valid host"</li>  ' \
          ' <li>13595 "The IP address provided: %s contains a non' \
          ' zero subnet portion. An equivalent IP address such as' \
          ' %s with a zero subnet value must be provided."</li></ul>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'address couldn\'t be geocoded perfectly and needs some changes',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipPeerResponse',
                                   TnSipPeerResponse)
      )
    end

    # Delete a Sip Peer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @return [TnSipPeerResponse] response from the API call
    def delete_sip_peer(account_id,
                        site_id,
                        sip_peer_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.delete(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>Delete not' \
          ' allowed while a SIP Peer has SMS feature</li></ul>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Sip Peer not found',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipPeerResponse',
                                   TnSipPeerResponse)
      )
    end

    # Retrieve information about a Sip Peer or set of Sip Peers
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @return [SipPeersResponse] response from the API call
    def get_sip_peers(account_id,
                      site_id)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'TNSipPeersResponse',
                                   SipPeersResponse)
      )
    end

    # Create a Sip Peer
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [TnSipPeer] body Optional parameter: Example:
    # @return [TnSipPeerResponse] response from the API call
    def create_sip_peer(account_id,
                        site_id,
                        body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeer', body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:   Possible errors in' \
          ' response:   <ul>        <li>12113 "The provided street' \
          ' address could not be verified. Please submit a valid' \
          ' street address."</li>        <li>13569 "A termination' \
          ' host with HostName = 2.1.1.9 is already in use"</li>  ' \
          '      <li>13509 "\'wrong.ip\' is not a valid host.' \
          ' Provide valid IP or domain name"</li>        <li>13553' \
          ' "Duplicate host (and port) in VoiceHosts"</li>       ' \
          ' <li>13510 "\'wrong.url\' is not a valid Destination' \
          ' URI"</li>        <li>13522 "IsDefaultPeer cannot be' \
          ' false right now. The account requires at least one' \
          ' Default Sip Peer"</li>        <li>13552 "A termination' \
          ' host with HostName = %s and Port = %s is already in' \
          ' use"</li>        <li>12024 "Region with state \'%s\'' \
          ' and country \'%s\' does not exist"</li>       ' \
          ' <li>13576 "Account 9999999 has no CNAM product' \
          ' feature"</li>        <li>13581 "Display option is' \
          ' missing"</li>        <li>13582 "Enforce option is' \
          ' missing"</li>        <li>13590 "The supplied' \
          ' CustomerTrafficAllowed value on host %s:%s are not' \
          ' allowed for this sippeer"</li>        <li>13591' \
          ' "Termination Settings at the SIP Peer level are not' \
          ' allowed for accounts with the' \
          ' \'DedicatedPrivateNetworkTopology\' product."</li>    ' \
          '    <li>13592 "Calling name \'Display\' and' \
          ' \'Enforced\' values can\'t be updated for' \
          ' \'DedicatedPrivateNetworkTopology\' account.</li>     ' \
          '   <li>13593 "%s has invalid mask. Valid mask values:' \
          ' 20-32"</li>        <li>13594 "%s is not valid' \
          ' host"</li>        <li>13595 "The IP address provided:' \
          ' %s contains a non zero subnet portion. An equivalent' \
          ' IP address such as %s with a zero subnet value must be' \
          ' provided."</li>   </ul>',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict - Sip Peer with such name already exists; address' \
          ' couldn\'t be geocoded perfectly and needs some changes',
          _response
        )
      elsif _response.status_code == 503
        raise APIException.new(
          'Service unavailable',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body, 'SipPeerResponse',
                                   TnSipPeerResponse)
      )
    end

    # The POST method moves all telephone numbers specified in the body to the
    # given SIP peer.<br>The source SIP peer is determined by the Telephone
    # Number, i.e. the PUT method can move multiple numbers from different
    # source SIP peers.<br>The destination SIP peer is specified in the
    # URL.<br>NOTE: only a maximum of 5000 Telephone Numbers can be moved in one
    # operation.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerTelephoneNumberBulk] body Optional parameter: Example:
    # @return [SipPeerTelephoneNumberBulkResponse] response from the API call
    def create_sip_peer_telephone_number_bulk(account_id,
                                              site_id,
                                              sip_peer_id,
                                              body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/movetns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerTelephoneNumbers',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>    <li>Shared TNs' \
          ' with messaging cannot be moved to a sippeer without' \
          ' the SMS feature enabled.</li>    <li>Shared TNs with' \
          ' voice cannot be moved to a sippeer with the SMS' \
          ' feature enabled.</li></ul>',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumberMoveResponse',
                                   SipPeerTelephoneNumberBulkResponse)
      )
    end

    # Retrieve information about a Telephone number or set of Telephone numbers
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [String] page Optional parameter: Example:
    # @param [Integer] size Optional parameter: Example:
    # @param [String] include_attributes Optional parameter: Example:
    # @param [String] tn_status Optional parameter: Example:
    # @return [SipPeerTelephoneNumbersResponse] response from the API call
    def get_sip_peer_telephone_numbers(account_id,
                                       site_id,
                                       sip_peer_id,
                                       page: nil,
                                       size: nil,
                                       include_attributes: nil,
                                       tn_status: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/tns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        'page' => page,
        'size' => size,
        'includeAttributes' => include_attributes,
        'tnStatus' => tn_status
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumbersResponse',
                                   SipPeerTelephoneNumbersResponse)
      )
    end

    # <strong>As of MARCH 2nd, 2020 this endpoint will go into sunset and be
    # deactivated.</strong><br/>Moves an existing TN on the account to the
    # specified SIP Peer, and sets the various TN-related options.This API call
    # remains unpublished externally.  /movetns is preferred for TN moving.
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [SipPeerTelephoneNumber] body Optional parameter: Example:
    # @return [SipPeerTelephoneNumberResponse] response from the API call
    def create_sip_peer_telephone_number(account_id,
                                         site_id,
                                         sip_peer_id,
                                         body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/tns'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerTelephoneNumber',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _response.status_code == 400
        raise APIException.new(
          'Bad Request. Possible errors in response:<ul>   <li>13513 "Call' \
          ' Forwarding number \'%s\' is not a valid 10-digit' \
          ' telephone number"</li>   <li>13514 "Number Format' \
          ' \'%s\' is invalid for telephone number \'%s\'"</li>  ' \
          ' <li>13515 "Rewrite User \'%s\' is invalid for' \
          ' telephone number \'%s\'"</li>   <li>13516 "RPID Format' \
          ' \'%s\' is invalid for telephone number \'%s\'"</li>  ' \
          ' <li>13517 "Telephone number \'%s\' is not' \
          ' available"</li>   <li>13518 "Telephone number \'%s\'' \
          ' is not available"</li>   <li>13519 "There is an issue' \
          ' with telephone number \'%s\'. Please contact Customer' \
          ' Service"</li>   <li>13575 "CallingNameDisplay \'%s\'' \
          ' is invalid. Valid values are: \'true\',' \
          ' \'false\'"</li>   <li>13576 "Account \'%s\' has no' \
          ' [CallForwarding|CNAM] product feature"</li>  ' \
          ' <li>13583 "CNAM for \'%s\' is applied at the Location' \
          ' level and it is not applicable at the TN level."</li> ' \
          '  <li>5166 "Sip Peer doesn\'t have Sms feature."</li>  ' \
          ' <li>13670 "Updating of sms attribute is not allowed' \
          ' for %TN"</li></ul>',
          _response
        )
      elsif _response.status_code == 404
        raise APIException.new(
          'Bad Request. Possible errors in response:   13536 "Telephone' \
          ' number %s does not exist on Account %s, Site %s, and' \
          ' Sip Peer %s"   13563 "Sip Peer \'%s\' account \'%s\'' \
          ' and site \'%s\' does not exist"',
          _response
        )
      elsif _response.status_code == 409
        raise APIException.new(
          'Conflict - Telephone number exists on Sip Peer',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumberResponse',
                                   SipPeerTelephoneNumberResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [String] full_number Required parameter: Example:
    # @return [SipPeerTelephoneNumberResponse] response from the API call
    def get_sip_peer_telephone_number(account_id,
                                      site_id,
                                      sip_peer_id,
                                      full_number)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/tns/{fullNumber}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'fullNumber' => { 'value' => full_number, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumberResponse',
                                   SipPeerTelephoneNumberResponse)
      )
    end

    # TODO
    # @param [Integer] account_id Required parameter: Example:
    # @param [Integer] site_id Required parameter: Example:
    # @param [Integer] sip_peer_id Required parameter: Example:
    # @param [String] full_number Required parameter: Example:
    # @param [SipPeerTelephoneNumber] body Optional parameter: Example:
    # @return [SipPeerTelephoneNumberResponse] response from the API call
    def update_replace_sip_peer_telephone_number(account_id,
                                                 site_id,
                                                 sip_peer_id,
                                                 full_number,
                                                 body: nil)
      # Prepare query url.
      _query_builder = config.get_base_uri(Server::DASHBOARDDEFAULT)
      _query_builder << '/accounts/{accountId}/sites/{siteId}/sippeers/{sipPeerId}/tns/{fullNumber}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'accountId' => { 'value' => account_id, 'encode' => false },
        'siteId' => { 'value' => site_id, 'encode' => false },
        'sipPeerId' => { 'value' => sip_peer_id, 'encode' => false },
        'fullNumber' => { 'value' => full_number, 'encode' => false }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/xml',
        'content-type' => 'application/xml; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: XmlUtilities.serialize_to_xml('SipPeerTelephoneNumber',
                                                  body)
      )
      DashboardBasicAuth.apply(config, _request)
      _response = execute_request(_request)
      validate_response(_response)

      # Return appropriate response type.
      ApiResponse.new(
        _response,
        data: XmlUtilities.deserialize_xml(_response.raw_body,
                                   'SipPeerTelephoneNumberResponse',
                                   SipPeerTelephoneNumberResponse)
      )
    end
  end
end
end
