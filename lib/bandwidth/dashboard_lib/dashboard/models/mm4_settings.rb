# bandwidth
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Bandwidth
  # Mm4Settings Model.
  class Mm4Settings < BaseModel
    # TODO: Write general description for this method
    # @return [String]
    attr_accessor :domain

    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :conn_valid_window

    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :max_conn

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :persistent_conn

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :keep_alive_noop

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :skip_ack

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :allow_multi_recepient

    # TODO: Write general description for this method
    # @return [Float]
    attr_accessor :conn_message_ratio

    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :conn_sent_timeout

    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :max_messages_in_queue

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :loop_allowed

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :force_ack

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :async_message_flow_supported

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['domain'] = 'domain'
      @_hash['conn_valid_window'] = 'connValidWindow'
      @_hash['max_conn'] = 'maxConn'
      @_hash['persistent_conn'] = 'persistentConn'
      @_hash['keep_alive_noop'] = 'keepAliveNoop'
      @_hash['skip_ack'] = 'skipAck'
      @_hash['allow_multi_recepient'] = 'allowMultiRecepient'
      @_hash['conn_message_ratio'] = 'connMessageRatio'
      @_hash['conn_sent_timeout'] = 'connSentTimeout'
      @_hash['max_messages_in_queue'] = 'maxMessagesInQueue'
      @_hash['loop_allowed'] = 'loopAllowed'
      @_hash['force_ack'] = 'forceAck'
      @_hash['async_message_flow_supported'] = 'asyncMessageFlowSupported'
      @_hash
    end

    def initialize(domain = nil,
                   conn_valid_window = nil,
                   max_conn = nil,
                   persistent_conn = nil,
                   keep_alive_noop = nil,
                   skip_ack = nil,
                   allow_multi_recepient = nil,
                   conn_message_ratio = nil,
                   conn_sent_timeout = nil,
                   max_messages_in_queue = nil,
                   loop_allowed = nil,
                   force_ack = nil,
                   async_message_flow_supported = nil)
      @domain = domain
      @conn_valid_window = conn_valid_window
      @max_conn = max_conn
      @persistent_conn = persistent_conn
      @keep_alive_noop = keep_alive_noop
      @skip_ack = skip_ack
      @allow_multi_recepient = allow_multi_recepient
      @conn_message_ratio = conn_message_ratio
      @conn_sent_timeout = conn_sent_timeout
      @max_messages_in_queue = max_messages_in_queue
      @loop_allowed = loop_allowed
      @force_ack = force_ack
      @async_message_flow_supported = async_message_flow_supported
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      domain = hash['domain']
      conn_valid_window = hash['connValidWindow']
      max_conn = hash['maxConn']
      persistent_conn = hash['persistentConn']
      keep_alive_noop = hash['keepAliveNoop']
      skip_ack = hash['skipAck']
      allow_multi_recepient = hash['allowMultiRecepient']
      conn_message_ratio = hash['connMessageRatio']
      conn_sent_timeout = hash['connSentTimeout']
      max_messages_in_queue = hash['maxMessagesInQueue']
      loop_allowed = hash['loopAllowed']
      force_ack = hash['forceAck']
      async_message_flow_supported = hash['asyncMessageFlowSupported']

      # Create object from extracted values.
      Mm4Settings.new(domain,
                      conn_valid_window,
                      max_conn,
                      persistent_conn,
                      keep_alive_noop,
                      skip_ack,
                      allow_multi_recepient,
                      conn_message_ratio,
                      conn_sent_timeout,
                      max_messages_in_queue,
                      loop_allowed,
                      force_ack,
                      async_message_flow_supported)
    end

    def self.from_element(root)
      domain = XmlUtilities.from_element(root, 'Domain', String)
      conn_valid_window = XmlUtilities.from_element(root, 'ConnValidWindow',
                                                    Integer)
      max_conn = XmlUtilities.from_element(root, 'MaxConn', Integer)
      persistent_conn = XmlUtilities.from_element(root, 'PersistentConn',
                                                  TrueClass)
      keep_alive_noop = XmlUtilities.from_element(root, 'KeepAliveNoop',
                                                  TrueClass)
      skip_ack = XmlUtilities.from_element(root, 'SkipAck', TrueClass)
      allow_multi_recepient = XmlUtilities.from_element(root,
                                                        'AllowMultiRecepient',
                                                        TrueClass)
      conn_message_ratio = XmlUtilities.from_element(root, 'ConnMessageRatio',
                                                     Float)
      conn_sent_timeout = XmlUtilities.from_element(root, 'ConnSentTimeout',
                                                    Integer)
      max_messages_in_queue = XmlUtilities.from_element(root,
                                                        'MaxMessagesInQueue',
                                                        Integer)
      loop_allowed = XmlUtilities.from_element(root, 'LoopAllowed', TrueClass)
      force_ack = XmlUtilities.from_element(root, 'ForceAck', TrueClass)
      async_message_flow_supported = XmlUtilities.from_element(
        root, 'AsyncMessageFlowSupported', TrueClass
      )

      new(domain,
          conn_valid_window,
          max_conn,
          persistent_conn,
          keep_alive_noop,
          skip_ack,
          allow_multi_recepient,
          conn_message_ratio,
          conn_sent_timeout,
          max_messages_in_queue,
          loop_allowed,
          force_ack,
          async_message_flow_supported)
    end

    def to_xml_element(doc, root_name)
      root = doc.create_element(root_name)

      XmlUtilities.add_as_subelement(doc, root, 'Domain', domain)
      XmlUtilities.add_as_subelement(doc, root, 'ConnValidWindow',
                                     conn_valid_window)
      XmlUtilities.add_as_subelement(doc, root, 'MaxConn', max_conn)
      XmlUtilities.add_as_subelement(doc, root, 'PersistentConn',
                                     persistent_conn)
      XmlUtilities.add_as_subelement(doc, root, 'KeepAliveNoop',
                                     keep_alive_noop)
      XmlUtilities.add_as_subelement(doc, root, 'SkipAck', skip_ack)
      XmlUtilities.add_as_subelement(doc, root, 'AllowMultiRecepient',
                                     allow_multi_recepient)
      XmlUtilities.add_as_subelement(doc, root, 'ConnMessageRatio',
                                     conn_message_ratio)
      XmlUtilities.add_as_subelement(doc, root, 'ConnSentTimeout',
                                     conn_sent_timeout)
      XmlUtilities.add_as_subelement(doc, root, 'MaxMessagesInQueue',
                                     max_messages_in_queue)
      XmlUtilities.add_as_subelement(doc, root, 'LoopAllowed', loop_allowed)
      XmlUtilities.add_as_subelement(doc, root, 'ForceAck', force_ack)
      XmlUtilities.add_as_subelement(doc, root, 'AsyncMessageFlowSupported',
                                     async_message_flow_supported)

      root
    end
  end
end
