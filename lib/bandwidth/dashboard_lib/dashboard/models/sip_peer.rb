# bandwidth
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Bandwidth
  # SipPeer Model.
  class SipPeer < BaseModel
    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :id

    # TODO: Write general description for this method
    # @return [String]
    attr_accessor :peer_name

    # TODO: Write general description for this method
    # @return [String]
    attr_accessor :description

    # TODO: Write general description for this method
    # @return [Boolean]
    attr_accessor :default_peer

    # TODO: Write general description for this method
    # @return [String]
    attr_accessor :destination_uri

    # TODO: Write general description for this method
    # @return [Hosts]
    attr_accessor :voice_hosts

    # TODO: Write general description for this method
    # @return [List of Hosts]
    attr_accessor :voice_host_groups

    # TODO: Write general description for this method
    # @return [SipPeerTerminationHosts]
    attr_accessor :termination_hosts

    # TODO: Write general description for this method
    # @return [List of ProductTypeEnum]
    attr_accessor :product_types

    # TODO: Write general description for this method
    # @return [Address]
    attr_accessor :address

    # TODO: Write general description for this method
    # @return [String]
    attr_accessor :premise_trunks

    # TODO: Write general description for this method
    # @return [SipPeerLineOptionDto]
    attr_accessor :calling_name

    # TODO: Write general description for this method
    # @return [List of Address]
    attr_accessor :suggested_addresses

    # TODO: Write general description for this method
    # @return [Integer]
    attr_accessor :tn_count

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['id'] = 'id'
      @_hash['peer_name'] = 'peerName'
      @_hash['description'] = 'description'
      @_hash['default_peer'] = 'defaultPeer'
      @_hash['destination_uri'] = 'destinationUri'
      @_hash['voice_hosts'] = 'voiceHosts'
      @_hash['voice_host_groups'] = 'voiceHostGroups'
      @_hash['termination_hosts'] = 'terminationHosts'
      @_hash['product_types'] = 'productTypes'
      @_hash['address'] = 'address'
      @_hash['premise_trunks'] = 'premiseTrunks'
      @_hash['calling_name'] = 'callingName'
      @_hash['suggested_addresses'] = 'suggestedAddresses'
      @_hash['tn_count'] = 'tnCount'
      @_hash
    end

    def initialize(id = nil,
                   peer_name = nil,
                   description = nil,
                   default_peer = nil,
                   destination_uri = nil,
                   voice_hosts = nil,
                   voice_host_groups = nil,
                   termination_hosts = nil,
                   product_types = nil,
                   address = nil,
                   premise_trunks = nil,
                   calling_name = nil,
                   suggested_addresses = nil,
                   tn_count = nil)
      @id = id
      @peer_name = peer_name
      @description = description
      @default_peer = default_peer
      @destination_uri = destination_uri
      @voice_hosts = voice_hosts
      @voice_host_groups = voice_host_groups
      @termination_hosts = termination_hosts
      @product_types = product_types
      @address = address
      @premise_trunks = premise_trunks
      @calling_name = calling_name
      @suggested_addresses = suggested_addresses
      @tn_count = tn_count
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      id = hash['id']
      peer_name = hash['peerName']
      description = hash['description']
      default_peer = hash['defaultPeer']
      destination_uri = hash['destinationUri']
      voice_hosts = Hosts.from_hash(hash['voiceHosts']) if hash['voiceHosts']
      # Parameter is an array, so we need to iterate through it
      voice_host_groups = nil
      unless hash['voiceHostGroups'].nil?
        voice_host_groups = []
        hash['voiceHostGroups'].each do |structure|
          voice_host_groups << (Hosts.from_hash(structure) if structure)
        end
      end
      if hash['terminationHosts']
        termination_hosts = SipPeerTerminationHosts.from_hash(hash['terminationHosts'])
      end
      product_types = hash['productTypes']
      address = Address.from_hash(hash['address']) if hash['address']
      premise_trunks = hash['premiseTrunks']
      calling_name = SipPeerLineOptionDto.from_hash(hash['callingName']) if
        hash['callingName']
      # Parameter is an array, so we need to iterate through it
      suggested_addresses = nil
      unless hash['suggestedAddresses'].nil?
        suggested_addresses = []
        hash['suggestedAddresses'].each do |structure|
          suggested_addresses << (Address.from_hash(structure) if structure)
        end
      end
      tn_count = hash['tnCount']

      # Create object from extracted values.
      SipPeer.new(id,
                  peer_name,
                  description,
                  default_peer,
                  destination_uri,
                  voice_hosts,
                  voice_host_groups,
                  termination_hosts,
                  product_types,
                  address,
                  premise_trunks,
                  calling_name,
                  suggested_addresses,
                  tn_count)
    end

    def self.from_element(root)
      id = XmlUtilities.from_element(root, 'PeerId', Integer)
      peer_name = XmlUtilities.from_element(root, 'PeerName', String)
      description = XmlUtilities.from_element(root, 'Description', String)
      default_peer = XmlUtilities.from_element(root, 'IsDefaultPeer', TrueClass)
      destination_uri = XmlUtilities.from_element(root, 'FinalDestinationUri',
                                                  String)
      voice_hosts = XmlUtilities.from_element(root, 'VoiceHosts', Hosts)
      voice_host_groups = XmlUtilities.from_element_to_array(
        root, 'Hosts', Hosts,
        wrapping_element_name: 'VoiceHostGroups'
      )
      termination_hosts = XmlUtilities.from_element(root, 'TerminationHosts',
                                                    SipPeerTerminationHosts)
      product_types = XmlUtilities.from_element_to_array(
        root, 'productTypes', String,
        wrapping_element_name: 'Products'
      )
      address = XmlUtilities.from_element(root, 'Address', Address)
      premise_trunks = XmlUtilities.from_element(root, 'PremiseTrunks', String)
      calling_name = XmlUtilities.from_element(root, 'CallingName',
                                               SipPeerLineOptionDto)
      suggested_addresses = XmlUtilities.from_element_to_array(
        root, 'Address', Address,
        wrapping_element_name: 'SuggestedAddresses'
      )
      tn_count = XmlUtilities.from_element(root, 'TnCount', Integer)

      new(id,
          peer_name,
          description,
          default_peer,
          destination_uri,
          voice_hosts,
          voice_host_groups,
          termination_hosts,
          product_types,
          address,
          premise_trunks,
          calling_name,
          suggested_addresses,
          tn_count)
    end

    def to_xml_element(doc, root_name)
      root = doc.create_element(root_name)

      XmlUtilities.add_as_subelement(doc, root, 'PeerId', id)
      XmlUtilities.add_as_subelement(doc, root, 'PeerName', peer_name)
      XmlUtilities.add_as_subelement(doc, root, 'Description', description)
      XmlUtilities.add_as_subelement(doc, root, 'IsDefaultPeer', default_peer)
      XmlUtilities.add_as_subelement(doc, root, 'FinalDestinationUri',
                                     destination_uri)
      XmlUtilities.add_as_subelement(doc, root, 'VoiceHosts', voice_hosts)
      XmlUtilities.add_array_as_subelement(
        doc, root, 'Hosts', voice_host_groups,
        wrapping_element_name: 'VoiceHostGroups'
      )
      XmlUtilities.add_as_subelement(doc, root, 'TerminationHosts',
                                     termination_hosts)
      XmlUtilities.add_array_as_subelement(doc, root, 'productTypes',
                                           product_types,
                                           wrapping_element_name: 'Products')
      XmlUtilities.add_as_subelement(doc, root, 'Address', address)
      XmlUtilities.add_as_subelement(doc, root, 'PremiseTrunks', premise_trunks)
      XmlUtilities.add_as_subelement(doc, root, 'CallingName', calling_name)
      XmlUtilities.add_array_as_subelement(
        doc, root, 'Address', suggested_addresses,
        wrapping_element_name: 'SuggestedAddresses'
      )
      XmlUtilities.add_as_subelement(doc, root, 'TnCount', tn_count)

      root
    end
  end
end
